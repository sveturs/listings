// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: api/proto/chat/v1/chat.proto

package chatsvcv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ChatService_GetOrCreateChat_FullMethodName    = "/chatsvc.v1.ChatService/GetOrCreateChat"
	ChatService_ListUserChats_FullMethodName      = "/chatsvc.v1.ChatService/ListUserChats"
	ChatService_GetChatByID_FullMethodName        = "/chatsvc.v1.ChatService/GetChatByID"
	ChatService_ArchiveChat_FullMethodName        = "/chatsvc.v1.ChatService/ArchiveChat"
	ChatService_DeleteChat_FullMethodName         = "/chatsvc.v1.ChatService/DeleteChat"
	ChatService_GetChatStats_FullMethodName       = "/chatsvc.v1.ChatService/GetChatStats"
	ChatService_SendMessage_FullMethodName        = "/chatsvc.v1.ChatService/SendMessage"
	ChatService_GetMessages_FullMethodName        = "/chatsvc.v1.ChatService/GetMessages"
	ChatService_StreamMessages_FullMethodName     = "/chatsvc.v1.ChatService/StreamMessages"
	ChatService_MarkMessagesAsRead_FullMethodName = "/chatsvc.v1.ChatService/MarkMessagesAsRead"
	ChatService_GetUnreadCount_FullMethodName     = "/chatsvc.v1.ChatService/GetUnreadCount"
	ChatService_DeleteMessage_FullMethodName      = "/chatsvc.v1.ChatService/DeleteMessage"
	ChatService_UploadAttachment_FullMethodName   = "/chatsvc.v1.ChatService/UploadAttachment"
	ChatService_GetAttachment_FullMethodName      = "/chatsvc.v1.ChatService/GetAttachment"
	ChatService_DeleteAttachment_FullMethodName   = "/chatsvc.v1.ChatService/DeleteAttachment"
)

// ChatServiceClient is the client API for ChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// # ChatService provides RPC methods for managing chat conversations
//
// AUTHORIZATION PATTERN (TRUE MICROSERVICE):
// - All RPCs use JWT middleware to extract user_id from gRPC metadata
// - user_id is NOT passed in request messages (extracted from JWT token)
// - Service layer retrieves user_id from context: userID := ctx.Value("user_id").(int64)
// - Ownership validation happens in service layer
//
// INTEGRATION:
// - Auth Service: JWT validation (via github.com/vondi-global/auth/pkg/grpc/middleware)
// - Listings Service: Validate listing_id, get seller_id, listing title
// - Storefronts Service: Validate storefront_product_id, get seller_id, product title
// - MinIO: Upload/download attachments
type ChatServiceClient interface {
	// GetOrCreateChat retrieves existing chat or creates new one
	// Context: Marketplace listing, B2C product, or direct message
	// AUTHORIZATION: Via JWT middleware (user_id validated)
	// Returns: Chat with last message and unread count
	GetOrCreateChat(ctx context.Context, in *GetOrCreateChatRequest, opts ...grpc.CallOption) (*GetOrCreateChatResponse, error)
	// ListUserChats retrieves all chats for authenticated user
	// Returns: chats with last message, unread count, participant info
	// AUTHORIZATION: Via JWT middleware (user_id validated)
	// Pagination: Offset-based (standard for list views)
	ListUserChats(ctx context.Context, in *ListUserChatsRequest, opts ...grpc.CallOption) (*ListUserChatsResponse, error)
	// GetChatByID retrieves a single chat with details
	// AUTHORIZATION: Via JWT middleware (user must be participant)
	// Returns: Full chat details with last message
	GetChatByID(ctx context.Context, in *GetChatByIDRequest, opts ...grpc.CallOption) (*GetChatByIDResponse, error)
	// ArchiveChat archives/unarchives a chat for current user
	// AUTHORIZATION: Via JWT middleware (user must be participant)
	// SIDE EFFECTS: Updates is_archived flag for current user
	ArchiveChat(ctx context.Context, in *ArchiveChatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteChat permanently deletes a chat (admin only)
	// AUTHORIZATION: Via JWT middleware (admin role required)
	// SIDE EFFECTS: Cascades to messages and attachments
	DeleteChat(ctx context.Context, in *DeleteChatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetChatStats retrieves chat statistics (admin only)
	// AUTHORIZATION: Via JWT middleware (admin role required)
	// Returns: Aggregated stats, daily breakdown
	GetChatStats(ctx context.Context, in *GetChatStatsRequest, opts ...grpc.CallOption) (*GetChatStatsResponse, error)
	// SendMessage sends a new message in a chat
	// SIDE EFFECTS: Updates chat.last_message_at, increments unread count
	// AUTHORIZATION: Via JWT middleware (user must be participant)
	// Validation: content required (1-10000 chars), chat must be active
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
	// GetMessages retrieves messages with cursor-based pagination
	// Supports: before_message_id (load older) or after_message_id (load newer)
	// AUTHORIZATION: Via JWT middleware (user must be participant)
	// Pagination: Cursor-based (message_id) for real-time consistency
	GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error)
	// StreamMessages streams new messages in real-time (server streaming)
	// Use case: Keep UI updated with new messages
	// AUTHORIZATION: Via JWT middleware (user must be participant)
	// FALLBACK: Client can poll GetMessages if streaming fails
	// Real-time: Long-lived connection, pushes messages as they arrive
	StreamMessages(ctx context.Context, in *StreamMessagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamMessagesResponse], error)
	// MarkMessagesAsRead marks messages as read
	// SIDE EFFECTS: Updates message.is_read, message.read_at, decrements unread count
	// AUTHORIZATION: Via JWT middleware (user must be receiver)
	// Supports: Mark specific messages OR mark all in chat
	MarkMessagesAsRead(ctx context.Context, in *MarkMessagesAsReadRequest, opts ...grpc.CallOption) (*MarkMessagesAsReadResponse, error)
	// GetUnreadCount retrieves unread message count
	// Can be for all chats or specific chat
	// AUTHORIZATION: Via JWT middleware (user_id validated)
	// Returns: Total count + per-chat breakdown
	GetUnreadCount(ctx context.Context, in *GetUnreadCountRequest, opts ...grpc.CallOption) (*GetUnreadCountResponse, error)
	// DeleteMessage deletes a message (soft delete)
	// AUTHORIZATION: Via JWT middleware (user must be sender OR admin)
	// SIDE EFFECTS: Message content replaced with "[deleted]"
	DeleteMessage(ctx context.Context, in *DeleteMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UploadAttachment uploads a file attachment
	// Returns: temporary attachment (linked to message via SendMessage)
	// AUTHORIZATION: Via JWT middleware (authenticated user)
	// Validation: File size limits (10MB/50MB/20MB), supported MIME types
	// Storage: MinIO with public URL generation
	UploadAttachment(ctx context.Context, in *UploadAttachmentRequest, opts ...grpc.CallOption) (*UploadAttachmentResponse, error)
	// GetAttachment retrieves attachment metadata
	// AUTHORIZATION: Via JWT middleware (user must have access to parent message)
	// Returns: Full attachment details with public URL
	GetAttachment(ctx context.Context, in *GetAttachmentRequest, opts ...grpc.CallOption) (*GetAttachmentResponse, error)
	// DeleteAttachment deletes an attachment
	// AUTHORIZATION: Via JWT middleware (user must be sender OR admin)
	// SIDE EFFECTS: Removes file from MinIO, deletes DB record
	DeleteAttachment(ctx context.Context, in *DeleteAttachmentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type chatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatServiceClient(cc grpc.ClientConnInterface) ChatServiceClient {
	return &chatServiceClient{cc}
}

func (c *chatServiceClient) GetOrCreateChat(ctx context.Context, in *GetOrCreateChatRequest, opts ...grpc.CallOption) (*GetOrCreateChatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOrCreateChatResponse)
	err := c.cc.Invoke(ctx, ChatService_GetOrCreateChat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) ListUserChats(ctx context.Context, in *ListUserChatsRequest, opts ...grpc.CallOption) (*ListUserChatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserChatsResponse)
	err := c.cc.Invoke(ctx, ChatService_ListUserChats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) GetChatByID(ctx context.Context, in *GetChatByIDRequest, opts ...grpc.CallOption) (*GetChatByIDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetChatByIDResponse)
	err := c.cc.Invoke(ctx, ChatService_GetChatByID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) ArchiveChat(ctx context.Context, in *ArchiveChatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChatService_ArchiveChat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) DeleteChat(ctx context.Context, in *DeleteChatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChatService_DeleteChat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) GetChatStats(ctx context.Context, in *GetChatStatsRequest, opts ...grpc.CallOption) (*GetChatStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetChatStatsResponse)
	err := c.cc.Invoke(ctx, ChatService_GetChatStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMessageResponse)
	err := c.cc.Invoke(ctx, ChatService_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessagesResponse)
	err := c.cc.Invoke(ctx, ChatService_GetMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) StreamMessages(ctx context.Context, in *StreamMessagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamMessagesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[0], ChatService_StreamMessages_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMessagesRequest, StreamMessagesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamMessagesClient = grpc.ServerStreamingClient[StreamMessagesResponse]

func (c *chatServiceClient) MarkMessagesAsRead(ctx context.Context, in *MarkMessagesAsReadRequest, opts ...grpc.CallOption) (*MarkMessagesAsReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkMessagesAsReadResponse)
	err := c.cc.Invoke(ctx, ChatService_MarkMessagesAsRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) GetUnreadCount(ctx context.Context, in *GetUnreadCountRequest, opts ...grpc.CallOption) (*GetUnreadCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUnreadCountResponse)
	err := c.cc.Invoke(ctx, ChatService_GetUnreadCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) DeleteMessage(ctx context.Context, in *DeleteMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChatService_DeleteMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) UploadAttachment(ctx context.Context, in *UploadAttachmentRequest, opts ...grpc.CallOption) (*UploadAttachmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UploadAttachmentResponse)
	err := c.cc.Invoke(ctx, ChatService_UploadAttachment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) GetAttachment(ctx context.Context, in *GetAttachmentRequest, opts ...grpc.CallOption) (*GetAttachmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAttachmentResponse)
	err := c.cc.Invoke(ctx, ChatService_GetAttachment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) DeleteAttachment(ctx context.Context, in *DeleteAttachmentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ChatService_DeleteAttachment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChatServiceServer is the server API for ChatService service.
// All implementations must embed UnimplementedChatServiceServer
// for forward compatibility.
//
// # ChatService provides RPC methods for managing chat conversations
//
// AUTHORIZATION PATTERN (TRUE MICROSERVICE):
// - All RPCs use JWT middleware to extract user_id from gRPC metadata
// - user_id is NOT passed in request messages (extracted from JWT token)
// - Service layer retrieves user_id from context: userID := ctx.Value("user_id").(int64)
// - Ownership validation happens in service layer
//
// INTEGRATION:
// - Auth Service: JWT validation (via github.com/vondi-global/auth/pkg/grpc/middleware)
// - Listings Service: Validate listing_id, get seller_id, listing title
// - Storefronts Service: Validate storefront_product_id, get seller_id, product title
// - MinIO: Upload/download attachments
type ChatServiceServer interface {
	// GetOrCreateChat retrieves existing chat or creates new one
	// Context: Marketplace listing, B2C product, or direct message
	// AUTHORIZATION: Via JWT middleware (user_id validated)
	// Returns: Chat with last message and unread count
	GetOrCreateChat(context.Context, *GetOrCreateChatRequest) (*GetOrCreateChatResponse, error)
	// ListUserChats retrieves all chats for authenticated user
	// Returns: chats with last message, unread count, participant info
	// AUTHORIZATION: Via JWT middleware (user_id validated)
	// Pagination: Offset-based (standard for list views)
	ListUserChats(context.Context, *ListUserChatsRequest) (*ListUserChatsResponse, error)
	// GetChatByID retrieves a single chat with details
	// AUTHORIZATION: Via JWT middleware (user must be participant)
	// Returns: Full chat details with last message
	GetChatByID(context.Context, *GetChatByIDRequest) (*GetChatByIDResponse, error)
	// ArchiveChat archives/unarchives a chat for current user
	// AUTHORIZATION: Via JWT middleware (user must be participant)
	// SIDE EFFECTS: Updates is_archived flag for current user
	ArchiveChat(context.Context, *ArchiveChatRequest) (*emptypb.Empty, error)
	// DeleteChat permanently deletes a chat (admin only)
	// AUTHORIZATION: Via JWT middleware (admin role required)
	// SIDE EFFECTS: Cascades to messages and attachments
	DeleteChat(context.Context, *DeleteChatRequest) (*emptypb.Empty, error)
	// GetChatStats retrieves chat statistics (admin only)
	// AUTHORIZATION: Via JWT middleware (admin role required)
	// Returns: Aggregated stats, daily breakdown
	GetChatStats(context.Context, *GetChatStatsRequest) (*GetChatStatsResponse, error)
	// SendMessage sends a new message in a chat
	// SIDE EFFECTS: Updates chat.last_message_at, increments unread count
	// AUTHORIZATION: Via JWT middleware (user must be participant)
	// Validation: content required (1-10000 chars), chat must be active
	SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error)
	// GetMessages retrieves messages with cursor-based pagination
	// Supports: before_message_id (load older) or after_message_id (load newer)
	// AUTHORIZATION: Via JWT middleware (user must be participant)
	// Pagination: Cursor-based (message_id) for real-time consistency
	GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error)
	// StreamMessages streams new messages in real-time (server streaming)
	// Use case: Keep UI updated with new messages
	// AUTHORIZATION: Via JWT middleware (user must be participant)
	// FALLBACK: Client can poll GetMessages if streaming fails
	// Real-time: Long-lived connection, pushes messages as they arrive
	StreamMessages(*StreamMessagesRequest, grpc.ServerStreamingServer[StreamMessagesResponse]) error
	// MarkMessagesAsRead marks messages as read
	// SIDE EFFECTS: Updates message.is_read, message.read_at, decrements unread count
	// AUTHORIZATION: Via JWT middleware (user must be receiver)
	// Supports: Mark specific messages OR mark all in chat
	MarkMessagesAsRead(context.Context, *MarkMessagesAsReadRequest) (*MarkMessagesAsReadResponse, error)
	// GetUnreadCount retrieves unread message count
	// Can be for all chats or specific chat
	// AUTHORIZATION: Via JWT middleware (user_id validated)
	// Returns: Total count + per-chat breakdown
	GetUnreadCount(context.Context, *GetUnreadCountRequest) (*GetUnreadCountResponse, error)
	// DeleteMessage deletes a message (soft delete)
	// AUTHORIZATION: Via JWT middleware (user must be sender OR admin)
	// SIDE EFFECTS: Message content replaced with "[deleted]"
	DeleteMessage(context.Context, *DeleteMessageRequest) (*emptypb.Empty, error)
	// UploadAttachment uploads a file attachment
	// Returns: temporary attachment (linked to message via SendMessage)
	// AUTHORIZATION: Via JWT middleware (authenticated user)
	// Validation: File size limits (10MB/50MB/20MB), supported MIME types
	// Storage: MinIO with public URL generation
	UploadAttachment(context.Context, *UploadAttachmentRequest) (*UploadAttachmentResponse, error)
	// GetAttachment retrieves attachment metadata
	// AUTHORIZATION: Via JWT middleware (user must have access to parent message)
	// Returns: Full attachment details with public URL
	GetAttachment(context.Context, *GetAttachmentRequest) (*GetAttachmentResponse, error)
	// DeleteAttachment deletes an attachment
	// AUTHORIZATION: Via JWT middleware (user must be sender OR admin)
	// SIDE EFFECTS: Removes file from MinIO, deletes DB record
	DeleteAttachment(context.Context, *DeleteAttachmentRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedChatServiceServer()
}

// UnimplementedChatServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChatServiceServer struct{}

func (UnimplementedChatServiceServer) GetOrCreateChat(context.Context, *GetOrCreateChatRequest) (*GetOrCreateChatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOrCreateChat not implemented")
}
func (UnimplementedChatServiceServer) ListUserChats(context.Context, *ListUserChatsRequest) (*ListUserChatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUserChats not implemented")
}
func (UnimplementedChatServiceServer) GetChatByID(context.Context, *GetChatByIDRequest) (*GetChatByIDResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetChatByID not implemented")
}
func (UnimplementedChatServiceServer) ArchiveChat(context.Context, *ArchiveChatRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ArchiveChat not implemented")
}
func (UnimplementedChatServiceServer) DeleteChat(context.Context, *DeleteChatRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteChat not implemented")
}
func (UnimplementedChatServiceServer) GetChatStats(context.Context, *GetChatStatsRequest) (*GetChatStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetChatStats not implemented")
}
func (UnimplementedChatServiceServer) SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedChatServiceServer) GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMessages not implemented")
}
func (UnimplementedChatServiceServer) StreamMessages(*StreamMessagesRequest, grpc.ServerStreamingServer[StreamMessagesResponse]) error {
	return status.Error(codes.Unimplemented, "method StreamMessages not implemented")
}
func (UnimplementedChatServiceServer) MarkMessagesAsRead(context.Context, *MarkMessagesAsReadRequest) (*MarkMessagesAsReadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkMessagesAsRead not implemented")
}
func (UnimplementedChatServiceServer) GetUnreadCount(context.Context, *GetUnreadCountRequest) (*GetUnreadCountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUnreadCount not implemented")
}
func (UnimplementedChatServiceServer) DeleteMessage(context.Context, *DeleteMessageRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteMessage not implemented")
}
func (UnimplementedChatServiceServer) UploadAttachment(context.Context, *UploadAttachmentRequest) (*UploadAttachmentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadAttachment not implemented")
}
func (UnimplementedChatServiceServer) GetAttachment(context.Context, *GetAttachmentRequest) (*GetAttachmentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAttachment not implemented")
}
func (UnimplementedChatServiceServer) DeleteAttachment(context.Context, *DeleteAttachmentRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteAttachment not implemented")
}
func (UnimplementedChatServiceServer) mustEmbedUnimplementedChatServiceServer() {}
func (UnimplementedChatServiceServer) testEmbeddedByValue()                     {}

// UnsafeChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatServiceServer will
// result in compilation errors.
type UnsafeChatServiceServer interface {
	mustEmbedUnimplementedChatServiceServer()
}

func RegisterChatServiceServer(s grpc.ServiceRegistrar, srv ChatServiceServer) {
	// If the following call panics, it indicates UnimplementedChatServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChatService_ServiceDesc, srv)
}

func _ChatService_GetOrCreateChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrCreateChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetOrCreateChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_GetOrCreateChat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetOrCreateChat(ctx, req.(*GetOrCreateChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_ListUserChats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserChatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).ListUserChats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_ListUserChats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).ListUserChats(ctx, req.(*ListUserChatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_GetChatByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChatByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetChatByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_GetChatByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetChatByID(ctx, req.(*GetChatByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_ArchiveChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).ArchiveChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_ArchiveChat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).ArchiveChat(ctx, req.(*ArchiveChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_DeleteChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).DeleteChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_DeleteChat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).DeleteChat(ctx, req.(*DeleteChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_GetChatStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChatStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetChatStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_GetChatStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetChatStats(ctx, req.(*GetChatStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).SendMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_GetMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_GetMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetMessages(ctx, req.(*GetMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_StreamMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMessagesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).StreamMessages(m, &grpc.GenericServerStream[StreamMessagesRequest, StreamMessagesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_StreamMessagesServer = grpc.ServerStreamingServer[StreamMessagesResponse]

func _ChatService_MarkMessagesAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkMessagesAsReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).MarkMessagesAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_MarkMessagesAsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).MarkMessagesAsRead(ctx, req.(*MarkMessagesAsReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_GetUnreadCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnreadCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetUnreadCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_GetUnreadCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetUnreadCount(ctx, req.(*GetUnreadCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_DeleteMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).DeleteMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_DeleteMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).DeleteMessage(ctx, req.(*DeleteMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_UploadAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).UploadAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_UploadAttachment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).UploadAttachment(ctx, req.(*UploadAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_GetAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_GetAttachment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetAttachment(ctx, req.(*GetAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_DeleteAttachment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).DeleteAttachment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_DeleteAttachment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).DeleteAttachment(ctx, req.(*DeleteAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChatService_ServiceDesc is the grpc.ServiceDesc for ChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatsvc.v1.ChatService",
	HandlerType: (*ChatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOrCreateChat",
			Handler:    _ChatService_GetOrCreateChat_Handler,
		},
		{
			MethodName: "ListUserChats",
			Handler:    _ChatService_ListUserChats_Handler,
		},
		{
			MethodName: "GetChatByID",
			Handler:    _ChatService_GetChatByID_Handler,
		},
		{
			MethodName: "ArchiveChat",
			Handler:    _ChatService_ArchiveChat_Handler,
		},
		{
			MethodName: "DeleteChat",
			Handler:    _ChatService_DeleteChat_Handler,
		},
		{
			MethodName: "GetChatStats",
			Handler:    _ChatService_GetChatStats_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _ChatService_SendMessage_Handler,
		},
		{
			MethodName: "GetMessages",
			Handler:    _ChatService_GetMessages_Handler,
		},
		{
			MethodName: "MarkMessagesAsRead",
			Handler:    _ChatService_MarkMessagesAsRead_Handler,
		},
		{
			MethodName: "GetUnreadCount",
			Handler:    _ChatService_GetUnreadCount_Handler,
		},
		{
			MethodName: "DeleteMessage",
			Handler:    _ChatService_DeleteMessage_Handler,
		},
		{
			MethodName: "UploadAttachment",
			Handler:    _ChatService_UploadAttachment_Handler,
		},
		{
			MethodName: "GetAttachment",
			Handler:    _ChatService_GetAttachment_Handler,
		},
		{
			MethodName: "DeleteAttachment",
			Handler:    _ChatService_DeleteAttachment_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMessages",
			Handler:       _ChatService_StreamMessages_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/proto/chat/v1/chat.proto",
}
