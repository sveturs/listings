--- Содержимое файла: backend/main.go ---

package main

import (
    "context"
    "fmt"
    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/fiber/v2/middleware/cors"
    "github.com/jackc/pgx/v5/pgxpool"
    "github.com/disintegration/imaging"
    "log"
    "mime/multipart"
    "os"
    "path/filepath"
    "strconv"
    "strings"
    "time"
)
type RoomImage struct {
    ID          int    `json:"id"`
    RoomID      int    `json:"room_id"`
    FilePath    string `json:"file_path"`
    FileName    string `json:"file_name"`
    FileSize    int    `json:"file_size"`
    ContentType string `json:"content_type"`
    IsMain      bool   `json:"is_main"`
    CreatedAt   time.Time `json:"created_at"` // Изменено с string на time.Time
}
func main() {
	app := fiber.New()

	// Настройка CORS
	app.Use(cors.New(cors.Config{
		AllowOrigins: "http://localhost:3001,http://localhost:3000",
		AllowMethods: "GET,POST,DELETE,PUT",
		AllowHeaders: "Origin, Content-Type, Accept",
		ExposeHeaders: "Content-Length",
		AllowCredentials: true,
	}))

    os.MkdirAll("./uploads", os.ModePerm)
	// Подключение к базе данных
	dbURL := os.Getenv("DATABASE_URL")
	pool, err := pgxpool.New(context.Background(), dbURL)
	if err != nil {
		log.Fatalf("Ошибка подключения к базе данных: %v", err)
	}
	defer pool.Close()
    processImage := func(file *multipart.FileHeader) (string, error) {
        src, err := file.Open()
        if err != nil {
            return "", err
        }
        defer src.Close()

        // Генерируем уникальное имя файла
        ext := filepath.Ext(file.Filename)
        fileName := fmt.Sprintf("%d%s", time.Now().UnixNano(), ext)
        filePath := filepath.Join("uploads", fileName)

        // Создаем файл для сохранения
        dst, err := os.Create(filePath)
        if err != nil {
            return "", err
        }
        defer dst.Close()

        // Открываем изображение для обработки
        img, err := imaging.Decode(src)
        if err != nil {
            return "", err
        }

        // Изменяем размер изображения (например, максимальная ширина 1200px)
        resized := imaging.Resize(img, 1200, 0, imaging.Lanczos)

        // Сохраняем обработанное изображение
        err = imaging.Save(resized, filePath)
        if err != nil {
            return "", err
        }

        return fileName, nil
    }

    // Добавляем эндпоинт для загрузки изображений
    app.Post("/rooms/:id/images", func(c *fiber.Ctx) error {
		log.Printf("Начало загрузки изображений")
		roomID, err := strconv.Atoi(c.Params("id"))
		if err != nil {
			log.Printf("Ошибка преобразования ID комнаты: %v", err)
			return c.Status(400).SendString("Неверный ID комнаты")
		}
	
		form, err := c.MultipartForm()
		if err != nil {
			log.Printf("Ошибка получения формы: %v", err)
			return c.Status(400).SendString("Ошибка получения файлов")
		}
	
		files := form.File["images"]
		log.Printf("Получено %d файлов", len(files))

        isMain := len(files) > 0 // Первое изображение будет главным

        var uploadedImages []RoomImage
        for _, file := range files {
            // Проверяем тип файла
            if !strings.HasPrefix(file.Header.Get("Content-Type"), "image/") {
                return c.Status(400).SendString("Допустимы только изображения")
            }

            // Проверяем размер файла (например, максимум 5MB)
            if file.Size > 5*1024*1024 {
                return c.Status(400).SendString("Размер файла не должен превышать 5MB")
            }

            // Обрабатываем и сохраняем изображение
            fileName, err := processImage(file)
            if err != nil {
                log.Printf("Ошибка обработки изображения: %v", err)
                return c.Status(500).SendString("Ошибка обработки изображения")
            }

            // Сохраняем информацию в базу данных
            var imageID int
            err = pool.QueryRow(context.Background(), `
                INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main)
                VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING id
            `, roomID, fileName, file.Filename, file.Size, file.Header.Get("Content-Type"), isMain).Scan(&imageID)

            if err != nil {
                log.Printf("Ошибка сохранения информации об изображении: %v", err)
                return c.Status(500).SendString("Ошибка сохранения информации об изображении")
            }

            uploadedImages = append(uploadedImages, RoomImage{
                ID:          imageID,
                RoomID:      roomID,
                FilePath:    fileName,
                FileName:    file.Filename,
                FileSize:    int(file.Size),
                ContentType: file.Header.Get("Content-Type"),
                IsMain:     isMain,
            })

            isMain = false // Только первое изображение главное
        }

        return c.JSON(uploadedImages)
    })

    // Получение изображений комнаты
    app.Get("/rooms/:id/images", func(c *fiber.Ctx) error {
		roomID := c.Params("id")
		log.Printf("Получение изображений для комнаты: %s", roomID)
		
		rows, err := pool.Query(context.Background(), `
			SELECT id, room_id, file_path, file_name, file_size, content_type, is_main, created_at
			FROM room_images
			WHERE room_id = $1
			ORDER BY is_main DESC, created_at DESC
		`, roomID)
		if err != nil {
			log.Printf("Ошибка запроса изображений: %v", err)
			return c.Status(500).SendString("Ошибка получения изображений")
		}
		defer rows.Close()
	
		var images []RoomImage
		for rows.Next() {
			var img RoomImage
			err := rows.Scan(
				&img.ID,
				&img.RoomID,
				&img.FilePath,
				&img.FileName,
				&img.FileSize,
				&img.ContentType,
				&img.IsMain,
				&img.CreatedAt,
			)
			if err != nil {
				log.Printf("Ошибка сканирования изображения: %v", err)
				continue
			}
			images = append(images, img)
		}
	
		if len(images) == 0 {
			log.Printf("Изображения не найдены для комнаты: %s", roomID)
		} else {
			log.Printf("Найдено %d изображений для комнаты: %s", len(images), roomID)
		}
	
		return c.JSON(images)
	})

    // Удаление изображения
    app.Delete("/rooms/:roomId/images/:imageId", func(c *fiber.Ctx) error {
        imageID := c.Params("imageId")
        var filePath string
        err := pool.QueryRow(context.Background(), "SELECT file_path FROM room_images WHERE id = $1", imageID).Scan(&filePath)
        if err != nil {
            return c.Status(404).SendString("Изображение не найдено")
        }

        // Удаляем файл
        os.Remove(filepath.Join("uploads", filePath))

        // Удаляем запись из базы
        _, err = pool.Exec(context.Background(), "DELETE FROM room_images WHERE id = $1", imageID)
        if err != nil {
            return c.Status(500).SendString("Ошибка удаления изображения")
        }

        return c.SendString("Изображение удалено")
    })

    // Статическая раздача изображений
    app.Static("/uploads", "./uploads")

	// Главный маршрут
	app.Get("/", func(c *fiber.Ctx) error {
		return c.SendString("Hostel Booking System API с PostgreSQL")
	})

	// Добавление пользователя
	app.Post("/users", func(c *fiber.Ctx) error {
		type User struct {
			Name  string `json:"name"`
			Email string `json:"email"`
		}
	
		var user User
		if err := c.BodyParser(&user); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}
	
		_, err := pool.Exec(context.Background(), "INSERT INTO users (name, email) VALUES ($1, $2)", user.Name, user.Email)
		if err != nil {
			if strings.Contains(err.Error(), "unique constraint") {
				return c.Status(400).SendString("Email уже используется")
			}
			log.Printf("Ошибка добавления пользователя: %v", err)
			return c.Status(500).SendString("Ошибка добавления пользователя")
		}
	
		return c.SendString("Пользователь добавлен успешно")
	})
	
type Room struct {
    Name              string  `json:"name"`
    Capacity          int     `json:"capacity"`
    PricePerNight     *float64 `json:"price_per_night"`
    AddressStreet     string  `json:"address_street"`
    AddressCity       string  `json:"address_city"`
    AddressState      string  `json:"address_state"`
    AddressCountry    string  `json:"address_country"`
    AddressPostalCode string  `json:"address_postal_code"`
    AccommodationType string  `json:"accommodation_type"`
    IsShared          bool    `json:"is_shared"`
    TotalBeds         *int     `json:"total_beds,omitempty"`
    AvailableBeds     *int     `json:"available_beds,omitempty"`
    HasPrivateBathroom bool   `json:"has_private_bathroom"`
}

type Bed struct {
    ID            int     `json:"id"`
    RoomID        int     `json:"room_id"`
    BedNumber     string  `json:"bed_number"`  // изменено с int на string
    IsAvailable   bool    `json:"is_available"`
    PricePerNight float64 `json:"price_per_night"`
}

type BedBooking struct {
    ID        int       `json:"id"`
    BedID     int       `json:"bed_id"`
    UserID    int       `json:"user_id"`
    StartDate string    `json:"start_date"`
    EndDate   string    `json:"end_date"`
}
app.Post("/rooms", func(c *fiber.Ctx) error {
    var room Room
    if err := c.BodyParser(&room); err != nil {
        return c.Status(400).SendString("Неверный формат данных")
    }

    var roomId int
    err := pool.QueryRow(context.Background(), `
        INSERT INTO rooms (
            name, capacity, price_per_night,
            address_street, address_city, address_state,
            address_country, address_postal_code,
            accommodation_type, is_shared,
            total_beds, available_beds, has_private_bathroom
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
        RETURNING id`,
        room.Name, room.Capacity, room.PricePerNight,
        room.AddressStreet, room.AddressCity, room.AddressState,
        room.AddressCountry, room.AddressPostalCode,
        room.AccommodationType, room.IsShared,
        room.TotalBeds, room.AvailableBeds, room.HasPrivateBathroom,
    ).Scan(&roomId)

    if err != nil {
        if strings.Contains(err.Error(), "unique constraint") {
            return c.Status(400).SendString("Комната с таким названием уже существует")
        }
        log.Printf("Ошибка добавления комнаты: %v", err)
        return c.Status(500).SendString("Ошибка добавления комнаты")
    }

    return c.JSON(fiber.Map{"id": roomId})
})
	// Добавление кровати
// Обработчик создания кровати
app.Post("/rooms/:id/beds", func(c *fiber.Ctx) error {
    type BedRequest struct {
        BedNumber    string  `json:"bed_number"`
        PricePerNight float64 `json:"price_per_night"`
    }

    roomID, err := strconv.Atoi(c.Params("id"))
    if err != nil {
        return c.Status(400).SendString("Неверный ID комнаты")
    }

    var bedReq BedRequest
    if err := c.BodyParser(&bedReq); err != nil {
        log.Printf("Ошибка парсинга данных: %v", err)
        return c.Status(400).SendString("Неверный формат данных")
    }

    // Проверяем, существует ли комната
    var roomExists bool
    err = pool.QueryRow(context.Background(), 
        "SELECT EXISTS(SELECT 1 FROM rooms WHERE id = $1)", 
        roomID).Scan(&roomExists)
    if err != nil || !roomExists {
        return c.Status(404).SendString("Комната не найдена")
    }

    // Добавляем кровать
    var bedID int
    err = pool.QueryRow(context.Background(), `
        INSERT INTO beds (room_id, bed_number, price_per_night, is_available) 
        VALUES ($1, $2, $3, true)
        RETURNING id`,
        roomID, bedReq.BedNumber, bedReq.PricePerNight).Scan(&bedID)

    if err != nil {
        log.Printf("Ошибка добавления кровати: %v", err)
        return c.Status(500).SendString("Ошибка добавления кровати")
    }

    return c.JSON(fiber.Map{
        "id": bedID,
        "room_id": roomID,
        "bed_number": bedReq.BedNumber,
        "price_per_night": bedReq.PricePerNight,
        "is_available": true    })
})

// Получение доступных кроватей
app.Get("/rooms/:id/available-beds", func(c *fiber.Ctx) error {
    roomID := c.Params("id")
    startDate := c.Query("start_date")
    endDate := c.Query("end_date")

    query := `
        SELECT b.id, b.bed_number, b.price_per_night
        FROM beds b
        WHERE b.room_id = $1
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE $2 < end_date AND $3 > start_date
            AND status != 'cancelled'
        )
    `

    rows, err := pool.Query(context.Background(), query, roomID, startDate, endDate)
    if err != nil {
        return c.Status(500).SendString("Ошибка получения списка кроватей")
    }
    defer rows.Close()

    var beds []Bed
    for rows.Next() {
        var bed Bed
        if err := rows.Scan(&bed.ID, &bed.BedNumber, &bed.PricePerNight); err != nil {
            continue
        }
        beds = append(beds, bed)
    }

    return c.JSON(beds)
})
	// В endpoint получения списка комнат обновляем запрос
	app.Get("/rooms", func(c *fiber.Ctx) error {
		capacity := c.Query("capacity")
		startDate := c.Query("start_date")
		endDate := c.Query("end_date")
		minPrice := c.Query("min_price")
		maxPrice := c.Query("max_price")
		city := c.Query("city")      // Добавляем параметр города
		country := c.Query("country") // Добавляем параметр страны
	
		query := `
        SELECT id, name, capacity, price_per_night, address_street, address_city, 
       		address_state, address_country, address_postal_code,
       		accommodation_type, is_shared, COALESCE(total_beds, 0) AS total_beds, 
       		COALESCE(available_beds, 0) AS available_beds, 
       		has_private_bathroom, created_at 
		FROM rooms`
		args := []interface{}{}
		conditions := []string{}
	
		// Фильтр по вместимости
		if capacity != "" {
			conditions = append(conditions, "capacity >= $"+strconv.Itoa(len(args)+1))
			args = append(args, capacity)
		}
	
		// Фильтр по минимальной цене
		if minPrice != "" {
			minPriceFloat, err := strconv.ParseFloat(minPrice, 64)
			if err != nil {
				return c.Status(400).SendString("Некорректное значение минимальной цены")
			}
			conditions = append(conditions, "price_per_night >= $"+strconv.Itoa(len(args)+1))
			args = append(args, minPriceFloat)
		}
	
		// Фильтр по максимальной цене
		if maxPrice != "" {
			maxPriceFloat, err := strconv.ParseFloat(maxPrice, 64)
			if err != nil {
				return c.Status(400).SendString("Некорректное значение максимальной цены")
			}
			conditions = append(conditions, "price_per_night <= $"+strconv.Itoa(len(args)+1))
			args = append(args, maxPriceFloat)
		}
	
		// Проверка корректности диапазона цен
		if minPrice != "" && maxPrice != "" {
			minPriceFloat, _ := strconv.ParseFloat(minPrice, 64)
			maxPriceFloat, _ := strconv.ParseFloat(maxPrice, 64)
			if minPriceFloat > maxPriceFloat {
				return c.Status(400).SendString("Минимальная цена не может быть больше максимальной")
			}
		}
	
		// Фильтр по доступности дат
		if startDate != "" && endDate != "" {
			conditions = append(conditions, `
				id NOT IN (
					SELECT room_id FROM bookings 
					WHERE $`+strconv.Itoa(len(args)+1)+` < end_date 
					  AND $`+strconv.Itoa(len(args)+2)+` > start_date
				)
			`)
			args = append(args, startDate, endDate)
		}
	    if city != "" {
			conditions = append(conditions, "address_city ILIKE $"+strconv.Itoa(len(args)+1))
			args = append(args, "%"+city+"%")
		}
		if country != "" {
			conditions = append(conditions, "address_country ILIKE $"+strconv.Itoa(len(args)+1))
			args = append(args, "%"+country+"%")
		}




		// Добавление условий в запрос
		if len(conditions) > 0 {
			query += " WHERE " + strings.Join(conditions, " AND ")
		}
	
		// Логирование запроса
		log.Printf("SQL Query: %s, Args: %v", query, args)
	
		// Выполнение запроса
		rows, err := pool.Query(context.Background(), query, args...)
		if err != nil {
			log.Printf("Ошибка выполнения запроса: %v", err)
			return c.Status(500).SendString("Ошибка получения списка комнат")
		}
		defer rows.Close()
	
		// Обработка результатов
    var rooms []map[string]interface{}
    for rows.Next() {
        var id, capacity, totalBeds, availableBeds int
        var name, addressStreet, addressCity, addressState, 
            addressCountry, addressPostalCode, accommodationType string
        var pricePerNight float64
        var isShared, hasPrivateBathroom bool
        var createdAt time.Time
        
        if err := rows.Scan(
            &id, &name, &capacity, &pricePerNight,
            &addressStreet, &addressCity, &addressState,
            &addressCountry, &addressPostalCode,
            &accommodationType, &isShared,
            &totalBeds, &availableBeds, &hasPrivateBathroom,
            &createdAt,
        ); err != nil {
            log.Printf("Ошибка сканирования строки: %v", err)
            return c.Status(500).SendString("Ошибка обработки данных")
        }
        
        rooms = append(rooms, map[string]interface{}{
            "id":                 id,
            "name":               name,
            "capacity":           capacity,
            "price_per_night":    pricePerNight,
            "address_street":     addressStreet,
            "address_city":       addressCity,
            "address_state":      addressState,
            "address_country":    addressCountry,
            "address_postal_code": addressPostalCode,
            "accommodation_type":  accommodationType,
            "is_shared":          isShared,
            "total_beds":         totalBeds,
            "available_beds":     availableBeds,
            "has_private_bathroom": hasPrivateBathroom,
            "created_at":         createdAt.Format("2006-01-02 15:04:05"),
        })
    }

    return c.JSON(rooms)
})
	
	
	// Добавление бронирования
	app.Post("/bookings", func(c *fiber.Ctx) error {
		type Booking struct {
			UserID    int    `json:"user_id"`
			RoomID    int    `json:"room_id"`
			StartDate string `json:"start_date"`
			EndDate   string `json:"end_date"`
		}
	
		var booking Booking
		if err := c.BodyParser(&booking); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}
	
		// Проверяем, существует ли пользователь
		var userCount int
		if err := pool.QueryRow(context.Background(), "SELECT COUNT(*) FROM users WHERE id = $1", booking.UserID).Scan(&userCount); err != nil || userCount == 0 {
			return c.Status(400).SendString("Пользователь не найден")
		}
	
		// Проверяем, существует ли комната
		var roomCount int
		if err := pool.QueryRow(context.Background(), "SELECT COUNT(*) FROM rooms WHERE id = $1", booking.RoomID).Scan(&roomCount); err != nil || roomCount == 0 {
			return c.Status(400).SendString("Комната не найдена")
		}
	
		// Проверяем доступность комнаты
		var count int
		err := pool.QueryRow(context.Background(), `
			SELECT COUNT(*) FROM bookings 
			WHERE room_id = $1 AND $2 < end_date AND $3 > start_date
		`, booking.RoomID, booking.StartDate, booking.EndDate).Scan(&count)
		if err != nil {
			log.Printf("Ошибка проверки доступности комнаты: %v", err)
			return c.Status(500).SendString("Ошибка проверки доступности комнаты")
		}
		if count > 0 {
			return c.Status(400).SendString("Комната занята на указанные даты")
		}
	
		_, err = pool.Exec(context.Background(), `
			INSERT INTO bookings (user_id, room_id, start_date, end_date) 
			VALUES ($1, $2, $3, $4)
		`, booking.UserID, booking.RoomID, booking.StartDate, booking.EndDate)
		if err != nil {
			log.Printf("Ошибка добавления бронирования: %v", err)
			return c.Status(500).SendString("Ошибка добавления бронирования")
		}
	
		return c.SendString("Бронирование добавлено успешно")
	})
	

	// Получение списка всех бронирований
	app.Get("/bookings", func(c *fiber.Ctx) error {
		query := "SELECT id, user_id, room_id, start_date, end_date FROM bookings"
		rows, err := pool.Query(context.Background(), query)
		if err != nil {
			log.Printf("Ошибка выполнения запроса: %v", err)
			return c.Status(500).SendString("Ошибка получения списка бронирований")
		}
		defer rows.Close()
	
		var bookings []map[string]interface{}
		for rows.Next() {
			var id, userID, roomID int
			var startDate, endDate time.Time
			if err := rows.Scan(&id, &userID, &roomID, &startDate, &endDate); err != nil {
				log.Printf("Ошибка сканирования строки: %v", err)
				return c.Status(500).SendString("Ошибка обработки данных бронирования")
			}
			bookings = append(bookings, map[string]interface{}{
				"id":         id,
				"user_id":    userID,
				"room_id":    roomID,
				"start_date": startDate.Format("2006-01-02"),
				"end_date":   endDate.Format("2006-01-02"),
			})
		}
	
		return c.JSON(bookings)
	})
	

	// Удаление комнаты
	app.Delete("/rooms/:id", func(c *fiber.Ctx) error {
		id := c.Params("id")
		result, err := pool.Exec(context.Background(), "DELETE FROM rooms WHERE id=$1", id)
		if err != nil {
			log.Printf("Ошибка удаления комнаты: %v", err)
			return c.Status(500).SendString("Ошибка удаления комнаты")
		}
		if result.RowsAffected() == 0 {
			return c.Status(404).SendString("Комната не найдена")
		}
		return c.SendString("Комната успешно удалена")
	})

	// Добавление бронирования
	// (оставлено без изменений для краткости)

	// Запуск приложения
	log.Fatal(app.Listen(":3000"))
}


--- Содержимое файла: frontend/hostel-frontend/src/api/axios.js ---

import axios from 'axios';

// Установите базовый URL для вашего API-сервера
const instance = axios.create({
    baseURL: "http://localhost:3000",
    headers: {
      "Content-Type": "application/json",
    },
  });
  

export default instance;


--- Содержимое файла: backend/migrations/0004_update_constraints.down.sql ---


-- Remove the NOT NULL constraint.
ALTER TABLE bookings
ALTER COLUMN user_id DROP NOT NULL,
ALTER COLUMN room_id DROP NOT NULL;

-- Drop the added indexes.
DROP INDEX IF EXISTS idx_bookings_user_id;
DROP INDEX IF EXISTS idx_bookings_room_id;


--- Содержимое файла: backend/migrations/0001_create_tables.up.sql ---

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE rooms (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    capacity INT NOT NULL CHECK (capacity > 0),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE bookings (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- Добавить ограничение на длину email
ALTER TABLE users
    ADD CONSTRAINT valid_email 
    CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

-- Добавить ограничение на минимальную длину имени
ALTER TABLE users
    ADD CONSTRAINT valid_name 
    CHECK (length(name) >= 2);

--- Содержимое файла: backend/migrations/0002_add_price_per_night.up.sql ---

ALTER TABLE rooms 
    ADD COLUMN price_per_night NUMERIC(10, 2) NOT NULL DEFAULT 0 
    CHECK (price_per_night >= 0);
-- Добавить индекс для email, так как он используется при входе
CREATE INDEX idx_users_email ON users(email);

-- Добавить составной индекс для фильтрации комнат
CREATE INDEX idx_rooms_capacity_price ON rooms(capacity, price_per_night);

--- Содержимое файла: backend/migrations/0006_add_room_address.down.sql ---

-- 0006_add_room_address.down.sql
DROP INDEX IF EXISTS idx_rooms_city;
DROP INDEX IF EXISTS idx_rooms_country;

ALTER TABLE rooms
    DROP COLUMN address_street,
    DROP COLUMN address_city,
    DROP COLUMN address_state,
    DROP COLUMN address_country,
    DROP COLUMN address_postal_code;

--- Содержимое файла: backend/migrations/0005_add_status_and_indexes.down.sql ---

-- 0005_add_status_and_indexes.down.sql
DROP INDEX IF EXISTS idx_bookings_status;
DROP INDEX IF EXISTS idx_bookings_dates;
ALTER TABLE bookings DROP COLUMN status;

--- Содержимое файла: backend/migrations/0007_add_room_images.down.sql ---

-- 0007_add_room_images.down.sql
DROP TABLE IF EXISTS room_images;

--- Содержимое файла: backend/migrations/0011_extend_room_types.up.sql ---

-- 0011_extend_room_types.up.sql
ALTER TABLE rooms
    ADD COLUMN accommodation_type VARCHAR(50) NOT NULL DEFAULT 'room'
    CHECK (accommodation_type IN ('bed', 'room', 'apartment')),
    ADD COLUMN is_shared BOOLEAN NOT NULL DEFAULT false,
    ADD COLUMN total_beds INT CHECK (total_beds > 0),
    ADD COLUMN available_beds INT CHECK (available_beds >= 0),
    ADD COLUMN has_private_bathroom BOOLEAN NOT NULL DEFAULT true;

-- Создаем отдельную таблицу для кроватей
CREATE TABLE beds (
    id SERIAL PRIMARY KEY,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    bed_number INT NOT NULL,
    is_available BOOLEAN NOT NULL DEFAULT true,
    price_per_night DECIMAL(10, 2) NOT NULL CHECK (price_per_night >= 0),
    UNIQUE(room_id, bed_number)
);

-- Создаем таблицу для бронирования отдельных кроватей
CREATE TABLE bed_bookings (
    id SERIAL PRIMARY KEY,
    bed_id INT REFERENCES beds(id) ON DELETE CASCADE,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL CHECK (end_date > start_date),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--- Содержимое файла: backend/migrations/0005_add_status_and_indexes.up.sql ---

-- 0005_add_status_and_indexes.up.sql
ALTER TABLE bookings 
    ADD COLUMN status VARCHAR(20) NOT NULL 
    DEFAULT 'pending' 
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

CREATE INDEX idx_bookings_status ON bookings(status);
CREATE INDEX idx_bookings_dates ON bookings(start_date, end_date);

--- Содержимое файла: backend/migrations/0012_add_accommodation_types.down.sql ---

-- 0012_add_accommodation_types.down.sql

-- Удаляем поле status из таблицы bookings
ALTER TABLE bookings
    DROP COLUMN IF EXISTS status;

-- Удаляем таблицу bed_bookings
DROP TABLE IF EXISTS bed_bookings;

-- Удаляем таблицу beds
DROP TABLE IF EXISTS beds;

-- Удаляем добавленные колонки из таблицы rooms
ALTER TABLE rooms
    DROP COLUMN IF EXISTS accommodation_type,
    DROP COLUMN IF EXISTS is_shared,
    DROP COLUMN IF EXISTS total_beds,
    DROP COLUMN IF EXISTS available_beds,
    DROP COLUMN IF EXISTS has_private_bathroom;

--- Содержимое файла: backend/migrations/0004_update_constraints.up.sql ---


-- Add NOT NULL constraint to ensure data integrity.
ALTER TABLE bookings
ALTER COLUMN user_id SET NOT NULL,
ALTER COLUMN room_id SET NOT NULL;

-- Add an index to optimize queries on bookings table.
CREATE INDEX idx_bookings_user_id ON bookings(user_id);
CREATE INDEX idx_bookings_room_id ON bookings(room_id);


--- Содержимое файла: backend/migrations/0012_add_accommodation_types.up.sql ---

-- 0012_add_accommodation_types.up.sql
ALTER TABLE rooms
    ADD COLUMN accommodation_type VARCHAR(50) NOT NULL DEFAULT 'room'
        CHECK (accommodation_type IN ('bed', 'room', 'apartment')),
    ADD COLUMN is_shared BOOLEAN NOT NULL DEFAULT false,
    ADD COLUMN total_beds INT,
    ADD COLUMN available_beds INT,
    ADD COLUMN has_private_bathroom BOOLEAN NOT NULL DEFAULT true;

-- Создаем таблицу для отдельных кроватей
CREATE TABLE beds (
    id SERIAL PRIMARY KEY,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    bed_number VARCHAR(50) NOT NULL,
    is_available BOOLEAN NOT NULL DEFAULT true,
    price_per_night DECIMAL(10, 2) NOT NULL CHECK (price_per_night >= 0),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(room_id, bed_number)
);

-- Создаем таблицу для бронирования кроватей
CREATE TABLE bed_bookings (
    id SERIAL PRIMARY KEY,
    bed_id INT REFERENCES beds(id) ON DELETE CASCADE,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL CHECK (end_date > start_date),
    status VARCHAR(20) NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Добавляем поле status в существующую таблицу bookings
ALTER TABLE bookings
    ADD COLUMN status VARCHAR(20) NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

--- Содержимое файла: backend/migrations/0003_add_constraints_and_indexes.down.sql ---


-- Remove constraints and indexes added in the up migration
ALTER TABLE bookings DROP CONSTRAINT valid_date_range;

DROP INDEX IF EXISTS idx_rooms_price;
DROP INDEX IF EXISTS idx_bookings_room_date;


--- Содержимое файла: backend/migrations/0001_create_tables.down.sql ---

DROP TABLE IF EXISTS bookings CASCADE;
DROP TABLE IF EXISTS rooms CASCADE;
DROP TABLE IF EXISTS users CASCADE;


--- Содержимое файла: backend/migrations/0007_add_room_images.up.sql ---

-- 0007_add_room_images.up.sql
CREATE TABLE room_images (
    id SERIAL PRIMARY KEY,
    room_id INT NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    is_main BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_main_image_per_room UNIQUE (room_id, is_main) 
        DEFERRABLE INITIALLY DEFERRED
);

CREATE INDEX idx_room_images_room_id ON room_images(room_id);

--- Содержимое файла: backend/migrations/0011_extend_room_types.down.sql ---

-- 0011_extend_room_types.down.sql
DROP TABLE IF EXISTS bed_bookings;
DROP TABLE IF EXISTS beds;
ALTER TABLE rooms
    DROP COLUMN accommodation_type,
    DROP COLUMN is_shared,
    DROP COLUMN total_beds,
    DROP COLUMN available_beds,
    DROP COLUMN has_private_bathroom;

--- Содержимое файла: backend/migrations/0002_add_price_per_night.down.sql ---

ALTER TABLE rooms DROP COLUMN price_per_night;

--- Содержимое файла: backend/migrations/0006_add_room_address.up.sql ---

-- 0006_add_room_address.up.sql
ALTER TABLE rooms
    ADD COLUMN address_street VARCHAR(255) NOT NULL DEFAULT '',
    ADD COLUMN address_city VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_state VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_country VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_postal_code VARCHAR(20) NOT NULL DEFAULT '';

CREATE INDEX idx_rooms_city ON rooms(address_city);
CREATE INDEX idx_rooms_country ON rooms(address_country);

--- Содержимое файла: backend/migrations/0003_add_constraints_and_indexes.up.sql ---


-- Add additional constraints and indexes to fix issues
ALTER TABLE bookings
    ADD CONSTRAINT valid_date_range 
    CHECK (start_date < end_date AND start_date >= CURRENT_DATE);

-- Indexes to optimize queries
CREATE INDEX idx_rooms_price ON rooms (price_per_night);
CREATE INDEX idx_bookings_room_date ON bookings (room_id, start_date, end_date);


--- Содержимое файла: frontend/hostel-frontend/src/components/AddBooking.js ---

import React, { useState, useEffect } from "react";
import {
  Container,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  MenuItem,
  Grid
} from "@mui/material";
import axios from "../api/axios";

const AddBooking = () => {
  const [booking, setBooking] = useState({
    user_id: "",
    room_id: "",
    start_date: "",
    end_date: ""
  });
  
  const [rooms, setRooms] = useState([]); // Список всех комнат
  const [users, setUsers] = useState([]); // Список всех пользователей
  const [error, setError] = useState("");
  const [success, setSuccess] = useState(false);

  // Загрузка списка комнат и пользователей
  useEffect(() => {
    const fetchData = async () => {
      try {
        const [roomsResponse, usersResponse] = await Promise.all([
          axios.get("/rooms"),
          axios.get("/users")
        ]);
        setRooms(roomsResponse.data);
        setUsers(usersResponse.data);
      } catch (error) {
        console.error("Ошибка загрузки данных:", error);
      }
    };
    fetchData();
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setSuccess(false);

    try {
      await axios.post("/bookings", {
        ...booking,
        user_id: parseInt(booking.user_id),
        room_id: parseInt(booking.room_id)
      });
      setSuccess(true);
      setBooking({
        user_id: "",
        room_id: "",
        start_date: "",
        end_date: ""
      });
    } catch (error) {
      setError(error.response?.data || "Ошибка добавления бронирования");
      console.error("Ошибка добавления бронирования:", error);
    }
  };

  // Получаем текущую дату для ограничения выбора дат
  const today = new Date().toISOString().split('T')[0];

  return (
    <Container maxWidth="sm">
      <Box sx={{ mt: 4, mb: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Добавить бронирование (Админ)
        </Typography>

        {success && (
          <Alert severity="success" sx={{ mb: 2 }}>
            Бронирование добавлено успешно!
          </Alert>
        )}

        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        <form onSubmit={handleSubmit}>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                select
                label="Пользователь"
                fullWidth
                value={booking.user_id}
                onChange={(e) => setBooking({ ...booking, user_id: e.target.value })}
              >
                {users.map((user) => (
                  <MenuItem key={user.id} value={user.id}>
                    {user.name} ({user.email})
                  </MenuItem>
                ))}
              </TextField>
            </Grid>

            <Grid item xs={12}>
              <TextField
                select
                label="Комната"
                fullWidth
                value={booking.room_id}
                onChange={(e) => setBooking({ ...booking, room_id: e.target.value })}
              >
                {rooms.map((room) => (
                  <MenuItem key={room.id} value={room.id}>
                    {room.name} ({room.address_city}, {room.price_per_night} руб/ночь)
                  </MenuItem>
                ))}
              </TextField>
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                label="Дата заезда"
                type="date"
                fullWidth
                InputLabelProps={{ shrink: true }}
                value={booking.start_date}
                onChange={(e) => setBooking({ ...booking, start_date: e.target.value })}
                inputProps={{ min: today }}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                label="Дата выезда"
                type="date"
                fullWidth
                InputLabelProps={{ shrink: true }}
                value={booking.end_date}
                onChange={(e) => setBooking({ ...booking, end_date: e.target.value })}
                inputProps={{ min: booking.start_date || today }}
              />
            </Grid>

            <Grid item xs={12}>
              <Button
                type="submit"
                variant="contained"
                color="primary"
                fullWidth
                size="large"
              >
                Добавить бронирование
              </Button>
            </Grid>
          </Grid>
        </form>
      </Box>
    </Container>
  );
};

export default AddBooking;

--- Содержимое файла: frontend/hostel-frontend/src/components/BookRoom.js ---



--- Содержимое файла: frontend/hostel-frontend/src/components/BookingDialog.js ---

import React from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  Box,
  Typography,
  Alert
} from '@mui/material';
import axios from "../api/axios";

const BookingDialog = ({ open, onClose, room, startDate, endDate }) => {
  const [userId, setUserId] = React.useState('');
  const [error, setError] = React.useState('');
  const [success, setSuccess] = React.useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSuccess(false);

    try {
      await axios.post('/bookings', {
        user_id: parseInt(userId),
        room_id: room.id,
        start_date: startDate,
        end_date: endDate
      });
      setSuccess(true);
      setTimeout(() => {
        onClose();
        setUserId('');
        setSuccess(false);
      }, 2000);
    } catch (error) {
      setError(error.response?.data || 'Произошла ошибка при бронировании');
    }
  };

  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle>Бронирование комнаты</DialogTitle>
      <DialogContent>
        {success && (
          <Alert severity="success" sx={{ mt: 2 }}>
            Бронирование успешно создано!
          </Alert>
        )}
        {error && (
          <Alert severity="error" sx={{ mt: 2 }}>
            {error}
          </Alert>
        )}
        {room && (
          <Box sx={{ mt: 2 }}>
            <Typography variant="h6">{room.name}</Typography>
            <Typography variant="body2" color="text.secondary">
              {room.address_street}, {room.address_city}
            </Typography>
            <Typography sx={{ mt: 1 }}>
              Даты: {startDate} - {endDate}
            </Typography>
            <Typography sx={{ mt: 1 }}>
              Общая стоимость: {room.price_per_night * 
                (Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24)))} руб.
            </Typography>
          </Box>
        )}
        <TextField
          autoFocus
          margin="dense"
          label="ID пользователя"
          type="number"
          fullWidth
          value={userId}
          onChange={(e) => setUserId(e.target.value)}
          sx={{ mt: 2 }}
        />
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose} color="inherit">
          Отмена
        </Button>
        <Button onClick={handleSubmit} color="primary" variant="contained">
          Забронировать
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default BookingDialog;

--- Содержимое файла: frontend/hostel-frontend/src/components/AdminPanel.js ---



--- Содержимое файла: frontend/hostel-frontend/src/components/AddUser.js ---

import React, { useState } from "react";
import { TextField, Button, Container, Typography } from "@mui/material";
import axios from "../api/axios";

const AddUser = () => {
  const [user, setUser] = useState({ name: "", email: "" });

  const handleSubmit = async (e) => {
    e.preventDefault();
    await axios.post("http://localhost:3000/users", user);
    alert("Пользователь добавлен!");
  };

  return (
    <Container>
      <Typography variant="h4" gutterBottom>
        Добавить пользователя
      </Typography>
      <form onSubmit={handleSubmit}>
        <TextField
          label="Имя"
          fullWidth
          margin="normal"
          value={user.name}
          onChange={(e) => setUser({ ...user, name: e.target.value })}
        />
        <TextField
          label="Email"
          type="email"
          fullWidth
          margin="normal"
          value={user.email}
          onChange={(e) => setUser({ ...user, email: e.target.value })}
        />
        <Button type="submit" variant="contained" color="primary">
          Добавить
        </Button>
      </form>
    </Container>
  );
};

export default AddUser;


--- Содержимое файла: frontend/hostel-frontend/src/components/RoomList.js ---

import React, { useState, useEffect, useCallback } from 'react';
import axios from "../api/axios";
import { Chip } from '@mui/material';
import {
  Grid, Card, CardContent, Typography, TextField, 
  Button, Divider, Box, Dialog, DialogContent, IconButton,
  MobileStepper, CardMedia
} from "@mui/material";
import {
  KeyboardArrowLeft, KeyboardArrowRight,
  Close as CloseIcon
} from '@mui/icons-material';
import BookingDialog from "./BookingDialog";
import {
    SingleBed as SingleBedIcon,
    Hotel as HotelIcon,
    Apartment as ApartmentIcon,
    Home as HomeIcon
  } from '@mui/icons-material';


const BACKEND_URL = 'http://localhost:3000';

const ImageGallery = ({ images, open, onClose }) => {
    const [activeStep, setActiveStep] = useState(0);
    const maxSteps = images.length;
  
    const handleNext = () => {
      setActiveStep((prevStep) => (prevStep + 1) % maxSteps);
    };
  
    const handleBack = () => {
      setActiveStep((prevStep) => (prevStep - 1 + maxSteps) % maxSteps);
    };
  
    if (!images.length) return null;
  
    return (
        <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
      <DialogContent sx={{ position: 'relative', p: 0 }}>
          <IconButton
            onClick={onClose}
            sx={{
              position: 'absolute',
              right: 8,
              top: 8,
              color: 'white',
              bgcolor: 'rgba(0, 0, 0, 0.5)',
              '&:hover': {
                bgcolor: 'rgba(0, 0, 0, 0.7)',
              },
            }}
          >
            <CloseIcon />
          </IconButton>
          <Box sx={{ height: '80vh', display: 'flex', flexDirection: 'column', justifyContent: 'center' }}>
          <img
            src={`${BACKEND_URL}/uploads/${images[activeStep].file_path}`} // Исправлено здесь
            alt={images[activeStep].file_name}
            style={{
              width: '100%',
              height: '100%',
              objectFit: 'contain',
            }}
          />
            <MobileStepper
              steps={maxSteps}
              position="static"
              activeStep={activeStep}
              sx={{
                bgcolor: 'background.default',
                position: 'absolute',
                bottom: 0,
                width: '100%',
              }}
              nextButton={
                <Button size="small" onClick={handleNext}>
                  Следующее
                  <KeyboardArrowRight />
                </Button>
              }
              backButton={
                <Button size="small" onClick={handleBack}>
                  <KeyboardArrowLeft />
                  Предыдущее
                </Button>
              }
            />
          </Box>
        </DialogContent>
      </Dialog>
    );
  };

  const RoomList = () => {
    const [rooms, setRooms] = useState([]);
    const [filters, setFilters] = useState({
      capacity: "",
      min_price: "",
      max_price: "",
      city: "",
      country: "",
      start_date: "",
      end_date: ""
    });
  
    const [selectedRoom, setSelectedRoom] = useState(null);
    const [galleryOpen, setGalleryOpen] = useState(false);
    const [bookingDialogOpen, setBookingDialogOpen] = useState(false);
  
    const fetchRooms = useCallback(async () => {
      try {
        const params = new URLSearchParams();
        if (filters.capacity) params.append('capacity', filters.capacity);
        if (filters.min_price) params.append('min_price', filters.min_price);
        if (filters.max_price) params.append('max_price', filters.max_price);
        if (filters.city) params.append('city', filters.city);
        if (filters.country) params.append('country', filters.country);
        if (filters.start_date && filters.end_date) {
          params.append('start_date', filters.start_date);
          params.append('end_date', filters.end_date);
        }
        
        const response = await axios.get(`/rooms?${params.toString()}`);
        const roomsData = response.data || [];
        
        // Получаем изображения для каждой комнаты
        const roomsWithImages = await Promise.all(
          roomsData.map(async (room) => {
            const imagesResponse = await axios.get(`/rooms/${room.id}/images`);
            return {
              ...room,
              images: imagesResponse.data || []
            };
          })
        );
        
        setRooms(roomsWithImages);
      } catch (error) {
        console.error("Ошибка при получении списка комнат:", error);
      }
    }, [filters]);
  
    const handleDateChange = (field, value) => {
      setFilters(prev => {
        const newFilters = { ...prev, [field]: value };
        
        if (field === 'end_date' && newFilters.start_date && value < newFilters.start_date) {
          return prev;
        }
        
        if (field === 'start_date' && newFilters.end_date && value > newFilters.end_date) {
          return prev;
        }
        
        return newFilters;
      });
    };
  
    const handleBooking = (room) => {
        if (!filters.start_date || !filters.end_date) {
          alert('Пожалуйста, выберите даты заезда и выезда');
          return;
        }
        setSelectedRoom(room);
        setBookingOptionsOpen(true); // Сначала показываем опции бронирования
      };
      
      const handleBookingTypeSelect = (bookingType) => {
        setBookingOptionsOpen(false);
        setSelectedBookingType(bookingType);
        setBookingDialogOpen(true);
      };
  
    useEffect(() => {
      fetchRooms();
    }, [fetchRooms]);
  
    const AccommodationInfo = ({ room }) => {
        const getAccommodationInfo = () => {
          switch (room.accommodation_type) {
            case 'bed':
              return {
                title: 'Койко-место',
                details: `Доступно ${room.available_beds} из ${room.total_beds} мест`,
                icon: <SingleBedIcon />,
                shared: true
              };
            case 'room':
              return {
                title: room.is_shared ? 'Общая комната' : 'Отдельная комната',
                details: `Вместимость: ${room.capacity} чел.`,
                icon: <HotelIcon />,
                shared: room.is_shared
              };
            case 'apartment':
              return {
                title: 'Квартира',
                details: `${room.capacity} комнат`,
                icon: <ApartmentIcon />,
                shared: false
              };
            default:
              return {
                title: 'Помещение',
                details: `Вместимость: ${room.capacity} чел.`,
                icon: <HomeIcon />,
                shared: false
              };
          }
        };
      
        const info = getAccommodationInfo();
      
        return (
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
            {info.icon}
            <Box>
              <Typography variant="subtitle2" sx={{ fontWeight: 'medium' }}>
                {info.title}
                {info.shared && (
                  <Chip
                    size="small"
                    label="Общее помещение"
                    color="secondary"
                    sx={{ ml: 1 }}
                  />
                )}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                {info.details}
              </Typography>
            </Box>
          </Box>
        );
      };

      const BookingOptions = ({ room, onBookingTypeSelect }) => {
        const getAvailableOptions = () => {
          const options = [];
          
          if (room.accommodation_type === 'bed') {
            options.push({
              type: 'single_bed',
              title: 'Забронировать койко-место',
              price: room.price_per_night
            });
            
            if (room.available_beds > 1) {
              options.push({
                type: 'multiple_beds',
                title: 'Забронировать несколько мест',
                price: room.price_per_night,
                maxCount: room.available_beds
              });
            }
          } else if (room.accommodation_type === 'room') {
            if (room.is_shared) {
              options.push({
                type: 'shared_room',
                title: 'Забронировать место в комнате',
                price: room.price_per_night / room.capacity
              });
            }
            options.push({
              type: 'whole_room',
              title: 'Забронировать всю комнату',
              price: room.price_per_night
            });
          } else if (room.accommodation_type === 'apartment') {
            options.push({
              type: 'apartment',
              title: 'Забронировать квартиру',
              price: room.price_per_night
            });
          }
          
          return options;
        };
      
        return (
          <Dialog open={open} onClose={onClose}>
            <DialogTitle>Выберите тип бронирования</DialogTitle>
            <DialogContent>
              <Stack spacing={2}>
                {getAvailableOptions().map((option) => (
                  <Button
                    key={option.type}
                    variant="outlined"
                    onClick={() => onBookingTypeSelect(option)}
                  >
                    {option.title}
                    <Typography variant="caption" display="block">
                      {option.price} руб./ночь
                    </Typography>
                  </Button>
                ))}
              </Stack>
            </DialogContent>
          </Dialog>
        );
      };


    const today = new Date().toISOString().split('T')[0];
  
    return (
      <div>

      <Grid container spacing={2} sx={{ marginBottom: 4 }}>
        <Grid item xs={12} sm={6}>
          <TextField
            label="Дата заезда"
            type="date"
            fullWidth
            InputLabelProps={{ shrink: true }}
            value={filters.start_date}
            onChange={(e) => handleDateChange('start_date', e.target.value)}
            inputProps={{ min: today }}
          />
        </Grid>
        <Grid item xs={12} sm={6}>
          <TextField
            label="Дата выезда"
            type="date"
            fullWidth
            InputLabelProps={{ shrink: true }}
            value={filters.end_date}
            onChange={(e) => handleDateChange('end_date', e.target.value)}
            inputProps={{ min: filters.start_date || today }}
          />
        </Grid>
        <Grid item xs={12} sm={4}>
          <TextField
            label="Вместимость"
            type="number"
            fullWidth
            value={filters.capacity}
            onChange={(e) => setFilters({ ...filters, capacity: e.target.value })}
          />
        </Grid>
        <Grid item xs={12} sm={4}>
          <TextField
            label="Мин. цена"
            type="number"
            fullWidth
            value={filters.min_price}
            onChange={(e) => setFilters({ ...filters, min_price: e.target.value })}
          />
        </Grid>
        <Grid item xs={12} sm={4}>
          <TextField
            label="Макс. цена"
            type="number"
            fullWidth
            value={filters.max_price}
            onChange={(e) => setFilters({ ...filters, max_price: e.target.value })}
          />
        </Grid>
        <Grid item xs={12} sm={6}>
          <TextField
            label="Город"
            fullWidth
            value={filters.city}
            onChange={(e) => setFilters({ ...filters, city: e.target.value })}
          />
        </Grid>
        <Grid item xs={12} sm={6}>
          <TextField
            label="Страна"
            fullWidth
            value={filters.country}
            onChange={(e) => setFilters({ ...filters, country: e.target.value })}
          />
        </Grid>
        <Grid item xs={12}>
          <Button variant="contained" color="primary" onClick={fetchRooms}>
            Фильтровать
          </Button>
        </Grid>
      </Grid>

      <Grid container spacing={2}>
  {rooms.map((room) => (
    <Grid item xs={12} md={6} lg={4} key={room.id}>
    <Card sx={{ 
      display: 'flex', 
      flexDirection: 'column', 
      height: '100%',
      '& .MuiCardContent-root': {
        padding: '12px',
      },
      '& .MuiTypography-root': {
        lineHeight: '1.3',
      }
    }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', p: 1.5 }}>
        <Box sx={{ flex: 1, pr: 1.5 }}>
          <AccommodationInfo room={room} />
          <Typography variant="h6" sx={{ 
            mb: 0.5,
            fontSize: '1.1rem'
          }}>
            {room.name}
          </Typography>
          {room.accommodation_type === 'bed' ? (
            <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
              Цена за койко-место: {room.price_per_night} руб./ночь
            </Typography>
          ) : (
            <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
              Цена за {room.accommodation_type === 'apartment' ? 'квартиру' : 'комнату'}: {room.price_per_night} руб./ночь
            </Typography>
          )}
        </Box>
        
        {/* Правый верхний угол: эскиз */}
        <Box sx={{ 
          width: '100px',
          height: '100px',
          flexShrink: 0,
          p: room.images?.length ? 0 : 1
        }}>
          {room.images && room.images.length > 0 ? (
            <CardMedia
              component="img"
              sx={{
                width: '100%',
                height: '100%',
                objectFit: 'cover',
                borderRadius: '4px',
                '&:hover': {
                  opacity: 0.8,
                  transition: 'opacity 0.2s ease-in-out',
                },
              }}
              image={`${BACKEND_URL}/uploads/${room.images[0].file_path}`}
              alt={room.name}
              onClick={() => {
                setSelectedRoom(room);
                setGalleryOpen(true);
              }}
            />
          ) : (
            <Box
              sx={{
                width: '100%',
                height: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                bgcolor: 'grey.100',
                borderRadius: '4px',
                fontSize: '0.8rem'
              }}
            >
              <Typography variant="body2" color="text.secondary">
                Нет фото
              </Typography>
            </Box>
          )}
        </Box>
      </Box>
  
      <Divider />
  
      {/* Нижняя часть карточки с адресом и кнопками */}
      <CardContent sx={{ 
        pt: 1,
        pb: '8px !important',
        display: 'flex', 
        justifyContent: 'space-between', 
        alignItems: 'center'
      }}>
        <Typography variant="body2" color="text.secondary" sx={{ 
          fontSize: '0.85rem',
          flex: 1,
          mr: 1
        }}>
          {room.address_street}
          {room.address_city && `, ${room.address_city}`}
          {room.address_state && `, ${room.address_state}`}
          {room.address_country && `, ${room.address_country}`}
          {room.address_postal_code && ` (${room.address_postal_code})`}
        </Typography>
        <Box sx={{ display: 'flex', gap: 0.5 }}>
          {room.images && room.images.length > 1 && (
            <Button
              size="small"
              sx={{ 
                minWidth: 'auto',
                padding: '4px 8px',
                fontSize: '0.8rem'
              }}
              onClick={() => {
                setSelectedRoom(room);
                setGalleryOpen(true);
              }}
            >
              Все ({room.images.length})
            </Button>
          )}
          <Button
            variant="contained"
            color="primary"
            size="small"
            sx={{ 
              minWidth: 'auto',
              padding: '4px 8px',
              fontSize: '0.8rem'
            }}
            onClick={() => handleBooking(room)}
            disabled={!filters.start_date || !filters.end_date}
          >
            Забронировать
          </Button>
        </Box>
      </CardContent>
    </Card>
  </Grid>

))}
</Grid>

    {selectedRoom && (
      <>
        <ImageGallery
          images={selectedRoom.images || []}
          open={galleryOpen}
          onClose={() => {
            setGalleryOpen(false);
            setSelectedRoom(null);
          }}
        />
        <BookingDialog
          open={bookingDialogOpen}
          onClose={() => {
            setBookingDialogOpen(false);
            setSelectedRoom(null);
          }}
          room={selectedRoom}
          startDate={filters.start_date}
          endDate={filters.end_date}
        />
      </>
    )}
  </div>
);
};

export default RoomList;

--- Содержимое файла: frontend/hostel-frontend/src/components/AddRoom.js ---

import React, { useState } from "react";
import { Delete as DeleteIcon, CloudUpload as CloudUploadIcon } from '@mui/icons-material';
import axios from "../api/axios";
import { 
    TextField, Button, Container, Typography, 
    Box, Alert, Grid, IconButton,
    FormControl, InputLabel, Select, MenuItem,
    FormControlLabel, Switch 
} from "@mui/material";

const AddRoom = () => {
    const [room, setRoom] = useState({
        name: "",
        accommodation_type: "room", // Добавляем тип размещения
        capacity: 0,
        price_per_night: 0,
        address_street: "",
        address_city: "",
        address_state: "",
        address_country: "",
        address_postal_code: "",
        is_shared: false,         // Общее помещение
        total_beds: null,         // Всего кроватей (для типа bed)
        available_beds: null,     // Доступно кроватей (для типа bed)
        has_private_bathroom: true // Наличие отдельной ванной
    });
    const [beds, setBeds] = useState([
        { bed_number: "1", price_per_night: 0 }
    ]);
    const [images, setImages] = useState([]);
    const [previewUrls, setPreviewUrls] = useState([]);
    const [error, setError] = useState("");
    const [success, setSuccess] = useState(false);

    const handleImageChange = (e) => {
        console.log('handleImageChange called', e.target.files); // Отладочный вывод
        const files = Array.from(e.target.files || []);
        if (files.length === 0) {
            console.log('No files selected'); // Отладочный вывод
            return;
        }

        const validFiles = files.filter(file => {
            if (!file.type.startsWith('image/')) {
                setError("Можно загружать только изображения");
                console.log('Invalid file type:', file.type); // Отладочный вывод
                return false;
            }
            if (file.size > 5 * 1024 * 1024) {
                setError("Размер файла не должен превышать 5MB");
                console.log('File too large:', file.size); // Отладочный вывод
                return false;
            }
            return true;
        });
        if (validFiles.length === 0) {
            console.log('No valid files after filtering'); // Отладочный вывод
            return;
        }
        setImages(prev => [...prev, ...validFiles]);
        
        // Создаем превью
        validFiles.forEach(file => {
            const reader = new FileReader();
            reader.onloadend = () => {
                setPreviewUrls(prev => [...prev, reader.result]);
            };
            reader.onerror = () => {
                console.error('Error reading file:', file.name); // Отладочный вывод
                setError("Ошибка при чтении файла: " + file.name);
            };
            reader.readAsDataURL(file);
        });
    };

    const removeImage = (index) => {
        setImages(prev => prev.filter((_, i) => i !== index));
        setPreviewUrls(prev => prev.filter((_, i) => i !== index));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError("");
        setSuccess(false);
    
        try {
            // Валидация в зависимости от типа размещения
            if (room.accommodation_type === 'bed') {
                if (!room.total_beds || beds.length === 0) {
                    setError("Добавьте информацию о кроватях");
                    return;
                }
            }
    
            // Подготовка данных комнаты
            const roomData = {
                ...room,
                // Если это не койко-место, очищаем связанные поля
                total_beds: room.accommodation_type === 'bed' ? room.total_beds : null,
                available_beds: room.accommodation_type === 'bed' ? room.total_beds : null,
                // Цена за ночь будет общей для комнаты/квартиры, для койко-мест - отдельно
                price_per_night: room.accommodation_type === 'bed' ? 0 : room.price_per_night
            };
    
            // Создаем комнату
            console.log('Отправляемые данные комнаты:', roomData);
            const roomResponse = await axios.post("/rooms", roomData);
            const roomId = roomResponse.data.id;
    
            // Если тип размещения - койко-места, создаем кровати
            if (room.accommodation_type === 'bed' && beds.length > 0) {
                console.log('Добавление кроватей для комнаты:', roomId);
                await Promise.all(
                    beds.map(async (bed) => {
                        try {
                            const bedData = {
                                bed_number: bed.bed_number,
                                price_per_night: parseFloat(bed.price_per_night)
                            };
                            console.log('Отправка данных кровати:', bedData);
                            await axios.post(`/rooms/${roomId}/beds`, bedData);
                        } catch (error) {
                            console.error('Ошибка добавления кровати:', error);
                            throw error;
                        }
                    })
                );
            }
    
            // Загружаем изображения
            if (images.length > 0) {
                const formData = new FormData();
                images.forEach(image => {
                    formData.append('images', image);
                });
    
                await axios.post(`/rooms/${roomId}/images`, formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                });
            }
    
            setSuccess(true);
            // Очистка формы
            setRoom({
                name: "",
                accommodation_type: "room",
                capacity: 0,
                price_per_night: 0,
                address_street: "",
                address_city: "",
                address_state: "",
                address_country: "",
                address_postal_code: "",
                is_shared: false,
                total_beds: null,
                available_beds: null,
                has_private_bathroom: true
            });
            setBeds([{ bed_number: "1", price_per_night: 0 }]);
            setImages([]);
            setPreviewUrls([]);
        } catch (error) {
            console.error('Ошибка при добавлении:', error);
            setError(error.response?.data || "Ошибка при добавлении объекта размещения");
        }
    };

    return (
        <Container>
            <Typography variant="h4" gutterBottom>
                Добавить комнату
            </Typography>
            {error && (
                <Alert severity="error" sx={{ mb: 2 }}>
                    {error}
                </Alert>
            )}
            {success && (
                <Alert severity="success" sx={{ mb: 2 }}>
                    Комната успешно добавлена!
                </Alert>
            )}
            <form onSubmit={handleSubmit}>
                <Grid container spacing={2}>
                    <Grid item xs={12}>
                        <TextField
                            label="Название комнаты"
                            fullWidth
                            required
                            value={room.name}
                            onChange={(e) => setRoom({ ...room, name: e.target.value })}
                        />
                    </Grid>

                    <Grid item xs={12}>
    <FormControl fullWidth>
        <InputLabel>Тип размещения</InputLabel>
        <Select
            value={room.accommodation_type}
            onChange={(e) => setRoom({ ...room, accommodation_type: e.target.value })}
        >
            <MenuItem value="bed">Койко-место</MenuItem>
            <MenuItem value="room">Комната</MenuItem>
            <MenuItem value="apartment">Квартира</MenuItem>
        </Select>
    </FormControl>
</Grid>

{room.accommodation_type === 'bed' ? (
    <>
        <Grid item xs={12} md={6}>
            <TextField
                label="Всего кроватей"
                type="number"
                fullWidth
                required
                value={room.total_beds || ''}
                onChange={(e) => setRoom({
                    ...room,
                    total_beds: parseInt(e.target.value) || 0,
                    available_beds: parseInt(e.target.value) || 0
                })}
                inputProps={{ min: 1 }}
            />
        </Grid>
        <Grid item xs={12}>
            <Typography variant="h6" sx={{ mt: 2, mb: 1 }}>
                Кровати
            </Typography>
            {beds.map((bed, index) => (
                <Box key={index} sx={{ display: 'flex', gap: 2, mb: 2 }}>
                    <TextField
                        label={`Номер кровати ${index + 1}`}
                        value={bed.bed_number}
                        onChange={(e) => {
                            const newBeds = [...beds];
                            newBeds[index].bed_number = e.target.value;
                            setBeds(newBeds);
                        }}
                    />
                    <TextField
                        label="Цена за ночь"
                        type="number"
                        value={bed.price_per_night}
                        onChange={(e) => {
                            const newBeds = [...beds];
                            newBeds[index].price_per_night = parseFloat(e.target.value);
                            setBeds(newBeds);
                        }}
                    />
                    <IconButton onClick={() => {
                        const newBeds = [...beds];
                        newBeds.splice(index, 1);
                        setBeds(newBeds);
                    }}>
                        <DeleteIcon />
                    </IconButton>
                </Box>
            ))}
            <Button
                variant="outlined"
                onClick={() => setBeds([...beds, { bed_number: `${beds.length + 1}`, price_per_night: 0 }])}
            >
                Добавить кровать
            </Button>
        </Grid>
    </>
) : (
    <Grid item xs={12} md={6}>
        <TextField
            label="Вместимость"
            type="number"
            fullWidth
            required
            value={room.capacity}
            onChange={(e) => setRoom({ ...room, capacity: parseInt(e.target.value) || 0 })}
            inputProps={{ min: 1 }}
        />
    </Grid>
)}

<Grid item xs={12}>
    <FormControlLabel
        control={
            <Switch
                checked={room.is_shared}
                onChange={(e) => setRoom({ ...room, is_shared: e.target.checked })}
            />
        }
        label="Общее помещение"
    />
</Grid>

<Grid item xs={12}>
    <FormControlLabel
        control={
            <Switch
                checked={room.has_private_bathroom}
                onChange={(e) => setRoom({ ...room, has_private_bathroom: e.target.checked })}
            />
        }
        label="Отдельная ванная комната"
    />
</Grid>

                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Вместимость"
                            type="number"
                            fullWidth
                            required
                            value={room.capacity}
                            onChange={(e) => setRoom({ ...room, capacity: parseInt(e.target.value) || 0 })}
                            inputProps={{ min: 1 }}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Цена за ночь"
                            type="number"
                            fullWidth
                            required
                            value={room.price_per_night}
                            onChange={(e) => setRoom({ ...room, price_per_night: parseFloat(e.target.value) || 0 })}
                            inputProps={{ min: 0, step: "0.01" }}
                        />
                    </Grid>

                    {/* Адрес */}
                    <Grid item xs={12}>
                        <Typography variant="h6" sx={{ mt: 2, mb: 1 }}>
                            Адрес
                        </Typography>
                    </Grid>
                    <Grid item xs={12}>
                        <TextField
                            label="Улица"
                            fullWidth
                            required
                            value={room.address_street}
                            onChange={(e) => setRoom({ ...room, address_street: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Город"
                            fullWidth
                            required
                            value={room.address_city}
                            onChange={(e) => setRoom({ ...room, address_city: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Область/Регион"
                            fullWidth
                            value={room.address_state}
                            onChange={(e) => setRoom({ ...room, address_state: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Страна"
                            fullWidth
                            required
                            value={room.address_country}
                            onChange={(e) => setRoom({ ...room, address_country: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Почтовый индекс"
                            fullWidth
                            value={room.address_postal_code}
                            onChange={(e) => setRoom({ ...room, address_postal_code: e.target.value })}
                        />
                    </Grid>

                    {/* Изображения */}
                    <Grid item xs={12}>
                        <Typography variant="h6" sx={{ mt: 2, mb: 1 }}>
                            Фотографии комнаты
                        </Typography>
                    </Grid>
            <Grid item xs={12}>
                <Box sx={{ mt: 1, mb: 2 }}>
                    <Button
                        variant="contained"
                        component="label"
                        startIcon={<CloudUploadIcon />}
                    >
                        Загрузить изображения
                        <input
                            type="file"
                            hidden
                            multiple
                            accept="image/*"
                            onChange={handleImageChange}
                            onClick={(e) => e.target.value = null} // Сброс значения input
                        />
                    </Button>
                </Box>
                {/* Добавим информацию о загруженных файлах */}
                {images.length > 0 && (
                    <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                        Выбрано файлов: {images.length}
                    </Typography>
                )}
            </Grid>
                </Grid>

                <Grid container spacing={2} sx={{ mb: 2 }}>
                    {previewUrls.map((url, index) => (
                        <Grid item xs={12} sm={6} md={4} key={index}>
                            <Box sx={{ position: 'relative' }}>
                                <img 
                                    src={url} 
                                    alt={`Preview ${index}`} 
                                    style={{ 
                                        width: '100%', 
                                        height: '200px',
                                        objectFit: 'cover',
                                        borderRadius: '4px'
                                    }}
                                />
                                <IconButton
                                    sx={{
                                        position: 'absolute',
                                        top: 8,
                                        right: 8,
                                        bgcolor: 'rgba(255, 255, 255, 0.8)',
                                        '&:hover': {
                                            bgcolor: 'rgba(255, 255, 255, 0.9)',
                                        }
                                    }}
                                    onClick={() => removeImage(index)}
                                >
                                    <DeleteIcon />
                                </IconButton>
                            </Box>
                        </Grid>
                    ))}
                </Grid>

                <Box sx={{ mt: 3 }}>
                    <Button 
                        type="submit" 
                        variant="contained" 
                        color="primary"
                        fullWidth
                        size="large"
                        disabled={!room.name || !room.capacity || !room.price_per_night || 
                                !room.address_street || !room.address_city || !room.address_country}
                    >
                        Добавить комнату
                    </Button>
                </Box>
            </form>
        </Container>
    );
};

export default AddRoom;

--- Содержимое файла: frontend/hostel-frontend/src/pages/AddBookingPage.js ---

import React from "react";
import AddBooking from "../components/AddBooking";

const AddBookingPage = () => <AddBooking />;

export default AddBookingPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/AddRoomPage.js ---

import React from "react";
import AddRoom from "../components/AddRoom";

const AddRoomPage = () => <AddRoom />;

export default AddRoomPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/AddUserPage.js ---

import React from "react";
import AddUser from "../components/AddUser";

const AddUserPage = () => <AddUser />;

export default AddUserPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/HomePage.js ---

import React from "react";
import { Link } from "react-router-dom";
import { AppBar, Toolbar, Typography, Button, Container } from "@mui/material";
import RoomList from "../components/RoomList";

const HomePage = () => (
  <div>
    <AppBar position="static">
      <Toolbar>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          Hostel Booking System
        </Typography>
        <Button color="inherit" component={Link} to="/add-room">
          Добавить комнату
        </Button>
        <Button color="inherit" component={Link} to="/add-user">
          Добавить пользователя
        </Button>
        <Button color="inherit" component={Link} to="/admin">
          Админская панель
        </Button>
      </Toolbar>
    </AppBar>
    <Container sx={{ marginTop: 4 }}>
      <Typography variant="h4" gutterBottom>
        Список комнат
      </Typography>
      <RoomList />
    </Container>
  </div>
);

export default HomePage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/BookRoomPage.js ---



--- Содержимое файла: frontend/hostel-frontend/src/pages/AdminPanelPage.js ---

import React from "react";
import AddRoom from "../components/AddRoom";
import AddUser from "../components/AddUser";
import AddBooking from "../components/AddBooking";

const AdminPanelPage = () => (
  <div>
    <h1>Админ-панель</h1>
    <AddRoom />
    <AddUser />
    <AddBooking />
  </div>
);

export default AdminPanelPage;


--- Содержимое файла: frontend/hostel-frontend/src/App.css ---

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


--- Содержимое файла: frontend/hostel-frontend/src/App.js ---

import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { Container } from '@mui/material';
import HomePage from "./pages/HomePage";
import AddRoomPage from "./pages/AddRoomPage";
import AddUserPage from "./pages/AddUserPage";
import BookRoomPage from "./pages/BookRoomPage";
import AdminPanelPage from "./pages/AdminPanelPage";
import AddBookingPage from "./pages/AddBookingPage";

function App() {
  return (
    <Router>
      <Container>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/add-room" element={<AddRoomPage />} />
          <Route path="/add-user" element={<AddUserPage />} />
          <Route path="/book-room" element={<BookRoomPage />} />
          <Route path="/admin" element={<AdminPanelPage />} />
          <Route path="/add-booking" element={<AddBookingPage />} />
        </Routes>
      </Container>
    </Router>
  );
}

export default App;

--- Содержимое файла: frontend/hostel-frontend/src/index.css ---

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


--- Содержимое файла: frontend/hostel-frontend/src/index.js ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { ThemeProvider } from "@mui/material/styles";
import { CssBaseline } from '@mui/material';
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  // Можно добавить кастомные настройки темы
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <App />
    </ThemeProvider>
  </React.StrictMode>
);

reportWebVitals();

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


--- Содержимое файла: deploy/docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"

  backend:
    build:
      context: ../backend
    ports:
      - "3000:3000"
    env_file:
      - ../backend/.env
    depends_on:
      - db

      
frontend:
  build:
    context: ../frontend/hostel-frontend
  ports:
    - "3001:3000"
  environment:
    - REACT_APP_API_URL=http://localhost:3000



--- Содержимое файла: backend/.env ---

DATABASE_URL=postgres://postgres:password@db:5432/hostel_db?sslmode=disable

--- Содержимое файла: frontend/hostel-frontend/package.json ---

{
  "name": "hostel-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@mui/icons-material": "^6.1.7",
    "@mui/material": "^5.16.7",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.7.7",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.28.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "babel-preset-react-app": "^10.0.1"
  }
}


--- Содержимое файла: docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    container_name: hostel_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build:
      context: ./backend
    ports:
      - "3000:3000"
    env_file:
      - ./backend/.env
    depends_on:
      - db
    volumes:
      - ./backend/uploads:/app/uploads
    environment:
      - UPLOAD_DIR=/app/uploads
      
  migrate:
    image: migrate/migrate
    volumes:
      - ./backend/migrations:/migrations
    command: [
      "-path", "/migrations",
      "-database", "postgres://postgres:password@db:5432/hostel_db?sslmode=disable",
      "up"
    ]
    depends_on:
      - db

volumes:
  postgres_data:


