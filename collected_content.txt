--- Содержимое файла: backend/main.go ---

package main

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"hostel-backend/auth"
	"hostel-backend/database"
	"log"
	"mime/multipart"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
	"context"
	"github.com/disintegration/imaging"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/joho/godotenv"
)

type Server struct {
	app  *fiber.App
	db   *database.Database
	auth *auth.AuthManager
}

// Вспомогательная функция для обработки изображений
func processImage(file *multipart.FileHeader) (string, error) {
	src, err := file.Open()
	if err != nil {
		return "", err
	}
	defer src.Close()

	ext := filepath.Ext(file.Filename)
	fileName := fmt.Sprintf("%d%s", time.Now().UnixNano(), ext)
	filePath := filepath.Join("uploads", fileName)

	dst, err := os.Create(filePath)
	if err != nil {
		return "", err
	}
	defer dst.Close()

	img, err := imaging.Decode(src)
	if err != nil {
		return "", err
	}

	resized := imaging.Resize(img, 1200, 0, imaging.Lanczos)
	err = imaging.Save(resized, filePath)
	if err != nil {
		return "", err
	}

	return fileName, nil
}

// Вспомогательная функция для генерации токена сессии
func generateSessionToken() string {
	b := make([]byte, 32)
	if _, err := rand.Read(b); err != nil {
		return ""
	}
	return hex.EncodeToString(b)
}

func (s *Server) setupRoutes() {
	// Основные маршруты
	s.app.Get("/", func(c *fiber.Ctx) error {
		return c.SendString("Hostel Booking System API")
	})

	// Добавление пользователя
	s.app.Post("/users", func(c *fiber.Ctx) error {
		var user struct {
			Name  string `json:"name"`
			Email string `json:"email"`
		}
		if err := c.BodyParser(&user); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}

		err := s.db.AddUser(c.Context(), user.Name, user.Email)
		if err != nil {
			if strings.Contains(err.Error(), "unique constraint") {
				return c.Status(400).SendString("Email уже используется")
			}
			return c.Status(500).SendString("Ошибка добавления пользователя")
		}
		return c.SendString("Пользователь добавлен успешно")
	})

	// Маршруты для комнат
	s.app.Post("/rooms", func(c *fiber.Ctx) error {
		var room database.Room
		if err := c.BodyParser(&room); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}

		roomID, err := s.db.AddRoom(c.Context(), room)
		if err != nil {
			if strings.Contains(err.Error(), "unique constraint") {
				return c.Status(400).SendString("Комната с таким названием уже существует")
			}
			return c.Status(500).SendString("Ошибка добавления комнаты")
		}

		return c.JSON(fiber.Map{"id": roomID})
	})

	s.app.Get("/rooms", func(c *fiber.Ctx) error {
		filters := map[string]string{
			"capacity":           c.Query("capacity"),
			"start_date":         c.Query("start_date"),
			"end_date":           c.Query("end_date"),
			"min_price":          c.Query("min_price"),
			"max_price":          c.Query("max_price"),
			"city":               c.Query("city"),
			"country":            c.Query("country"),
			"accommodation_type": c.Query("accommodation_type"),
			"has_private_rooms":  c.Query("has_private_rooms"),
		}
		log.Printf("Handling /rooms request with filters: %+v", filters) // Добавить

		rooms, err := s.db.GetRooms(c.Context(), filters)
		if err != nil {
			log.Printf("Error getting rooms: %v", err) // Добавить
			return c.Status(500).SendString("Ошибка получения списка комнат")
		}
	
		log.Printf("Successfully retrieved %d rooms", len(rooms)) // Добавить
		log.Printf("Returning rooms: %+v", rooms)
		return c.JSON(rooms)
	})

	// Изображения комнат
	s.app.Post("/rooms/:id/images", func(c *fiber.Ctx) error {
		roomID, err := strconv.Atoi(c.Params("id"))
		if err != nil {
			return c.Status(400).SendString("Неверный ID комнаты")
		}

		form, err := c.MultipartForm()
		if err != nil {
			return c.Status(400).SendString("Ошибка получения файлов")
		}

		files := form.File["images"]
		isMain := len(files) > 0

		var uploadedImages []database.RoomImage
		for _, file := range files {
			if !strings.HasPrefix(file.Header.Get("Content-Type"), "image/") {
				return c.Status(400).SendString("Допустимы только изображения")
			}

			if file.Size > 5*1024*1024 {
				return c.Status(400).SendString("Размер файла не должен превышать 5MB")
			}

			fileName, err := processImage(file)
			if err != nil {
				return c.Status(500).SendString("Ошибка обработки изображения")
			}

			image := database.RoomImage{
				RoomID:      roomID,
				FilePath:    fileName,
				FileName:    file.Filename,
				FileSize:    int(file.Size),
				ContentType: file.Header.Get("Content-Type"),
				IsMain:      isMain,
			}

			imageID, err := s.db.AddRoomImage(c.Context(), roomID, image)
			if err != nil {
				return c.Status(500).SendString("Ошибка сохранения информации об изображении")
			}

			image.ID = imageID
			uploadedImages = append(uploadedImages, image)
			isMain = false
		}

		return c.JSON(uploadedImages)
	})

	s.app.Get("/rooms/:id/images", func(c *fiber.Ctx) error {
		images, err := s.db.GetRoomImages(c.Context(), c.Params("id"))
		if err != nil {
			return c.Status(500).SendString("Ошибка получения изображений")
		}
		return c.JSON(images)
	})

	s.app.Delete("/rooms/:roomId/images/:imageId", func(c *fiber.Ctx) error {
		filePath, err := s.db.DeleteRoomImage(c.Context(), c.Params("imageId"))
		if err != nil {
			return c.Status(404).SendString("Изображение не найдено")
		}

		os.Remove(filepath.Join("uploads", filePath))
		return c.SendString("Изображение удалено")
	})

	// Маршруты для кроватей
	s.app.Post("/rooms/:id/beds", func(c *fiber.Ctx) error {
		type BedRequest struct {
			BedNumber     string  `json:"bed_number"`
			PricePerNight float64 `json:"price_per_night"`
		}

		roomID, err := strconv.Atoi(c.Params("id"))
		if err != nil {
			return c.Status(400).SendString("Неверный ID комнаты")
		}

		var bedReq BedRequest
		if err := c.BodyParser(&bedReq); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}

		bedID, err := s.db.AddBed(c.Context(), roomID, bedReq.BedNumber, bedReq.PricePerNight)
		if err != nil {
			if err.Error() == "room not found" {
				return c.Status(404).SendString("Комната не найдена")
			}
			return c.Status(500).SendString("Ошибка добавления кровати")
		}

		return c.JSON(fiber.Map{
			"id":              bedID,
			"room_id":         roomID,
			"bed_number":      bedReq.BedNumber,
			"price_per_night": bedReq.PricePerNight,
			"is_available":    true,
		})
	})

	s.app.Get("/rooms/:id/available-beds", func(c *fiber.Ctx) error {
		startDate := c.Query("start_date")
		endDate := c.Query("end_date")

		if startDate == "" || endDate == "" {
			return c.Status(400).SendString("Необходимо указать даты")
		}

		beds, err := s.db.GetAvailableBeds(c.Context(), c.Params("id"), startDate, endDate)
		if err != nil {
			return c.Status(500).SendString("Ошибка получения списка кроватей")
		}

		return c.JSON(beds)
	})

	// Маршруты для бронирований
	s.app.Post("/bookings", func(c *fiber.Ctx) error {
		// Получаем сессию пользователя
		sessionToken := c.Cookies("session_token")
		if sessionToken == "" {
			return c.Status(401).SendString("Необходима авторизация")
		}
	
		sessionData, ok := s.auth.GetSession(sessionToken)
		if !ok {
			return c.Status(401).SendString("Необходима авторизация")
		}
	
		var booking database.BookingRequest
		if err := c.BodyParser(&booking); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}
	
		// Получаем id пользователя по email из сессии
		userId, err := s.db.GetUserIDByEmail(c.Context(), sessionData.Email)
		if err != nil {
			return c.Status(500).SendString("Ошибка получения данных пользователя")
		}
	
		// Устанавливаем ID пользователя из сессии
		booking.UserID = userId
	
		err = s.db.CreateBooking(c.Context(), booking)
		if err != nil {
			switch err.Error() {
			case "bed ID is required for bed booking":
				return c.Status(400).SendString("Для койко-места необходимо указать ID кровати")
			case "bed is not available":
				return c.Status(400).SendString("Койко-место недоступно")
			case "bed is already booked for these dates":
				return c.Status(400).SendString("Койко-место уже забронировано на эти даты")
			case "room is already booked for these dates":
				return c.Status(400).SendString("Помещение занято на указанные даты")
			case "check-out date must be after check-in date":
				return c.Status(400).SendString("Дата выезда должна быть позже даты заезда")
			default:
				return c.Status(500).SendString("Ошибка создания бронирования")
			}
		}
	
		return c.SendString("Бронирование создано успешно")
	})


	s.app.Get("/bookings", func(c *fiber.Ctx) error {
		bookings, err := s.db.GetAllBookings(c.Context())
		if err != nil {
			return c.Status(500).SendString("Ошибка получения списка бронирований")
		}
		return c.JSON(bookings)
	})

	s.app.Delete("/rooms/:roomId/bookings/:bookingId", func(c *fiber.Ctx) error {
		err := s.db.DeleteBooking(c.Context(), c.Params("bookingId"), "room")
		if err != nil {
			return c.Status(500).SendString("Ошибка удаления бронирования")
		}
		return c.SendString("Бронирование удалено")
	})

	s.app.Delete("/beds/:bedId/bookings/:bookingId", func(c *fiber.Ctx) error {
		err := s.db.DeleteBooking(c.Context(), c.Params("bookingId"), "bed")
		if err != nil {
			return c.Status(500).SendString("Ошибка удаления бронирования")
		}
		return c.SendString("Бронирование удалено")
	})

	// Статическая раздача изображений
	s.app.Static("/uploads", "./uploads")
}

func (s *Server) setupAuthRoutes() {
	s.app.Get("/auth/google", func(c *fiber.Ctx) error {
		url := s.auth.GetGoogleAuthURL()
		log.Printf("Generated Google Auth URL: %s", url) 
		return c.Redirect(url)
	})

	s.app.Get("/auth/google/callback", func(c *fiber.Ctx) error {
		code := c.Query("code")
		if code == "" {
			return c.Status(400).SendString("Missing code")
		}

		sessionData, err := s.auth.HandleGoogleCallback(c.Context(), code)
		if err != nil {
			return c.Status(500).SendString("Authentication failed")
		}

		// Получаем или создаём пользователя
		userID, err := s.db.GetOrCreateGoogleUser(
			c.Context(),
			sessionData.Name,
			sessionData.Email,
			sessionData.GoogleID,   // Должно приходить из auth.SessionData
			sessionData.PictureURL, // Должно приходить из auth.SessionData
		)
		if err != nil {
			log.Printf("Error managing user: %v", err)
			return c.Status(500).SendString("Error managing user")
		}

		sessionToken := generateSessionToken()
		sessionData.UserID = userID // Добавляем ID пользователя в данные сессии
		s.auth.SaveSession(sessionToken, sessionData)

		c.Cookie(&fiber.Cookie{
			Name:     "session_token",
			Value:    sessionToken,
			Path:     "/",
			MaxAge:   3600 * 24,
			Secure:   true,
			HTTPOnly: true,
			SameSite: "Lax",
		})

		return c.Redirect(os.Getenv("FRONTEND_URL"))
	})

	s.app.Get("/auth/session", func(c *fiber.Ctx) error {
		sessionToken := c.Cookies("session_token")
		if sessionToken == "" {
			return c.JSON(fiber.Map{
				"authenticated": false,
			})
		}

		sessionData, ok := s.auth.GetSession(sessionToken)
		if !ok {
			return c.JSON(fiber.Map{
				"authenticated": false,
			})
		}

		return c.JSON(fiber.Map{
			"authenticated": true,
			"user": fiber.Map{
				"name":     sessionData.Name,
				"email":    sessionData.Email,
				"provider": sessionData.Provider,
			},
		})
	})

	s.app.Get("/auth/logout", func(c *fiber.Ctx) error {
		sessionToken := c.Cookies("session_token")
		if sessionToken != "" {
			s.auth.DeleteSession(sessionToken)
			c.Cookie(&fiber.Cookie{
				Name:     "session_token",
				Value:    "",
				Path:     "/",
				MaxAge:   -1,
				Secure:   true,
				HTTPOnly: true,
				SameSite: "Lax",
			})
		}
		return c.SendStatus(200)
	})
}

func NewServer() (*Server, error) {
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found")
    }

	db, err := database.New(os.Getenv("DATABASE_URL"))
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %v", err)
	}
    if err := db.Ping(context.Background()); err != nil {
        return nil, fmt.Errorf("cannot ping database: %v", err)
    }
    log.Println("Successfully connected to database")

	authManager := auth.NewAuthManager(
		os.Getenv("GOOGLE_CLIENT_ID"),
		os.Getenv("GOOGLE_CLIENT_SECRET"),
		os.Getenv("GOOGLE_OAUTH_REDIRECT_URL"),
	)

	app := fiber.New()

	// Настройка CORS
	//app.Use(cors.New(cors.Config{
	//	AllowOrigins:     os.Getenv("FRONTEND_URL"),
	//	AllowMethods:     "GET,POST,DELETE,PUT,OPTIONS",
	//	AllowHeaders:     "Origin, Content-Type, Accept, Authorization",
	//	ExposeHeaders:    "Content-Length",
	//	AllowCredentials: true,
	//	MaxAge:           300,
	//}))

	app.Use(cors.New(cors.Config{
		AllowOrigins: "http://localhost:3000,http://localhost:3001,https://landhub.rs,http://landhub.rs", // Укажите домены, которые разрешены
		AllowCredentials: true, // Включить передачу cookie
		AllowMethods: "GET,POST,DELETE,PUT,OPTIONS", // Разрешить основные HTTP методы
		AllowHeaders: "Origin, Content-Type, Accept, Authorization", // Разрешить заголовки
		ExposeHeaders: "Content-Length", // Экспонировать определенные заголовки
	}))
	

	os.MkdirAll("./uploads", os.ModePerm)

	server := &Server{
		app:  app,
		db:   db,
		auth: authManager,
	}

	// Настройка маршрутов
	server.setupAuthRoutes()
	server.setupRoutes()

	return server, nil
}

func main() {
	server, err := NewServer()
	if err != nil {
		log.Fatalf("Failed to create server: %v", err)
	}

	port := os.Getenv("PORT")
	if port == "" {
		port = "3000"
	}

	log.Printf("Server running on port %s", port)
	log.Fatal(server.app.Listen(fmt.Sprintf(":%s", port)))
}


--- Содержимое файла: backend/Dockerfile ---

FROM golang:1.21
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN mkdir -p uploads
RUN go mod tidy
RUN CGO_ENABLED=0 GOOS=linux go build -o main .
EXPOSE 3000
CMD ["./main"]


--- Содержимое файла: backend/.env ---

DATABASE_URL=postgres://postgres:c9XWc7Cm@db:5432/hostel_db?sslmode=disable
CORS_ORIGINS=http://landhub.rs,https://landhub.rs


GOOGLE_CLIENT_ID=917315728307-au9ga5fl7o3bbid9nv7e4l92gut194pq.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
GOOGLE_OAUTH_REDIRECT_URL=https://landhub.rs/auth/google/callback
FRONTEND_URL=https://landhub.rs


--- Содержимое файла: backend/.env.local ---

DATABASE_URL=postgres://postgres:password@db:5432/hostel_db?sslmode=disable
CORS_ORIGINS=http://localhost:3001,http://localhost:3000



GOOGLE_CLIENT_ID=917315728307-au9ga5fl7o3bbid9nv7e4l92gut194pq.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
GOOGLE_OAUTH_REDIRECT_URL=http://localhost:3000/auth/google/callback
FRONTEND_URL=http://localhost:3001
PORT=3000


--- Содержимое файла: backend/.dockerignore ---

# backend/.dockerignore
uploads/

--- Содержимое файла: backend/database/db.go ---

package database

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"
	"strconv"
	"github.com/jackc/pgx/v5/pgxpool"
)

type Database struct {
	pool *pgxpool.Pool
}

type Room struct {
	Name               string   `json:"name"`
	Capacity           int      `json:"capacity"`
	PricePerNight     *float64 `json:"price_per_night"`
	AddressStreet     string   `json:"address_street"`
	AddressCity       string   `json:"address_city"`
	AddressState      string   `json:"address_state"`
	AddressCountry    string   `json:"address_country"`
	AddressPostalCode string   `json:"address_postal_code"`
	AccommodationType string   `json:"accommodation_type"`
	IsShared          bool     `json:"is_shared"`
	TotalBeds         *int     `json:"total_beds"`
	AvailableBeds     *int     `json:"available_beds"`
	HasPrivateBathroom bool    `json:"has_private_bathroom"`
	Latitude          *float64 `json:"latitude"`
	Longitude         *float64 `json:"longitude"`
	FormattedAddress  string   `json:"formatted_address"`
}

type RoomImage struct {
	ID          int       `json:"id"`
	RoomID      int       `json:"room_id"`
	FilePath    string    `json:"file_path"`
	FileName    string    `json:"file_name"`
	FileSize    int       `json:"file_size"`
	ContentType string    `json:"content_type"`
	IsMain      bool      `json:"is_main"`
	CreatedAt   time.Time `json:"created_at"`
}

type Bed struct {
	ID            int     `json:"id"`
	RoomID        int     `json:"room_id"`
	BedNumber     string  `json:"bed_number"`
	IsAvailable   bool    `json:"is_available"`
	PricePerNight float64 `json:"price_per_night"`
}

type BedImage struct {
	ID          int       `json:"id"`
	BedID       int       `json:"bed_id"`
	FilePath    string    `json:"file_path"`
	FileName    string    `json:"file_name"`
	FileSize    int       `json:"file_size"`
	ContentType string    `json:"content_type"`
	CreatedAt   time.Time `json:"created_at"`
}

type BookingRequest struct {
	UserID    int    `json:"user_id"`
	RoomID    int    `json:"room_id"`
	BedID     *int   `json:"bed_id,omitempty"`
	StartDate string `json:"start_date"`
	EndDate   string `json:"end_date"`
}

type Booking struct {
	ID             int       `json:"id"`
	UserID         int       `json:"user_id"`
	RoomID         int       `json:"room_id"`
	BedID          *int      `json:"bed_id"`
	StartDate      time.Time `json:"start_date"`
	EndDate        time.Time `json:"end_date"`
	Status         string    `json:"status"`
	RoomName       string    `json:"room_name"`
	AccommodationType string `json:"type"`
	UserName       string    `json:"user_name"`
	UserEmail      string    `json:"user_email"`
	BookingType    string    `json:"booking_type"`
}
type User struct {
    ID         int    `json:"id"`
    Name       string `json:"name"`
    Email      string `json:"email"`
    GoogleID   string `json:"google_id"`
    PictureURL string `json:"picture_url"`
}

func (db *Database) GetOrCreateGoogleUser(ctx context.Context, name, email, googleID, pictureURL string) (int, error) {
    var userID int
    
    // Пробуем найти пользователя по google_id
    err := db.pool.QueryRow(ctx, `
        SELECT id FROM users WHERE google_id = $1
    `, googleID).Scan(&userID)

    if err == nil {
        // Пользователь найден, обновляем информацию
        _, err = db.pool.Exec(ctx, `
            UPDATE users 
            SET name = $1, email = $2, picture_url = $3
            WHERE id = $4
        `, name, email, pictureURL, userID)
        return userID, err
    }

    // Пользователь не найден, создаём нового
    err = db.pool.QueryRow(ctx, `
        INSERT INTO users (name, email, google_id, picture_url)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (email) DO UPDATE 
            SET google_id = $3, 
                picture_url = $4,
                name = $1
        RETURNING id
    `, name, email, googleID, pictureURL).Scan(&userID)

    return userID, err
}

func (db *Database) GetUserIDByEmail(ctx context.Context, email string) (int, error) {
    var userID int
    err := db.pool.QueryRow(ctx, "SELECT id FROM users WHERE email = $1", email).Scan(&userID)
    if err != nil {
        return 0, err
    }
    return userID, nil
}


func New(dbURL string) (*Database, error) {
	pool, err := pgxpool.New(context.Background(), dbURL)
	if err != nil {
		return nil, err
	}
	return &Database{pool: pool}, nil
}

func (db *Database) Close() {
	db.pool.Close()
}

// User methods
func (db *Database) AddUser(ctx context.Context, name, email string) error {
	_, err := db.pool.Exec(ctx, "INSERT INTO users (name, email) VALUES ($1, $2)", name, email)
	return err
}

// Room methods
func (db *Database) AddRoom(ctx context.Context, room Room) (int, error) {
	var roomID int
	totalBeds := 0
	availableBeds := 0
	
	if room.TotalBeds != nil {
		totalBeds = *room.TotalBeds
		if room.AvailableBeds != nil {
			availableBeds = *room.AvailableBeds
		} else {
			availableBeds = totalBeds
		}
	}

	err := db.pool.QueryRow(ctx, `
		INSERT INTO rooms (
			name, capacity, price_per_night,
			address_street, address_city, address_state,
			address_country, address_postal_code,
			accommodation_type, is_shared,
			total_beds, available_beds, has_private_bathroom,
			latitude, longitude, formatted_address
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
			$11, $12, $13, $14, $15, $16)
		RETURNING id
	`, room.Name, room.Capacity, room.PricePerNight,
		room.AddressStreet, room.AddressCity, room.AddressState,
		room.AddressCountry, room.AddressPostalCode,
		room.AccommodationType, room.IsShared,
		totalBeds, availableBeds, room.HasPrivateBathroom,
		room.Latitude, room.Longitude, room.FormattedAddress,
	).Scan(&roomID)

	return roomID, err
}

func (db *Database) DeleteRoom(ctx context.Context, id string) error {
	result, err := db.pool.Exec(ctx, "DELETE FROM rooms WHERE id=$1", id)
	if err != nil {
		return err
	}
	if result.RowsAffected() == 0 {
		return fmt.Errorf("room not found")
	}
	return nil
}
func (db *Database) Ping(ctx context.Context) error {
    return db.pool.Ping(ctx)
}
func (db *Database) GetRooms(ctx context.Context, filters map[string]string) ([]map[string]interface{}, error) {
	baseQuery := `
	WITH room_availability AS (
		SELECT 
			r.id,
			COALESCE(r.total_beds, 0) as total_beds,
			CASE 
				WHEN r.accommodation_type = 'bed' THEN 
					COALESCE(
						r.total_beds - COALESCE((
							SELECT COUNT(DISTINCT bb.bed_id)
							FROM beds b2
							LEFT JOIN bed_bookings bb ON b2.id = bb.bed_id
							WHERE b2.room_id = r.id
							AND bb.status = 'confirmed'
							AND bb.start_date <= $2
							AND bb.end_date >= $1
						), 0),
						r.total_beds
					)
				ELSE 
					CASE WHEN EXISTS (
						SELECT 1 FROM bookings b
						WHERE b.room_id = r.id
						AND b.status = 'confirmed'
						AND b.start_date <= $2
						AND b.end_date >= $1
					) THEN 0 ELSE 1 END
			END as available_count,
			CASE 
				WHEN r.accommodation_type = 'bed' THEN
					COALESCE(
						(SELECT MIN(b3.price_per_night) 
						 FROM beds b3 
						 WHERE b3.room_id = r.id 
						 AND b3.is_available = true
						 AND b3.id NOT IN (
							SELECT bb.bed_id
							FROM bed_bookings bb
							WHERE bb.status = 'confirmed'
							AND bb.start_date <= $2
							AND bb.end_date >= $1
						 )),
						r.price_per_night
					)
				ELSE r.price_per_night
			END as actual_price
		FROM rooms r
	)
	SELECT 
		r.id, 
		r.name, 
		r.capacity,
		r.latitude,
		r.longitude,
		ra.actual_price as price_per_night,
		r.address_street, 
		r.address_city, 
		r.address_state,
		r.address_country, 
		r.address_postal_code,
		r.accommodation_type, 
		r.is_shared,
		COALESCE(r.total_beds, 0) as total_beds,
		COALESCE(ra.available_count, 0) as available_beds,
		r.has_private_bathroom,
		r.created_at
	FROM rooms r
	JOIN room_availability ra ON r.id = ra.id
	WHERE 1=1
		AND (
			CASE 
				WHEN r.accommodation_type = 'bed' 
				THEN COALESCE(ra.available_count, 0) > 0 
				ELSE COALESCE(ra.available_count, 1) = 1
			END
		)`

	var conditions []string
	args := []interface{}{filters["start_date"], filters["end_date"]}
	paramCount := 2

	if accommodationType := filters["accommodation_type"]; accommodationType != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("r.accommodation_type = $%d", paramCount))
		args = append(args, accommodationType)

		if accommodationType == "room" && filters["has_private_rooms"] == "true" {
			conditions = append(conditions, "r.is_shared = false")
		}
	}

	if capacity := filters["capacity"]; capacity != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("r.capacity >= $%d", paramCount))
		args = append(args, capacity)
	}

	if minPrice := filters["min_price"]; minPrice != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("ra.actual_price >= $%d", paramCount))
		args = append(args, minPrice)
	}

	if maxPrice := filters["max_price"]; maxPrice != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("ra.actual_price <= $%d", paramCount))
		args = append(args, maxPrice)
	}

	if city := filters["city"]; city != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("r.address_city ILIKE $%d", paramCount))
		args = append(args, "%"+city+"%")
	}

	if country := filters["country"]; country != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("r.address_country ILIKE $%d", paramCount))
		args = append(args, "%"+country+"%")
	}

	if len(conditions) > 0 {
		baseQuery += " AND " + strings.Join(conditions, " AND ")
	}

	baseQuery += " ORDER BY ra.available_count DESC, ra.actual_price ASC, r.created_at DESC"

	rows, err := db.pool.Query(ctx, baseQuery, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var rooms []map[string]interface{}
	for rows.Next() {
		var id, capacity int
		var totalBeds, availableBeds int
		var name, addressStreet, addressCity, addressState,
			addressCountry, addressPostalCode, accommodationType string
		var latitude, longitude float64
		var pricePerNight float64
		var isShared, hasPrivateBathroom bool
		var createdAt time.Time

		if err := rows.Scan(
			&id, &name, &capacity, &latitude, &longitude, &pricePerNight,
			&addressStreet, &addressCity, &addressState,
			&addressCountry, &addressPostalCode,
			&accommodationType, &isShared,
			&totalBeds, &availableBeds,
			&hasPrivateBathroom,
			&createdAt,
		); err != nil {
			log.Printf("Ошибка сканирования строки: %v", err)
			continue
		}

		rooms = append(rooms, map[string]interface{}{
			"id":                   id,
			"name":                 name,
			"capacity":             capacity,
			"latitude":             latitude,
			"longitude":            longitude,
			"price_per_night":      pricePerNight,
			"address_street":       addressStreet,
			"address_city":         addressCity,
			"address_state":        addressState,
			"address_country":      addressCountry,
			"address_postal_code":  addressPostalCode,
			"accommodation_type":   accommodationType,
			"is_shared":           isShared,
			"total_beds":          totalBeds,
			"available_beds":      availableBeds,
			"has_private_bathroom": hasPrivateBathroom,
			"created_at":          createdAt.Format("2006-01-02 15:04:05"),
		})
	}

	return rooms, nil
}

// Room Image methods
func (db *Database) AddRoomImage(ctx context.Context, roomID int, image RoomImage) (int, error) {
	var imageID int
	err := db.pool.QueryRow(ctx, `
		INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main)
		VALUES ($1, $2, $3, $4, $5, $6)
		RETURNING id
	`, roomID, image.FilePath, image.FileName, image.FileSize, image.ContentType, image.IsMain).Scan(&imageID)
	return imageID, err
}

func (db *Database) GetRoomImages(ctx context.Context, roomID string) ([]RoomImage, error) {
	rows, err := db.pool.Query(ctx, `
		SELECT id, room_id, file_path, file_name, file_size, content_type, is_main, created_at
		FROM room_images
		WHERE room_id = $1
		ORDER BY is_main DESC, created_at DESC
	`, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var images []RoomImage
	for rows.Next() {
		var img RoomImage
		err := rows.Scan(
			&img.ID,
			&img.RoomID,
			&img.FilePath,
			&img.FileName,
			&img.FileSize,
			&img.ContentType,
			&img.IsMain,
			&img.CreatedAt,
		)
		if err != nil {
			log.Printf("Ошибка сканирования изображения: %v", err)
			continue
		}
		images = append(images, img)
	}
	return images, rows.Err()
}

func (db *Database) DeleteRoomImage(ctx context.Context, imageID string) (string, error) {
	var filePath string
	err := db.pool.QueryRow(ctx, "SELECT file_path FROM room_images WHERE id = $1", imageID).Scan(&filePath)
	if err != nil {
		return "", err
	}

	_, err = db.pool.Exec(ctx, "DELETE FROM room_images WHERE id = $1", imageID)
	if err != nil {
		return "", err
	}

	return filePath, nil
}

// Bed methods
func (db *Database) AddBed(ctx context.Context, roomID int, bedNumber string, pricePerNight float64) (int, error) {
	var bedID int
	// Проверяем, существует ли комната
	var roomExists bool
	err := db.pool.QueryRow(ctx, 
		"SELECT EXISTS(SELECT 1 FROM rooms WHERE id = $1)", 
		roomID).Scan(&roomExists)
	if err != nil || !roomExists {
		return 0, fmt.Errorf("room not found")
	}

	// Добавляем кровать
	err = db.pool.QueryRow(ctx, `
		INSERT INTO beds (room_id, bed_number, price_per_night, is_available) 
		VALUES ($1, $2, $3, true)
		RETURNING id`,
		roomID, bedNumber, pricePerNight).Scan(&bedID)

	return bedID, err
}

func (db *Database) GetAvailableBeds(ctx context.Context, roomID string, startDate, endDate string) ([]Bed, error) {
	query := `
		SELECT b.id, b.bed_number, b.price_per_night
		FROM beds b
		WHERE b.room_id = $1
		AND b.is_available = true
		AND NOT EXISTS (
			SELECT 1
			FROM bed_bookings bb
			WHERE bb.bed_id = b.id
			AND bb.status = 'confirmed'
			AND (
				(bb.start_date <= $3 AND bb.end_date >= $2)
			)
		)
		ORDER BY b.bed_number
	`

	rows, err := db.pool.Query(ctx, query, roomID, startDate, endDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var beds []Bed
	for rows.Next() {
		var bed Bed
		if err := rows.Scan(&bed.ID, &bed.BedNumber, &bed.PricePerNight); err != nil {
			continue
		}
		bed.RoomID, _ = strconv.Atoi(roomID)
		bed.IsAvailable = true
		beds = append(beds, bed)
	}

	// Обновляем количество доступных кроватей в комнате
	_, err = db.pool.Exec(ctx, `
		UPDATE rooms 
		SET available_beds = $1
		WHERE id = $2
	`, len(beds), roomID)

	return beds, rows.Err()
}

// Bed Image methods
func (db *Database) AddBedImage(ctx context.Context, bedID int, image BedImage) (int, error) {
	var imageID int
	err := db.pool.QueryRow(ctx, `
		INSERT INTO bed_images (bed_id, file_path, file_name, file_size, content_type)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id
	`, bedID, image.FilePath, image.FileName, image.FileSize, image.ContentType).Scan(&imageID)
	return imageID, err
}

func (db *Database) GetBedImages(ctx context.Context, bedID string) ([]BedImage, error) {
	rows, err := db.pool.Query(ctx, `
		SELECT id, bed_id, file_path, file_name, file_size, content_type, created_at
		FROM bed_images
		WHERE bed_id = $1
		ORDER BY created_at DESC
	`, bedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var images []BedImage
	for rows.Next() {
		var img BedImage
		err := rows.Scan(
			&img.ID,
			&img.BedID,
			&img.FilePath,
			&img.FileName,
			&img.FileSize,
			&img.ContentType,
			&img.CreatedAt,
		)
		if err != nil {
			continue
		}
		images = append(images, img)
	}
	return images, rows.Err()
}

// Booking methods
func (db *Database) CreateBooking(ctx context.Context, booking BookingRequest) error {
	tx, err := db.pool.Begin(ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(ctx)

	var userExists bool
	err = tx.QueryRow(ctx,
		"SELECT EXISTS(SELECT 1 FROM users WHERE id = $1)",
		booking.UserID).Scan(&userExists)
	if err != nil || !userExists {
		return fmt.Errorf("user not found")
	}

	var roomType string
	var isShared bool
	err = tx.QueryRow(ctx, `
		SELECT accommodation_type, is_shared 
		FROM rooms 
		WHERE id = $1`,
		booking.RoomID).Scan(&roomType, &isShared)
	if err != nil {
		return err
	}

	if booking.StartDate == booking.EndDate {
		return fmt.Errorf("check-out date must be after check-in date")
	}

	if roomType == "bed" {
		if booking.BedID == nil {
			return fmt.Errorf("bed ID is required for bed booking")
		}

		var isAvailable bool
		err = tx.QueryRow(ctx, `
			SELECT is_available 
			FROM beds 
			WHERE id = $1 AND room_id = $2`,
			*booking.BedID, booking.RoomID).Scan(&isAvailable)
		if err != nil || !isAvailable {
			return fmt.Errorf("bed is not available")
		}

		var conflictCount int
		err = tx.QueryRow(ctx, `
			SELECT COUNT(*) 
			FROM bed_bookings 
			WHERE bed_id = $1 
			AND status = 'confirmed'
			AND (
				(start_date <= $2 AND end_date >= $2) OR
				(start_date <= $3 AND end_date >= $3) OR
				(start_date >= $2 AND end_date <= $3)
			)`,
			*booking.BedID, booking.StartDate, booking.EndDate).Scan(&conflictCount)

		if err != nil || conflictCount > 0 {
			return fmt.Errorf("bed is already booked for these dates")
		}

		_, err = tx.Exec(ctx, `
			INSERT INTO bed_bookings (bed_id, user_id, start_date, end_date, status)
			VALUES ($1, $2, $3, $4, 'confirmed')`,
			*booking.BedID, booking.UserID, booking.StartDate, booking.EndDate)

		_, err = tx.Exec(ctx, `
			UPDATE rooms 
			SET available_beds = available_beds - 1
			WHERE id = $1`,
			booking.RoomID)
	} else {
		var count int
		err = tx.QueryRow(ctx, `
			SELECT COUNT(*) 
			FROM bookings 
			WHERE room_id = $1 
				AND start_date <= $3 
				AND end_date >= $2
				AND status = 'confirmed'`,
			booking.RoomID, booking.StartDate, booking.EndDate).Scan(&count)
		if err != nil || count > 0 {
			return fmt.Errorf("room is already booked for these dates")
		}

		_, err = tx.Exec(ctx, `
			INSERT INTO bookings (user_id, room_id, start_date, end_date, status)
			VALUES ($1, $2, $3, $4, 'confirmed')`,
			booking.UserID, booking.RoomID, booking.StartDate, booking.EndDate)
	}

	if err != nil {
		return err
	}

	return tx.Commit(ctx)
}

func (db *Database) GetAllBookings(ctx context.Context) ([]Booking, error) {
	roomBookingsQuery := `
		SELECT b.id, b.user_id, b.room_id, NULL as bed_id, 
			   b.start_date, b.end_date, b.status,
			   r.name as room_name, r.accommodation_type,
			   u.name as user_name, u.email as user_email
		FROM bookings b
		JOIN rooms r ON b.room_id = r.id
		JOIN users u ON b.user_id = u.id
	`
	bedBookingsQuery := `
		SELECT bb.id, bb.user_id, b.room_id, bb.bed_id,
			   bb.start_date, bb.end_date, bb.status,
			   r.name as room_name, r.accommodation_type,
			   u.name as user_name, u.email as user_email
		FROM bed_bookings bb
		JOIN beds b ON bb.bed_id = b.id
		JOIN rooms r ON b.room_id = r.id
		JOIN users u ON bb.user_id = u.id
	`

	roomRows, err := db.pool.Query(ctx, roomBookingsQuery)
	if err != nil {
		return nil, err
	}
	defer roomRows.Close()

	bedRows, err := db.pool.Query(ctx, bedBookingsQuery)
	if err != nil {
		return nil, err
	}
	defer bedRows.Close()

	var bookings []Booking

	// Process room bookings
	for roomRows.Next() {
		var booking Booking
		err := roomRows.Scan(
			&booking.ID, &booking.UserID, &booking.RoomID, &booking.BedID,
			&booking.StartDate, &booking.EndDate, &booking.Status,
			&booking.RoomName, &booking.AccommodationType,
			&booking.UserName, &booking.UserEmail,
		)
		if err != nil {
			continue
		}
		booking.BookingType = "room"
		bookings = append(bookings, booking)
	}

	// Process bed bookings
	for bedRows.Next() {
		var booking Booking
		err := bedRows.Scan(
			&booking.ID, &booking.UserID, &booking.RoomID, &booking.BedID,
			&booking.StartDate, &booking.EndDate, &booking.Status,
			&booking.RoomName, &booking.AccommodationType,
			&booking.UserName, &booking.UserEmail,
		)
		if err != nil {
			continue
		}
		booking.BookingType = "bed"
		bookings = append(bookings, booking)
	}

	return bookings, nil
}

func (db *Database) DeleteBooking(ctx context.Context, bookingID, bookingType string) error {
	var query string
	if bookingType == "room" {
		query = "DELETE FROM bookings WHERE id = $1"
	} else if bookingType == "bed" {
		query = "DELETE FROM bed_bookings WHERE id = $1"
	} else {
		return fmt.Errorf("invalid booking type")
	}

	_, err := db.pool.Exec(ctx, query, bookingID)
	return err
}

--- Содержимое файла: backend/migrations/0004_update_constraints.down.sql ---


-- Remove the NOT NULL constraint.
ALTER TABLE bookings
ALTER COLUMN user_id DROP NOT NULL,
ALTER COLUMN room_id DROP NOT NULL;

-- Drop the added indexes.
DROP INDEX IF EXISTS idx_bookings_user_id;
DROP INDEX IF EXISTS idx_bookings_room_id;


--- Содержимое файла: backend/migrations/0001_create_tables.up.sql ---

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE rooms (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    capacity INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE bookings (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- Добавить ограничение на длину email
ALTER TABLE users
    ADD CONSTRAINT valid_email 
    CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

-- Добавить ограничение на минимальную длину имени
ALTER TABLE users
    ADD CONSTRAINT valid_name 
    CHECK (length(name) >= 2);

--- Содержимое файла: backend/migrations/0018_add_bed_images.up.sql ---

CREATE TABLE bed_images (
    id SERIAL PRIMARY KEY,
    bed_id INT NOT NULL REFERENCES beds(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_bed_images_bed_id ON bed_images(bed_id);

--- Содержимое файла: backend/migrations/0016_fix_bed_availability.down.sql ---

DROP FUNCTION IF EXISTS get_beds_availability;
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds;

--- Содержимое файла: backend/migrations/0002_add_price_per_night.up.sql ---

ALTER TABLE rooms 
    ADD COLUMN price_per_night NUMERIC(10, 2) NOT NULL DEFAULT 0 
    CHECK (price_per_night >= 0);
CREATE INDEX idx_users_email ON users(email);

-- Добавить составной индекс для фильтрации комнат
CREATE INDEX idx_rooms_capacity_price ON rooms(capacity, price_per_night);

--- Содержимое файла: backend/migrations/0015_fix_available_beds.up.sql ---

-- Удаляем старый триггер и функцию
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds();

-- Создаем улучшенную функцию обновления доступных мест
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    -- Обновляем количество доступных мест для комнаты, связанной с бронированием
    WITH bed_count AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        LEFT JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE 
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = r.total_beds - COALESCE(bc.booked_beds, 0)
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем новый триггер
CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();

-- Создаем функцию для получения количества доступных мест на конкретные даты
CREATE OR REPLACE FUNCTION get_available_beds(
    room_id_param INTEGER,
    start_date_param DATE,
    end_date_param DATE
)
RETURNS INTEGER AS $$
DECLARE
    total_beds INTEGER;
    booked_beds INTEGER;
BEGIN
    -- Получаем общее количество кроватей
    SELECT total_beds INTO total_beds
    FROM rooms
    WHERE id = room_id_param;

    -- Считаем количество забронированных кроватей на указанные даты
    SELECT COUNT(DISTINCT bb.bed_id) INTO booked_beds
    FROM bed_bookings bb
    JOIN beds b ON bb.bed_id = b.id
    WHERE b.room_id = room_id_param
    AND bb.status = 'confirmed'
    AND bb.start_date <= end_date_param
    AND bb.end_date >= start_date_param;

    -- Возвращаем разницу
    RETURN total_beds - COALESCE(booked_beds, 0);
END;
$$ LANGUAGE plpgsql;

-- Функция инициализации доступных мест
CREATE OR REPLACE FUNCTION initialize_available_beds()
RETURNS void AS $$
BEGIN
    WITH bed_count AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        LEFT JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE 
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = r.total_beds - COALESCE(bc.booked_beds, 0)
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';
END;
$$ LANGUAGE plpgsql;

-- Выполняем начальную инициализацию
SELECT initialize_available_beds();

--- Содержимое файла: backend/migrations/0006_add_room_address.down.sql ---

-- 0006_add_room_address.down.sql
DROP INDEX IF EXISTS idx_rooms_city;
DROP INDEX IF EXISTS idx_rooms_country;

ALTER TABLE rooms
    DROP COLUMN address_street,
    DROP COLUMN address_city,
    DROP COLUMN address_state,
    DROP COLUMN address_country,
    DROP COLUMN address_postal_code;

--- Содержимое файла: backend/migrations/0021_add_google_id_to_users.up.sql ---

ALTER TABLE users 
ADD COLUMN google_id VARCHAR(255) UNIQUE,
ADD COLUMN picture_url TEXT;

--- Содержимое файла: backend/migrations/0021_add_google_id_to_users.down.sql ---

ALTER TABLE users 
DROP COLUMN google_id,
DROP COLUMN picture_url;

--- Содержимое файла: backend/migrations/0014_add_beds_trigger.down.sql ---

-- Удаляем триггер
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;

-- Удаляем функцию
DROP FUNCTION IF EXISTS update_available_beds();

--- Содержимое файла: backend/migrations/0014_add_beds_trigger.up.sql ---

-- Создаем функцию для подсчета доступных кроватей
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
            AND (
                (start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE)
            )
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем триггер для таблицы bed_bookings
CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();

--- Содержимое файла: backend/migrations/0005_add_status_and_indexes.down.sql ---

-- 0005_add_status_and_indexes.down.sql
DROP INDEX IF EXISTS idx_bookings_status;
DROP INDEX IF EXISTS idx_bookings_dates;
ALTER TABLE bookings DROP COLUMN status;

--- Содержимое файла: backend/migrations/0017_add_location_fields.up.sql ---

-- Добавляем поля для координат и форматированного адреса
ALTER TABLE rooms
    ADD COLUMN latitude DECIMAL(10, 8),
    ADD COLUMN longitude DECIMAL(11, 8),
    ADD COLUMN formatted_address TEXT;

-- Индекс для географического поиска
CREATE INDEX idx_rooms_location ON rooms(latitude, longitude);

-- Функция для валидации координат
CREATE OR REPLACE FUNCTION validate_coordinates()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.latitude IS NOT NULL AND (NEW.latitude < -90 OR NEW.latitude > 90) THEN
        RAISE EXCEPTION 'Широта должна быть между -90 и 90';
    END IF;
    IF NEW.longitude IS NOT NULL AND (NEW.longitude < -180 OR NEW.longitude > 180) THEN
        RAISE EXCEPTION 'Долгота должна быть между -180 и 180';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Триггер для валидации координат
CREATE TRIGGER validate_coordinates_trigger
    BEFORE INSERT OR UPDATE ON rooms
    FOR EACH ROW
    EXECUTE FUNCTION validate_coordinates();

--- Содержимое файла: backend/migrations/0007_add_room_images.down.sql ---

-- 0007_add_room_images.down.sql
DROP TABLE IF EXISTS room_images;

--- Содержимое файла: backend/migrations/0011_extend_room_types.up.sql ---

ALTER TABLE rooms
    ADD COLUMN accommodation_type VARCHAR(50) NOT NULL DEFAULT 'room'
    CHECK (accommodation_type IN ('bed', 'room', 'apartment')),
    ADD COLUMN is_shared BOOLEAN NOT NULL DEFAULT false,
    ADD COLUMN total_beds INT,
    ADD COLUMN available_beds INT,
    ADD COLUMN has_private_bathroom BOOLEAN NOT NULL DEFAULT true;

CREATE TABLE beds (
    id SERIAL PRIMARY KEY,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    bed_number INT NOT NULL,
    is_available BOOLEAN NOT NULL DEFAULT true,
    price_per_night DECIMAL(10, 2) NOT NULL CHECK (price_per_night >= 0),
    UNIQUE(room_id, bed_number)
);

CREATE TABLE bed_bookings (
    id SERIAL PRIMARY KEY,
    bed_id INT REFERENCES beds(id) ON DELETE CASCADE,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL CHECK (end_date > start_date),
    status VARCHAR(20) NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--- Содержимое файла: backend/migrations/0020_add_demo_data.down.sql ---

-- Удаляем демо данные
DELETE FROM bed_images;
DELETE FROM beds;
DELETE FROM room_images;
DELETE FROM rooms;
DELETE FROM users WHERE email = 'demo@example.com';

-- Восстанавливаем старое ограничение
DROP INDEX IF EXISTS unique_main_image_per_room;
ALTER TABLE room_images ADD CONSTRAINT unique_main_image_per_room UNIQUE (room_id, is_main);

--- Содержимое файла: backend/migrations/0005_add_status_and_indexes.up.sql ---

-- 0005_add_status_and_indexes.up.sql
ALTER TABLE bookings 
    ADD COLUMN status VARCHAR(20) NOT NULL 
    DEFAULT 'pending' 
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

CREATE INDEX idx_bookings_status ON bookings(status);
CREATE INDEX idx_bookings_dates ON bookings(start_date, end_date);

--- Содержимое файла: backend/migrations/0018_add_bed_images.down.sql ---

DROP TABLE IF EXISTS bed_images;


--- Содержимое файла: backend/migrations/0013_update_bed_bookings.down.sql ---

-- 0013_update_bed_bookings.down.sql
DROP INDEX IF EXISTS idx_bed_bookings_dates_status;
ALTER TABLE bed_bookings DROP COLUMN IF EXISTS status;

--- Содержимое файла: backend/migrations/0012_add_accommodation_types.down.sql ---

-- 0012_add_accommodation_types.down.sql
ALTER TABLE bookings DROP COLUMN IF EXISTS status;

--- Содержимое файла: backend/migrations/0004_update_constraints.up.sql ---


-- Add NOT NULL constraint to ensure data integrity.
ALTER TABLE bookings
ALTER COLUMN user_id SET NOT NULL,
ALTER COLUMN room_id SET NOT NULL;

-- Add an index to optimize queries on bookings table.
CREATE INDEX idx_bookings_user_id ON bookings(user_id);
CREATE INDEX idx_bookings_room_id ON bookings(room_id);


--- Содержимое файла: backend/migrations/0019_update_bed_availability_trigger.down.sql ---

CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms r
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--- Содержимое файла: backend/migrations/0012_add_accommodation_types.up.sql ---

-- 0012_add_accommodation_types.up.sql
ALTER TABLE bookings
    ADD COLUMN IF NOT EXISTS status VARCHAR(20) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

--- Содержимое файла: backend/migrations/0013_update_bed_bookings.up.sql ---

-- 0013_update_bed_bookings.up.sql
ALTER TABLE bed_bookings
ADD COLUMN IF NOT EXISTS status VARCHAR(20) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

-- Создаем индекс для оптимизации поиска
CREATE INDEX IF NOT EXISTS idx_bed_bookings_dates_status 
ON bed_bookings(start_date, end_date, status);

--- Содержимое файла: backend/migrations/0003_add_constraints_and_indexes.down.sql ---


-- Remove constraints and indexes added in the up migration
ALTER TABLE bookings DROP CONSTRAINT valid_date_range;

DROP INDEX IF EXISTS idx_rooms_price;
DROP INDEX IF EXISTS idx_bookings_room_date;


--- Содержимое файла: backend/migrations/0017_add_location_fields.down.sql ---

-- Удаляем триггер и функцию
DROP TRIGGER IF EXISTS validate_coordinates_trigger ON rooms;
DROP FUNCTION IF EXISTS validate_coordinates;

-- Удаляем индекс
DROP INDEX IF EXISTS idx_rooms_location;

-- Удаляем колонки
ALTER TABLE rooms
    DROP COLUMN IF EXISTS latitude,
    DROP COLUMN IF EXISTS longitude,
    DROP COLUMN IF EXISTS formatted_address;

--- Содержимое файла: backend/migrations/0001_create_tables.down.sql ---

DROP TABLE IF EXISTS bookings CASCADE;
DROP TABLE IF EXISTS rooms CASCADE;
DROP TABLE IF EXISTS users CASCADE;


--- Содержимое файла: backend/migrations/0007_add_room_images.up.sql ---

-- 0007_add_room_images.up.sql
CREATE TABLE room_images (
    id SERIAL PRIMARY KEY,
    room_id INT NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    is_main BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_main_image_per_room UNIQUE (room_id, is_main) 
        DEFERRABLE INITIALLY DEFERRED
);

CREATE INDEX idx_room_images_room_id ON room_images(room_id);

--- Содержимое файла: backend/migrations/0015_fix_available_beds.down.sql ---

-- Удаляем созданные функции и триггеры
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds();
DROP FUNCTION IF EXISTS get_available_beds(INTEGER, DATE, DATE);
DROP FUNCTION IF EXISTS initialize_available_beds();

-- Возвращаем простой триггер для обновления available_beds
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
            AND (
                (start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE)
            )
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();

--- Содержимое файла: backend/migrations/0011_extend_room_types.down.sql ---

-- 0011_extend_room_types.down.sql
DROP TABLE IF EXISTS bed_bookings;
DROP TABLE IF EXISTS beds;
ALTER TABLE rooms
    DROP COLUMN accommodation_type,
    DROP COLUMN is_shared,
    DROP COLUMN total_beds,
    DROP COLUMN available_beds,
    DROP COLUMN has_private_bathroom;

--- Содержимое файла: backend/migrations/0002_add_price_per_night.down.sql ---

ALTER TABLE rooms DROP COLUMN price_per_night;

--- Содержимое файла: backend/migrations/0016_fix_bed_availability.up.sql ---

-- Название файла: backend/migrations/0016_fix_bed_availability.up.sql

-- Удаляем старую версию функции если она существует
DROP FUNCTION IF EXISTS update_available_beds CASCADE;

-- Создаем новую функцию
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    WITH bed_count AS (
        SELECT 
            b.room_id,
            COUNT(DISTINCT b.id) as total_beds,
            COUNT(DISTINCT CASE 
                WHEN NOT EXISTS (
                    SELECT 1 
                    FROM bed_bookings bb 
                    WHERE bb.bed_id = b.id 
                    AND bb.status = 'confirmed'
                    AND (
                        (bb.start_date <= CURRENT_DATE AND bb.end_date >= CURRENT_DATE) OR
                        (bb.start_date >= CURRENT_DATE AND bb.start_date <= CURRENT_DATE)
                    )
                ) THEN b.id 
            END) as available_beds
        FROM beds b
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET 
        total_beds = bc.total_beds,
        available_beds = bc.available_beds
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Пересоздаем триггер
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
CREATE TRIGGER bed_bookings_update_trigger
    AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
    FOR EACH ROW
    EXECUTE FUNCTION update_available_beds();

-- Создаем функцию для получения количества доступных мест на определенные даты
CREATE OR REPLACE FUNCTION get_beds_availability(
    p_room_id INTEGER,
    p_start_date DATE,
    p_end_date DATE
) RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT COUNT(DISTINCT b.id)
        FROM beds b
        WHERE b.room_id = p_room_id
        AND b.is_available = true
        AND NOT EXISTS (
            SELECT 1
            FROM bed_bookings bb
            WHERE bb.bed_id = b.id
            AND bb.status = 'confirmed'
            AND (
                (bb.start_date <= p_end_date AND bb.end_date >= p_start_date) OR
                (bb.start_date >= p_start_date AND bb.start_date <= p_end_date)
            )
        )
    );
END;
$$ LANGUAGE plpgsql;

--- Содержимое файла: backend/migrations/0006_add_room_address.up.sql ---

-- 0006_add_room_address.up.sql
ALTER TABLE rooms
    ADD COLUMN address_street VARCHAR(255) NOT NULL DEFAULT '',
    ADD COLUMN address_city VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_state VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_country VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_postal_code VARCHAR(20) NOT NULL DEFAULT '';

CREATE INDEX idx_rooms_city ON rooms(address_city);
CREATE INDEX idx_rooms_country ON rooms(address_country);

--- Содержимое файла: backend/migrations/0020_add_demo_data.up.sql ---

-- backend/migrations/0020_add_demo_data.up.sql

-- Сначала фиксим ограничение для изображений
ALTER TABLE room_images DROP CONSTRAINT IF EXISTS unique_main_image_per_room;
CREATE UNIQUE INDEX unique_main_image_per_room ON room_images (room_id) WHERE is_main = true;

-- Очищаем существующие данные
TRUNCATE bed_images, beds, room_images, rooms, users CASCADE;

-- Сбрасываем последовательности
ALTER SEQUENCE rooms_id_seq RESTART WITH 1;
ALTER SEQUENCE beds_id_seq RESTART WITH 1;
ALTER SEQUENCE room_images_id_seq RESTART WITH 1;
ALTER SEQUENCE bed_images_id_seq RESTART WITH 1;
ALTER SEQUENCE users_id_seq RESTART WITH 1;

-- Создаем тестового пользователя
INSERT INTO users (name, email) VALUES
('Demo User', 'demo@example.com');

-- Создаем демонстрационные объекты

-- 1. Апартаменты в центре
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Уютные апартаменты в центре', 4, 80,
    'Dunavska 35', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'apartment', false, true,
    45.255421, 19.845241,
    'Dunavska 35, Novi Sad, Serbia'
);

-- Добавляем изображения для первых апартаментов
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '1.jpg', 'apartment1.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '2.jpg', 'apartment2.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '3.jpg', 'apartment3.jpg', 1024, 'image/jpeg', false);

-- 2. Апартаменты возле парка
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Просторные апартаменты у парка', 6, 120,
    'Futoška 12', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'apartment', false, true,
    45.249877, 19.833657,
    'Futoška 12, Novi Sad, Serbia'
);

-- Добавляем изображения для вторых апартаментов
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '4.jpg', 'apartment4.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '5.jpg', 'apartment5.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '6.jpg', 'apartment6.jpg', 1024, 'image/jpeg', false);

-- 3. Приватная комната в историческом центре
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Уютная комната в историческом центре', 2, 35,
    'Zmaj Jovina 4', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'room', false, true,
    45.254663, 19.844966,
    'Zmaj Jovina 4, Novi Sad, Serbia'
);

-- Добавляем изображения для первой приватной комнаты
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '7.jpg', 'room1.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '8.jpg', 'room2.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '1.jpg', 'room3.jpg', 1024, 'image/jpeg', false);

-- 4. Приватная комната возле набережной
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Комната с видом на Дунай', 2, 40,
    'Beogradski kej 31', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'room', false, true,
    45.256893, 19.861559,
    'Beogradski kej 31, Novi Sad, Serbia'
);

-- Добавляем изображения для второй приватной комнаты
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '2.jpg', 'room4.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '3.jpg', 'room5.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '4.jpg', 'room6.jpg', 1024, 'image/jpeg', false);

-- 5. Хостел в центре (койко-места)
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, total_beds, available_beds, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Центральный хостел', 6, 12,
    'Miletićeva 15', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'bed', true, 6, 6, true,
    45.252558, 19.842895,
    'Miletićeva 15, Novi Sad, Serbia'
);

-- Добавляем изображения для первого хостела
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '5.jpg', 'hostel1.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '6.jpg', 'hostel2.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '7.jpg', 'hostel3.jpg', 1024, 'image/jpeg', false);

-- Добавляем кровати для первого хостела
INSERT INTO beds (room_id, bed_number, price_per_night, is_available) VALUES
((SELECT MAX(id) FROM rooms), 11, 12, true),
((SELECT MAX(id) FROM rooms), 12, 12, true),
((SELECT MAX(id) FROM rooms), 21, 12, true),
((SELECT MAX(id) FROM rooms), 22, 12, true),
((SELECT MAX(id) FROM rooms), 31, 12, true),
((SELECT MAX(id) FROM rooms), 32, 12, true);

-- Добавляем изображения для кроватей первого хостела
INSERT INTO bed_images (bed_id, file_path, file_name, file_size, content_type) VALUES
((SELECT MAX(id) FROM beds), '8.jpg', 'bed1.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) FROM beds), '1.jpg', 'bed2.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 1 FROM beds), '2.jpg', 'bed3.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 2 FROM beds), '3.jpg', 'bed4.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 3 FROM beds), '4.jpg', 'bed5.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 4 FROM beds), '5.jpg', 'bed6.jpg', 1024, 'image/jpeg');

-- 6. Хостел возле вокзала (койко-места)
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, total_beds, available_beds, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Хостел у вокзала', 4, 10,
    'Bulevar Jaše Tomića 5', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'bed', true, 4, 4, true,
    45.260721, 19.831572,
    'Bulevar Jaše Tomića 5, Novi Sad, Serbia'
);

-- Добавляем изображения для второго хостела
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '6.jpg', 'hostel4.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '7.jpg', 'hostel5.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '8.jpg', 'hostel6.jpg', 1024, 'image/jpeg', false);

-- Добавляем кровати для второго хостела
INSERT INTO beds (room_id, bed_number, price_per_night, is_available) VALUES
((SELECT MAX(id) FROM rooms), 1, 10, true),
((SELECT MAX(id) FROM rooms), 2, 10, true),
((SELECT MAX(id) FROM rooms), 3, 10, true),
((SELECT MAX(id) FROM rooms), 4, 10, true);

-- Добавляем изображения для кроватей второго хостела
INSERT INTO bed_images (bed_id, file_path, file_name, file_size, content_type) VALUES
((SELECT MAX(id) FROM beds), '1.jpg', 'bed7.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 1 FROM beds), '2.jpg', 'bed8.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 2 FROM beds), '3.jpg', 'bed9.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 3 FROM beds), '4.jpg', 'bed10.jpg', 1024, 'image/jpeg');



--- Содержимое файла: backend/migrations/0003_add_constraints_and_indexes.up.sql ---


-- Add additional constraints and indexes to fix issues
ALTER TABLE bookings
    ADD CONSTRAINT valid_date_range 
    CHECK (start_date < end_date AND start_date >= CURRENT_DATE);

-- Indexes to optimize queries
CREATE INDEX idx_rooms_price ON rooms (price_per_night);
CREATE INDEX idx_bookings_room_date ON bookings (room_id, start_date, end_date);


--- Содержимое файла: backend/migrations/0019_update_bed_availability_trigger.up.sql ---

-- Обновляем функцию подсчета доступных мест
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    -- Обновляем количество доступных мест для комнаты с учетом текущих броней
    WITH current_bookings AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = COALESCE(r.total_beds, 0) - COALESCE(cb.booked_beds, 0)
    FROM current_bookings cb
    WHERE r.id = cb.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--- Содержимое файла: frontend/hostel-frontend/src/index.js ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { ThemeProvider } from "@mui/material/styles";
import { CssBaseline } from '@mui/material';
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  // Можно добавить кастомные настройки темы
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <App />
    </ThemeProvider>
  </React.StrictMode>
);

reportWebVitals();

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


--- Содержимое файла: frontend/hostel-frontend/src/App.js ---

import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { AuthProvider } from "./contexts/AuthContext";
import Layout from "./components/Layout";
import HomePage from "./pages/HomePage";
import AddRoomPage from "./pages/AddRoomPage";
import AddUserPage from "./pages/AddUserPage";
import BookingsListPage from "./pages/BookingsListPage";
import AdminPanelPage from "./pages/AdminPanelPage";

function App() {
  return (
    <AuthProvider>
      <Router>
        <Layout>
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/bookings" element={<BookingsListPage />} />
            <Route path="/add-room" element={<AddRoomPage />} />
            <Route path="/add-user" element={<AddUserPage />} />
            <Route path="/admin" element={<AdminPanelPage />} />
          </Routes>
        </Layout>
      </Router>
    </AuthProvider>
  );
}

export default App;

--- Содержимое файла: frontend/hostel-frontend/src/api/axios.js ---

import axios from 'axios';

const instance = axios.create({
  baseURL: process.env.REACT_APP_BACKEND_URL,
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json'
  }
});

export default instance;

--- Содержимое файла: frontend/hostel-frontend/src/components/RoomList.js ---

import React, { useState, useEffect, useCallback } from 'react';
import axios from "../api/axios";
import { Chip } from '@mui/material';
import { LoadScript } from '@react-google-maps/api';
import {
    Grid, Card, CardContent, Typography, TextField,
    Button, Divider, Box, Dialog, DialogContent, IconButton,
    MobileStepper, CardMedia,
    ToggleButton,
    ToggleButtonGroup,
    Paper,
    ButtonGroup
} from "@mui/material";
import {
    KeyboardArrowLeft, KeyboardArrowRight,
    Close as CloseIcon,
    SingleBed as HotelIcon,
    Hotel as SingleBedIcon,
    Apartment as ApartmentIcon,
    Home as HomeIcon,
    ViewList as ViewListIcon,
    Map as MapIcon,
    Search as SearchIcon
} from '@mui/icons-material';
import BookingDialog from "./BookingDialog";
import MapView from './MapView';


const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;

const ImageGallery = ({ images, open, onClose }) => {
    const [activeStep, setActiveStep] = useState(0);
    const maxSteps = images.length;

    const handleNext = () => {
        setActiveStep((prevStep) => (prevStep + 1) % maxSteps);
    };

    const handleBack = () => {
        setActiveStep((prevStep) => (prevStep - 1 + maxSteps) % maxSteps);
    };

    if (!images.length) return null;

    return (
        <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
            <DialogContent sx={{ position: 'relative', p: 0 }}>
                <IconButton
                    onClick={onClose}
                    sx={{
                        position: 'absolute',
                        right: 8,
                        top: 8,
                        color: 'white',
                        bgcolor: 'rgba(0, 0, 0, 0.5)',
                        '&:hover': {
                            bgcolor: 'rgba(0, 0, 0, 0.7)',
                        },
                    }}
                >
                    <CloseIcon />
                </IconButton>
                <Box sx={{ height: '80vh', display: 'flex', flexDirection: 'column', justifyContent: 'center' }}>
                    <img
                        src={`${BACKEND_URL}/uploads/${images[activeStep].file_path}`} // Исправлено здесь
                        alt={images[activeStep].file_name}
                        style={{
                            width: '100%',
                            height: '100%',
                            objectFit: 'contain',
                        }}
                    />
                    <MobileStepper
                        steps={maxSteps}
                        position="static"
                        activeStep={activeStep}
                        sx={{
                            bgcolor: 'background.default',
                            position: 'absolute',
                            bottom: 0,
                            width: '100%',
                        }}
                        nextButton={
                            <Button size="small" onClick={handleNext}>
                                Следующее
                                <KeyboardArrowRight />
                            </Button>
                        }
                        backButton={
                            <Button size="small" onClick={handleBack}>
                                <KeyboardArrowLeft />
                                Предыдущее
                            </Button>
                        }
                    />
                </Box>
            </DialogContent>
        </Dialog>
    );
};

const RoomList = () => {
    const [rooms, setRooms] = useState([]);
    const [filters, setFilters] = useState({
        capacity: "",
        min_price: "",
        max_price: "",
        city: "",
        country: "",
        start_date: "",
        end_date: "",
        type: ''
    });

    const handleTypeFilter = (type) => {
        setFilters(prev => ({
            ...prev,
            type: prev.type === type ? '' : type // сброс фильтра при повторном нажатии
        }));
    };


    const [viewMode, setViewMode] = useState('list'); // 'list' или 'map'
    const [roomsWithCoordinates, setRoomsWithCoordinates] = useState([]);
    const geocodeRooms = async (rooms) => {
        if (!window.google) return rooms;

        const geocoder = new window.google.maps.Geocoder();
        const geocodeAddress = async (room) => {
            const address = `${room.address_street}, ${room.address_city}, ${room.address_country}`;
            try {
                const result = await new Promise((resolve, reject) => {
                    geocoder.geocode({ address }, (results, status) => {
                        if (status === 'OK') {
                            resolve(results[0].geometry.location);
                        } else {
                            reject(status);
                        }
                    });
                });

                return {
                    ...room,
                    latitude: result.lat(),
                    longitude: result.lng()
                };
            } catch (error) {
                console.error(`Error geocoding address: ${address}`, error);
                return room;
            }
        };

        const roomsWithCoords = await Promise.all(rooms.map(geocodeAddress));
        return roomsWithCoords;
    };
    const [selectedRoom, setSelectedRoom] = useState(null);
    const [galleryOpen, setGalleryOpen] = useState(false);
    const [bookingDialogOpen, setBookingDialogOpen] = useState(false);

    const fetchRooms = useCallback(async () => {
        try {
            const params = new URLSearchParams();

            // Добавляем базовые параметры
            if (filters.capacity && parseInt(filters.capacity) > 0) {
                params.append('capacity', filters.capacity);
            }
            if (filters.min_price && parseFloat(filters.min_price) > 0) {
                params.append('min_price', filters.min_price);
            }
            if (filters.max_price && parseFloat(filters.max_price) > 0) {
                params.append('max_price', filters.max_price);
            }
            if (filters.city?.trim()) {
                params.append('city', filters.city.trim());
            }
            if (filters.country?.trim()) {
                params.append('country', filters.country.trim());
            }

            // Добавляем фильтр по типу размещения
            if (filters.type) {
                params.append('accommodation_type', filters.type);
                if (filters.type === 'room') {
                    params.append('has_private_rooms', 'true');
                }
            }

            // Всегда отправляем даты для проверки доступности
            const today = new Date().toISOString().split('T')[0];
            params.append('start_date', filters.start_date || today);
            params.append('end_date', filters.end_date || today);

            const response = await axios.get(`/rooms?${params.toString()}`);
            const roomsData = response.data || [];

            // Фильтрация на фронтенде
            const filteredRooms = roomsData.filter(room => {
                // Базовая проверка доступности
                if (room.accommodation_type === 'bed' && room.available_beds <= 0) {
                    return false;
                }

                // Проверка типа размещения
                if (filters.type && room.accommodation_type !== filters.type) {
                    return false;
                }

                // Проверка для приватных комнат
                if (filters.type === 'room' && room.is_shared) {
                    return false;
                }

                return true;
            });

            // Получаем изображения для отфильтрованных комнат
            const roomsWithImages = await Promise.all(
                filteredRooms.map(async (room) => {
                    const imagesResponse = await axios.get(`/rooms/${room.id}/images`);
                    return {
                        ...room,
                        images: imagesResponse.data || []
                    };
                })
            );

            setRooms(roomsWithImages);
            setRoomsWithCoordinates(roomsWithImages.filter(room =>
                room.latitude && room.longitude));

        } catch (error) {
            console.error("Ошибка при получении списка комнат:", error);
        }
    }, [filters]);

    const handleDateChange = (field, value) => {
        setFilters(prev => {
            const newFilters = { ...prev, [field]: value };

            if (field === 'end_date' && newFilters.start_date && value < newFilters.start_date) {
                return prev;
            }

            if (field === 'start_date' && newFilters.end_date && value > newFilters.end_date) {
                return prev;
            }

            return newFilters;
        });
    };

    const handleBooking = (room) => {
        if (!filters.start_date || !filters.end_date) {
            alert('Пожалуйста, выберите даты заезда и выезда');
            return;
        }
        setSelectedRoom(room);
        setBookingDialogOpen(true);
    };

// долой протечки памяти
    useEffect(() => {
        let isSubscribed = true;
        
        const fetchData = async () => {
            try {
                const response = await fetchRooms();
                if (isSubscribed) {
                    setRooms(response.data);
                }
            } catch (error) {
                if (isSubscribed) {
                    console.error(error);
                }
            }
        };
        
        fetchData();
        
        return () => {
            isSubscribed = false;
        };
    }, [fetchRooms]);

    const AccommodationInfo = ({ room }) => {
        const getAccommodationInfo = () => {
            switch (room.accommodation_type) {
                case 'bed':
                    return {
                        title: 'Койко-место',
                        details: `Доступно ${room.available_beds} из ${room.total_beds} мест`,
                        icon: <HotelIcon />,
                        shared: true
                    };
                case 'room':
                    return {
                        title: room.is_shared ? 'Общая комната' : 'Отдельная комната',
                        details: `Вместимость: ${room.capacity} чел.`,
                        icon: <SingleBedIcon />,
                        shared: room.is_shared
                    };
                case 'apartment':
                    return {
                        title: 'Квартира',
                        details: `${room.capacity} комнат`,
                        icon: <ApartmentIcon />,
                        shared: false
                    };
                default:
                    return {
                        title: 'Помещение',
                        details: `Вместимость: ${room.capacity} чел.`,
                        icon: <HomeIcon />,
                        shared: false
                    };
            }
        };

        const info = getAccommodationInfo();

        return (
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                {info.icon}
                <Box>
                    <Typography variant="subtitle2" sx={{ fontWeight: 'medium' }}>
                        {info.title}
                        {info.shared && (
                            <Chip
                                size="small"
                                label="Общее помещение"
                                color="secondary"
                                sx={{ ml: 1 }}
                            />
                        )}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                        {info.details}
                    </Typography>
                </Box>
            </Box>
        );
    };


    const today = new Date().toISOString().split('T')[0];

    return (
        <div>

            <Grid container spacing={2} sx={{ mb: 3, mt: 1 }}>
                {/* Первая строка с датами, городом, страной и ценами */}
                <Grid item container spacing={2} xs={12}>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Дата заезда"
                            type="date"
                            size="small"
                            fullWidth
                            InputLabelProps={{ shrink: true }}
                            value={filters.start_date}
                            onChange={(e) => handleDateChange('start_date', e.target.value)}
                            inputProps={{ min: today }}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Дата выезда"
                            type="date"
                            size="small"
                            fullWidth
                            InputLabelProps={{ shrink: true }}
                            value={filters.end_date}
                            onChange={(e) => handleDateChange('end_date', e.target.value)}
                            inputProps={{ min: filters.start_date || today }}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Город"
                            size="small"
                            fullWidth
                            value={filters.city}
                            onChange={(e) => setFilters({ ...filters, city: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Страна"
                            size="small"
                            fullWidth
                            value={filters.country}
                            onChange={(e) => setFilters({ ...filters, country: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Мин. цена"
                            type="number"
                            size="small"
                            fullWidth
                            value={filters.min_price}
                            onChange={(e) => setFilters({ ...filters, min_price: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Макс. цена"
                            type="number"
                            size="small"
                            fullWidth
                            value={filters.max_price}
                            onChange={(e) => setFilters({ ...filters, max_price: e.target.value })}
                        />
                    </Grid>
                </Grid>

                {/* Вторая строка с кнопками */}
                <Grid item container xs={12} spacing={2} alignItems="center">
                    <Grid item>
                        <Button
                            variant="contained"
                            color="primary"
                            onClick={fetchRooms}
                            startIcon={<SearchIcon />}
                        >
                            Найти
                        </Button>
                    </Grid>
                    <Grid item>
                        <ButtonGroup
                            variant="outlined"
                            sx={{
                                '& .MuiButton-root': {
                                    borderColor: '#1976d2',
                                    '&:hover': {
                                        borderColor: '#1976d2',
                                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                    }
                                }
                            }}
                        >
                            <Button
                                onClick={() => handleTypeFilter('apartment')}
                                startIcon={<ApartmentIcon />}
                                color={filters.type === 'apartment' ? 'primary' : 'inherit'}
                            >
                                Аппарты
                            </Button>
                            <Button
                                onClick={() => handleTypeFilter('room')}
                                startIcon={<HotelIcon />}
                                color={filters.type === 'room' ? 'primary' : 'inherit'}
                            >
                                Приватка
                            </Button>
                            <Button
                                onClick={() => handleTypeFilter('bed')}
                                startIcon={<SingleBedIcon />}
                                color={filters.type === 'bed' ? 'primary' : 'inherit'}
                            >
                                Кровать
                            </Button>
                        </ButtonGroup>
                    </Grid>
                    <Grid item sx={{ marginLeft: 'auto' }}>
                        <ToggleButtonGroup
                            value={viewMode}
                            exclusive
                            onChange={(e, newMode) => newMode && setViewMode(newMode)}
                            aria-label="view mode"
                            size="small"
                            sx={{
                                border: '1px solid rgba(25, 118, 210, 0.5)',
                                '& .MuiToggleButton-root': {
                                    '&.Mui-selected': {
                                        backgroundColor: '#1976d2',
                                        color: 'white',
                                        '&:hover': {
                                            backgroundColor: '#1565c0',
                                        }
                                    },
                                    '&:hover': {
                                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                    }
                                }
                            }}
                        >
                            <ToggleButton value="list" aria-label="list view">
                                <ViewListIcon /> Список
                            </ToggleButton>
                            <ToggleButton value="map" aria-label="map view">
                                <MapIcon /> Карта
                            </ToggleButton>
                        </ToggleButtonGroup>
                    </Grid>
                </Grid>
            </Grid>
            <Box>
                {viewMode === 'map' ? (
                    <LoadScript
                        googleMapsApiKey={process.env.REACT_APP_GOOGLE_MAPS_API_KEY}
                        libraries={["places", "geometry"]}
                    >
                        <MapView
                            rooms={roomsWithCoordinates}
                            onRoomSelect={(room) => {
                                setSelectedRoom(room);
                                setBookingDialogOpen(true);
                            }}
                            onOpenGallery={(room) => {
                                setSelectedRoom(room);
                                setGalleryOpen(true);
                            }}
                        />
                    </LoadScript>
                ) : (
                    <Grid container spacing={2}>
                        {rooms.map((room) => (
                            <Grid item xs={12} md={6} lg={4} key={room.id}>
                                <Card sx={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    height: '100%',
                                    border: '1px solid rgba(25, 118, 210, 0.2)',
                                    boxShadow: '0 2px 4px rgba(25, 118, 210, 0.1)',
                                    '&:hover': {
                                        boxShadow: '0 4px 8px rgba(25, 118, 210, 0.2)',
                                    },
                                    '& .MuiCardContent-root': {
                                        padding: '12px',
                                    },
                                    '& .MuiTypography-root': {
                                        lineHeight: '1.3',
                                    }
                                }}>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', p: 1.5 }}>
                                        <Box sx={{ flex: 1, pr: 1.5 }}>
                                            <AccommodationInfo room={room} />
                                            <Typography variant="h6" sx={{
                                                mb: 0.5,
                                                fontSize: '1.1rem'
                                            }}>
                                                {room.name}
                                            </Typography>
                                            {room.accommodation_type === 'bed' ? (
                                                <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
                                                    Цена за койко-место: {room.price_per_night} евро/сутки
                                                </Typography>
                                            ) : (
                                                <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
                                                    Цена за {room.accommodation_type === 'apartment' ? 'квартиру' : 'комнату'}: {room.price_per_night} евро/сутки
                                                </Typography>
                                            )}
                                        </Box>

                                        {/* Правый верхний угол: эскиз */}
                                        <Box sx={{
                                            width: '100px',
                                            height: '100px',
                                            flexShrink: 0,
                                            p: room.images?.length ? 0 : 1
                                        }}>
                                            {room.images && room.images.length > 0 ? (
                                                <CardMedia
                                                    component="img"
                                                    sx={{
                                                        width: '100%',
                                                        height: '100%',
                                                        objectFit: 'cover',
                                                        borderRadius: '4px',
                                                        '&:hover': {
                                                            opacity: 0.8,
                                                            transition: 'opacity 0.2s ease-in-out',
                                                        },
                                                    }}
                                                    image={`${BACKEND_URL}/uploads/${room.images[0].file_path}`}
                                                    alt={room.name}
                                                    onClick={() => {
                                                        setSelectedRoom(room);
                                                        setGalleryOpen(true);
                                                    }}
                                                />
                                            ) : (
                                                <Box
                                                    sx={{
                                                        width: '100%',
                                                        height: '100%',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        bgcolor: 'grey.100',
                                                        borderRadius: '4px',
                                                        fontSize: '0.8rem'
                                                    }}
                                                >
                                                    <Typography variant="body2" color="text.secondary">
                                                        Нет фото
                                                    </Typography>
                                                </Box>
                                            )}
                                        </Box>
                                    </Box>

                                    <Divider />

                                    {/* Нижняя часть карточки с адресом и кнопками */}
                                    <CardContent sx={{
                                        pt: 1,
                                        pb: '8px !important',
                                        display: 'flex',
                                        justifyContent: 'space-between',
                                        alignItems: 'center'
                                    }}>
                                        <Typography variant="body2" color="text.secondary" sx={{
                                            fontSize: '0.85rem',
                                            flex: 1,
                                            mr: 1
                                        }}>
                                            {room.address_street}
                                            {room.address_city && `, ${room.address_city}`}
                                            {room.address_state && `, ${room.address_state}`}
                                            {room.address_country && `, ${room.address_country}`}
                                            {room.address_postal_code && ` (${room.address_postal_code})`}
                                        </Typography>
                                        <Box sx={{ display: 'flex', gap: 0.5 }}>
                                            {room.images && room.images.length > 1 && (
                                                <Button
                                                    size="small"
                                                    sx={{
                                                        minWidth: 'auto',
                                                        padding: '4px 8px',
                                                        fontSize: '0.8rem',
                                                        borderColor: '#1976d2',
                                                        color: '#1976d2',
                                                        '&:hover': {
                                                            borderColor: '#1565c0',
                                                            backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                                        }
                                                    }}
                                                    onClick={() => {
                                                        setSelectedRoom(room);
                                                        setGalleryOpen(true);
                                                    }}
                                                >
                                                    Все ({room.images.length})
                                                </Button> 
                                            )}
                                            <Button
                                                variant="contained"
                                                color="primary"
                                                size="small"
                                                sx={{
                                                    minWidth: 'auto',
                                                    padding: '4px 8px',
                                                    fontSize: '0.8rem',
                                                    boxShadow: '0 2px 4px rgba(25, 118, 210, 0.2)',
                                                    '&:hover': {
                                                        boxShadow: '0 4px 8px rgba(25, 118, 210, 0.3)',
                                                    }
                                                }}
                                                onClick={() => handleBooking(room)}
                                                disabled={!filters.start_date || !filters.end_date}
                                            >
                                                Забронировать
                                            </Button>
                                        </Box>
                                    </CardContent>
                                </Card>
                            </Grid>

                        ))}
                    </Grid>
                )}
            </Box>
            {selectedRoom && (
                <>
                    <ImageGallery
                        images={selectedRoom.images || []}
                        open={galleryOpen}
                        onClose={() => {
                            setGalleryOpen(false);
                            setSelectedRoom(null);
                        }}
                    />
                    <BookingDialog
                        open={bookingDialogOpen}
                        onClose={() => {
                            setBookingDialogOpen(false);
                            setSelectedRoom(null);
                        }}
                        room={selectedRoom}
                        startDate={filters.start_date}
                        endDate={filters.end_date}
                    />
                </>
            )}
        </div>
    );
};

export default RoomList;

--- Содержимое файла: frontend/hostel-frontend/src/components/BookingsList.js ---

import React, { useState, useEffect } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  Chip,
  Box
} from '@mui/material';
import {
  Apartment as ApartmentIcon,
  Hotel as HotelIcon,
  SingleBed as SingleBedIcon
} from '@mui/icons-material';
import axios from '../api/axios';

const BookingsList = () => {
  const [bookings, setBookings] = useState([]);

  useEffect(() => {
    const fetchBookings = async () => {
      try {
        const response = await axios.get('/bookings');
        if (Array.isArray(response.data)) {
          setBookings(response.data);
        } else {
          console.error('Unexpected data format:', response.data);
          setBookings([]); // или другая логика
        }
      } catch (error) {
        console.error('Error fetching bookings:', error);
        setBookings([]);
      }
    };

    fetchBookings();
  }, []);

  const getAccommodationIcon = (type) => {
    switch (type) {
      case 'bed':
        return <SingleBedIcon color="primary" />;
      case 'room':
        return <HotelIcon color="primary" />;
      case 'apartment':
        return <ApartmentIcon color="primary" />;
      default:
        return null;
    }
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('ru-RU', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    });
  };

  return (
    <Box>
      <Typography variant="h5" gutterBottom>
        Список бронирований
      </Typography>
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Тип размещения</TableCell>
              <TableCell>Комната</TableCell>
              <TableCell>Клиент</TableCell>
              <TableCell>Даты проживания</TableCell>
              <TableCell>Статус</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {bookings.map((booking) => (
              <TableRow key={booking.id} hover>
                <TableCell>
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                    {getAccommodationIcon(booking.type)}
                    <Typography variant="body2">
                      {booking.type === 'bed'
                        ? 'Койко-место'
                        : booking.type === 'room'
                          ? 'Комната'
                          : 'Квартира'}
                    </Typography>
                  </Box>
                </TableCell>
                <TableCell>
                  <Typography variant="body2">
                    {booking.room_name}
                    {booking.bed_id && (
                      <Typography variant="caption" display="block" color="text.secondary">
                        Место {booking.bed_id}
                      </Typography>
                    )}
                  </Typography>
                </TableCell>
                <TableCell>
                  <Typography variant="body2">
                    {booking.user_name}
                    <Typography variant="caption" display="block" color="text.secondary">
                      {booking.user_email}
                    </Typography>
                  </Typography>
                </TableCell>
                <TableCell>
                  <Box>
                    <Typography variant="body2">
                      {`${formatDate(booking.start_date)} - ${formatDate(booking.end_date)}`}
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      {Math.ceil(
                        (new Date(booking.end_date) - new Date(booking.start_date)) /
                        (1000 * 60 * 60 * 24)
                      )} дней
                    </Typography>
                  </Box>
                </TableCell>
                <TableCell>
                  <Chip
                    size="small"
                    label={booking.status === 'confirmed' ? 'Подтверждено' : 'В обработке'}
                    color={booking.status === 'confirmed' ? 'success' : 'warning'}
                  />
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Box>
  );
};

export default BookingsList;

--- Содержимое файла: deploy/docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

  backend:
    build:
      context: ../backend
    ports:
      - "3000:3000"
    env_file:
      - ../backend/.env
    depends_on:
      - db
    command: [ "go", "run", "main.go" ]
    networks:
      - hostel_network

  frontend:
    build:
      context: ../frontend/hostel-frontend
    ports:
      - "3001:3000"
    environment:
      - REACT_APP_API_URL=https://landhub.rs/api
    networks:
      - hostel_network

volumes:
  db_data:


networks:
  hostel_network:
    driver: bridge


--- Содержимое файла: frontend/hostel-frontend/.env ---

REACT_APP_GOOGLE_MAPS_API_KEY=AIzaSyBISWAfMMEdWSIKL9WASQIWeKbSQo4Dv48
REACT_APP_API_URL=https://landhub.rs
REACT_APP_BACKEND_URL=https://landhub.rs
FRONTEND_URL=https://landhub.rs

--- Содержимое файла: frontend/hostel-frontend/.env.local ---

REACT_APP_API_URL=http://localhost:3000
REACT_APP_BACKEND_URL=http://localhost:3000
tw=Z3Y733JX5KN65B5D8ZXJ1EDD
GOOGLE_CLIENT_ID=917315728307-au9ga5fl7o3bbid9nv7e4l92gut194pq.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
GOOGLE_OAUTH_REDIRECT_URL=http://localhost:3000/auth/google/callback
FRONTEND_URL=http://localhost:3001
PORT=3000

--- Содержимое файла: frontend/hostel-frontend/.gitignore ---

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env.local
.env.development.local
.env.test.local
.env.production.local


--- Содержимое файла: .gitignore ---

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local


npm-debug.log*
yarn-debug.log*
yarn-error.log*
# Node.js
node_modules/
build/
dist/
.cache/

# SSL certificates and related files
/certbot/

# Uploads directory
/backend/uploads/

# Editor files
.vscode/
.idea/
.DS_Store

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
collected_content.txt

# Build directories
/frontend/hostel-frontend/build/
/frontend/hostel-frontend/node_modules/

--- Содержимое файла: deploy.sh ---

#!/bin/bash
set -e  # Останавливаем выполнение при ошибках

echo "Starting deployment..."

# Переходим в папку проекта
cd /opt/hostel-booking-system

# Настраиваем git pull strategy
echo "Configuring git..."
git config pull.rebase false

# Создаем необходимые директории
echo "Creating required directories..."
mkdir -p backend/uploads
mkdir -p frontend/hostel-frontend/build
mkdir -p certbot/conf
mkdir -p certbot/www

# Сохраняем важные файлы
echo "Backing up environment files and SSL certificates..."
mkdir -p /tmp/hostel-backup
cp -f backend/.env /tmp/hostel-backup/backend.env 2>/dev/null || true
cp -f frontend/hostel-frontend/.env /tmp/hostel-backup/frontend.env 2>/dev/null || true

# Сохраняем SSL сертификаты
if [ -d "certbot/conf" ]; then
    cp -r certbot/conf /tmp/hostel-backup/ 2>/dev/null || true
fi

# Сохраняем загруженные изображения
cp -r backend/uploads /tmp/hostel-backup/ 2>/dev/null || true

# Обеспечиваем чистое состояние git
echo "Resetting git state..."
git fetch origin
git reset --hard origin/main
git clean -fdx -e "*.env*" -e "uploads/" -e "certbot/"

# Восстанавливаем файлы
echo "Restoring backups..."
cp -f /tmp/hostel-backup/backend.env backend/.env 2>/dev/null || true
cp -f /tmp/hostel-backup/frontend.env frontend/hostel-frontend/.env 2>/dev/null || true
if [ -d "/tmp/hostel-backup/conf" ]; then
    rm -rf certbot/conf
    cp -r /tmp/hostel-backup/conf certbot/ 2>/dev/null || true
fi

# Собираем фронтенд
echo "Building frontend..."
cd frontend/hostel-frontend
NODE_ENV=production docker run -v $(pwd):/app -w /app node:18 sh -c "npm install --legacy-peer-deps && npm install @babel/plugin-proposal-private-property-in-object && npm run build"
cd ../..

# Останавливаем все контейнеры
echo "Stopping all containers..."
docker-compose -f docker-compose.prod.yml down -v

# Создаем сеть если её нет
docker network create hostel-booking-system_hostel_network 2>/dev/null || true

# Запускаем только базу данных
echo "Starting database..."
docker-compose -f docker-compose.prod.yml up -d db

# Функция для проверки готовности базы данных
check_db() {
    echo "Checking database connection..."
    docker-compose -f docker-compose.prod.yml exec -T db pg_isready -U postgres
}

# Ждем готовности базы данных
echo "Waiting for database to start..."
for i in {1..30}; do
    if check_db > /dev/null 2>&1; then
        echo "Database is ready!"
        break
    fi
    echo "Waiting for database... Attempt $i/30"
    sleep 2
done

# Проверяем финальную готовность
if ! check_db > /dev/null 2>&1; then
    echo "Database failed to start"
    exit 1
fi

# Выполняем миграции
echo "Running migrations..."
docker run --rm \
    --network hostel-booking-system_hostel_network \
    -v $(pwd)/backend/migrations:/migrations \
    migrate/migrate \
    -path=/migrations/ \
    -database="postgres://postgres:c9XWc7Cm@db:5432/hostel_db?sslmode=disable" \
    up

# Проверяем результат миграций
if [ $? -eq 0 ]; then
    echo "Migrations successful! Starting other services..."
    
    # Запускаем остальные сервисы
    docker-compose -f docker-compose.prod.yml up -d

    # Проверяем структуру базы данных
    echo "Checking database structure..."
    sleep 5
    docker-compose -f docker-compose.prod.yml exec -T db psql -U postgres -d hostel_db -c "\dt"
    
    echo "Checking container status..."
    docker-compose -f docker-compose.prod.yml ps
else
    echo "Migration failed!"
    exit 1
fi

# Устанавливаем права на директории
echo "Setting permissions..."
chmod -R 755 backend/uploads || true
chmod -R 755 frontend/hostel-frontend/build || true
chmod -R 755 certbot/conf || true

# Удаляем бэкапы
rm -rf /tmp/hostel-backup

echo "Deployment completed!"

--- Содержимое файла: docker-compose.prod.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    container_name: hostel_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: c9XWc7Cm
      POSTGRES_DB: hostel_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - hostel_network
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build: ./backend
    container_name: hostel_backend
    env_file:
      - ./backend/.env
    networks:
      - hostel_network
    environment:
      - DATABASE_URL=postgres://postgres:c9XWc7Cm@db:5432/hostel_db?sslmode=disable
    volumes:
      - ./backend/uploads:/app/uploads
    depends_on:
      db:
        condition: service_healthy

  nginx:
    image: nginx:alpine
    container_name: hostel_nginx
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf
      - ./frontend/hostel-frontend/build:/usr/share/nginx/html:ro
      - ./backend/uploads:/usr/share/nginx/uploads
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      backend:
        condition: service_started
    networks:
      - hostel_network
    command: "/bin/sh -c 'while :; do sleep 6h & wait $${!}; nginx -s reload; done & nginx -g \"daemon off;\"'"

  certbot:
    image: certbot/certbot
    container_name: hostel_certbot
    volumes:
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"
    networks:
      - hostel_network

volumes:
  postgres_data:

networks:
  hostel_network:
    driver: bridge


--- Содержимое файла: docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    container_name: hostel_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: ./backend
    ports:
      - "3000:3000"
    env_file:
      - ./backend/.env.local
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - ./backend/uploads:/app/uploads
    environment:
      - UPLOAD_DIR=/app/uploads

  migrate:
    image: migrate/migrate
    volumes:
      - ./backend/migrations:/migrations
    command: [
      "-path", "/migrations",
      "-database", "postgres://postgres:password@db:5432/hostel_db?sslmode=disable",
      "up"
    ]
    depends_on:
      db:
        condition: service_healthy

volumes:
  postgres_data:


--- Содержимое файла: nginx.conf ---

upstream api_backend {
    server hostel_backend:3000;
}

# Редирект с HTTP на HTTPS
server {
    listen 80;
    server_name landhub.rs www.landhub.rs;
    
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
    
    location / {
        return 301 https://$host$request_uri;
    }
}

# Основной HTTPS сервер
server {
    listen 443 ssl;
    server_name landhub.rs www.landhub.rs;
    
    ssl_certificate /etc/letsencrypt/live/landhub.rs/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/landhub.rs/privkey.pem;
    
    # Оптимизация SSL
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;

    root /usr/share/nginx/html;
    index index.html;

    # API endpoints сначала
    location /api/ {
        rewrite ^/api/(.*) /$1 break;
        proxy_pass http://api_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
    }

    # Auth endpoints отдельно
    location /auth/ {
        proxy_pass http://api_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
    }

    location /uploads/ {
        alias /usr/share/nginx/uploads/;
        add_header Cache-Control "no-cache";
    }

    # Frontend routes в конце
    location / {
        try_files $uri $uri/ /index.html;
        add_header Cache-Control "no-cache";
    }

    location = /favicon.ico {
        access_log off;
        log_not_found off;
    }

    location = /robots.txt {
        access_log off;
        log_not_found off;
    }
}

