--- Содержимое файла: backend/main.go ---

package main

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"hostel-backend/auth"
	"hostel-backend/database"
	"log"
	"mime/multipart"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/disintegration/imaging"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/joho/godotenv"
)

type Server struct {
	app  *fiber.App
	db   *database.Database
	auth *auth.AuthManager
}

// Вспомогательная функция для обработки изображений
func processImage(file *multipart.FileHeader) (string, error) {
	src, err := file.Open()
	if err != nil {
		return "", err
	}
	defer src.Close()

	ext := filepath.Ext(file.Filename)
	fileName := fmt.Sprintf("%d%s", time.Now().UnixNano(), ext)
	filePath := filepath.Join("uploads", fileName)

	dst, err := os.Create(filePath)
	if err != nil {
		return "", err
	}
	defer dst.Close()

	img, err := imaging.Decode(src)
	if err != nil {
		return "", err
	}

	resized := imaging.Resize(img, 1200, 0, imaging.Lanczos)
	err = imaging.Save(resized, filePath)
	if err != nil {
		return "", err
	}

	return fileName, nil
}

// Вспомогательная функция для генерации токена сессии
func generateSessionToken() string {
	b := make([]byte, 32)
	if _, err := rand.Read(b); err != nil {
		return ""
	}
	return hex.EncodeToString(b)
}

func (s *Server) setupRoutes() {
	// Основные маршруты
	s.app.Get("/", func(c *fiber.Ctx) error {
		return c.SendString("Hostel Booking System API")
	})

	// Добавление пользователя
	s.app.Post("/users", func(c *fiber.Ctx) error {
		var user struct {
			Name  string `json:"name"`
			Email string `json:"email"`
		}
		if err := c.BodyParser(&user); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}

		err := s.db.AddUser(c.Context(), user.Name, user.Email)
		if err != nil {
			if strings.Contains(err.Error(), "unique constraint") {
				return c.Status(400).SendString("Email уже используется")
			}
			return c.Status(500).SendString("Ошибка добавления пользователя")
		}
		return c.SendString("Пользователь добавлен успешно")
	})

	// Маршруты для комнат
	s.app.Post("/rooms", func(c *fiber.Ctx) error {
		var room database.Room
		if err := c.BodyParser(&room); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}

		roomID, err := s.db.AddRoom(c.Context(), room)
		if err != nil {
			if strings.Contains(err.Error(), "unique constraint") {
				return c.Status(400).SendString("Комната с таким названием уже существует")
			}
			return c.Status(500).SendString("Ошибка добавления комнаты")
		}

		return c.JSON(fiber.Map{"id": roomID})
	})

	s.app.Get("/rooms", func(c *fiber.Ctx) error {
		filters := map[string]string{
			"capacity":           c.Query("capacity"),
			"start_date":         c.Query("start_date"),
			"end_date":           c.Query("end_date"),
			"min_price":          c.Query("min_price"),
			"max_price":          c.Query("max_price"),
			"city":               c.Query("city"),
			"country":            c.Query("country"),
			"accommodation_type": c.Query("accommodation_type"),
			"has_private_rooms":  c.Query("has_private_rooms"),
		}

		rooms, err := s.db.GetRooms(c.Context(), filters)
		if err != nil {
			return c.Status(500).SendString("Ошибка получения списка комнат")
		}

		return c.JSON(rooms)
	})

	// Изображения комнат
	s.app.Post("/rooms/:id/images", func(c *fiber.Ctx) error {
		roomID, err := strconv.Atoi(c.Params("id"))
		if err != nil {
			return c.Status(400).SendString("Неверный ID комнаты")
		}

		form, err := c.MultipartForm()
		if err != nil {
			return c.Status(400).SendString("Ошибка получения файлов")
		}

		files := form.File["images"]
		isMain := len(files) > 0

		var uploadedImages []database.RoomImage
		for _, file := range files {
			if !strings.HasPrefix(file.Header.Get("Content-Type"), "image/") {
				return c.Status(400).SendString("Допустимы только изображения")
			}

			if file.Size > 5*1024*1024 {
				return c.Status(400).SendString("Размер файла не должен превышать 5MB")
			}

			fileName, err := processImage(file)
			if err != nil {
				return c.Status(500).SendString("Ошибка обработки изображения")
			}

			image := database.RoomImage{
				RoomID:      roomID,
				FilePath:    fileName,
				FileName:    file.Filename,
				FileSize:    int(file.Size),
				ContentType: file.Header.Get("Content-Type"),
				IsMain:      isMain,
			}

			imageID, err := s.db.AddRoomImage(c.Context(), roomID, image)
			if err != nil {
				return c.Status(500).SendString("Ошибка сохранения информации об изображении")
			}

			image.ID = imageID
			uploadedImages = append(uploadedImages, image)
			isMain = false
		}

		return c.JSON(uploadedImages)
	})

	s.app.Get("/rooms/:id/images", func(c *fiber.Ctx) error {
		images, err := s.db.GetRoomImages(c.Context(), c.Params("id"))
		if err != nil {
			return c.Status(500).SendString("Ошибка получения изображений")
		}
		return c.JSON(images)
	})

	s.app.Delete("/rooms/:roomId/images/:imageId", func(c *fiber.Ctx) error {
		filePath, err := s.db.DeleteRoomImage(c.Context(), c.Params("imageId"))
		if err != nil {
			return c.Status(404).SendString("Изображение не найдено")
		}

		os.Remove(filepath.Join("uploads", filePath))
		return c.SendString("Изображение удалено")
	})

	// Маршруты для кроватей
	s.app.Post("/rooms/:id/beds", func(c *fiber.Ctx) error {
		type BedRequest struct {
			BedNumber     string  `json:"bed_number"`
			PricePerNight float64 `json:"price_per_night"`
		}

		roomID, err := strconv.Atoi(c.Params("id"))
		if err != nil {
			return c.Status(400).SendString("Неверный ID комнаты")
		}

		var bedReq BedRequest
		if err := c.BodyParser(&bedReq); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}

		bedID, err := s.db.AddBed(c.Context(), roomID, bedReq.BedNumber, bedReq.PricePerNight)
		if err != nil {
			if err.Error() == "room not found" {
				return c.Status(404).SendString("Комната не найдена")
			}
			return c.Status(500).SendString("Ошибка добавления кровати")
		}

		return c.JSON(fiber.Map{
			"id":              bedID,
			"room_id":         roomID,
			"bed_number":      bedReq.BedNumber,
			"price_per_night": bedReq.PricePerNight,
			"is_available":    true,
		})
	})

	s.app.Get("/rooms/:id/available-beds", func(c *fiber.Ctx) error {
		startDate := c.Query("start_date")
		endDate := c.Query("end_date")

		if startDate == "" || endDate == "" {
			return c.Status(400).SendString("Необходимо указать даты")
		}

		beds, err := s.db.GetAvailableBeds(c.Context(), c.Params("id"), startDate, endDate)
		if err != nil {
			return c.Status(500).SendString("Ошибка получения списка кроватей")
		}

		return c.JSON(beds)
	})

	// Маршруты для бронирований
	s.app.Post("/bookings", func(c *fiber.Ctx) error {
		// Получаем сессию пользователя
		sessionToken := c.Cookies("session_token")
		if sessionToken == "" {
			return c.Status(401).SendString("Необходима авторизация")
		}
	
		sessionData, ok := s.auth.GetSession(sessionToken)
		if !ok {
			return c.Status(401).SendString("Необходима авторизация")
		}
	
		var booking database.BookingRequest
		if err := c.BodyParser(&booking); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}
	
		// Получаем id пользователя по email из сессии
		userId, err := s.db.GetUserIDByEmail(c.Context(), sessionData.Email)
		if err != nil {
			return c.Status(500).SendString("Ошибка получения данных пользователя")
		}
	
		// Устанавливаем ID пользователя из сессии
		booking.UserID = userId
	
		err = s.db.CreateBooking(c.Context(), booking)
		if err != nil {
			switch err.Error() {
			case "bed ID is required for bed booking":
				return c.Status(400).SendString("Для койко-места необходимо указать ID кровати")
			case "bed is not available":
				return c.Status(400).SendString("Койко-место недоступно")
			case "bed is already booked for these dates":
				return c.Status(400).SendString("Койко-место уже забронировано на эти даты")
			case "room is already booked for these dates":
				return c.Status(400).SendString("Помещение занято на указанные даты")
			case "check-out date must be after check-in date":
				return c.Status(400).SendString("Дата выезда должна быть позже даты заезда")
			default:
				return c.Status(500).SendString("Ошибка создания бронирования")
			}
		}
	
		return c.SendString("Бронирование создано успешно")
	})

	
	s.app.Get("/bookings", func(c *fiber.Ctx) error {
		bookings, err := s.db.GetAllBookings(c.Context())
		if err != nil {
			return c.Status(500).SendString("Ошибка получения списка бронирований")
		}
		return c.JSON(bookings)
	})

	s.app.Delete("/rooms/:roomId/bookings/:bookingId", func(c *fiber.Ctx) error {
		err := s.db.DeleteBooking(c.Context(), c.Params("bookingId"), "room")
		if err != nil {
			return c.Status(500).SendString("Ошибка удаления бронирования")
		}
		return c.SendString("Бронирование удалено")
	})

	s.app.Delete("/beds/:bedId/bookings/:bookingId", func(c *fiber.Ctx) error {
		err := s.db.DeleteBooking(c.Context(), c.Params("bookingId"), "bed")
		if err != nil {
			return c.Status(500).SendString("Ошибка удаления бронирования")
		}
		return c.SendString("Бронирование удалено")
	})

	// Статическая раздача изображений
	s.app.Static("/uploads", "./uploads")
}

func (s *Server) setupAuthRoutes() {
	s.app.Get("/auth/google", func(c *fiber.Ctx) error {
		url := s.auth.GetGoogleAuthURL()
		return c.Redirect(url)
	})

	s.app.Get("/auth/google/callback", func(c *fiber.Ctx) error {
		code := c.Query("code")
		if code == "" {
			return c.Status(400).SendString("Missing code")
		}

		sessionData, err := s.auth.HandleGoogleCallback(c.Context(), code)
		if err != nil {
			return c.Status(500).SendString("Authentication failed")
		}

		// Получаем или создаём пользователя
		userID, err := s.db.GetOrCreateGoogleUser(
			c.Context(),
			sessionData.Name,
			sessionData.Email,
			sessionData.GoogleID,   // Должно приходить из auth.SessionData
			sessionData.PictureURL, // Должно приходить из auth.SessionData
		)
		if err != nil {
			log.Printf("Error managing user: %v", err)
			return c.Status(500).SendString("Error managing user")
		}

		sessionToken := generateSessionToken()
		sessionData.UserID = userID // Добавляем ID пользователя в данные сессии
		s.auth.SaveSession(sessionToken, sessionData)

		c.Cookie(&fiber.Cookie{
			Name:     "session_token",
			Value:    sessionToken,
			Path:     "/",
			MaxAge:   3600 * 24,
			Secure:   true,
			HTTPOnly: true,
			SameSite: "Lax",
		})

		return c.Redirect(os.Getenv("FRONTEND_URL"))
	})

	s.app.Get("/auth/session", func(c *fiber.Ctx) error {
		sessionToken := c.Cookies("session_token")
		if sessionToken == "" {
			return c.JSON(fiber.Map{
				"authenticated": false,
			})
		}

		sessionData, ok := s.auth.GetSession(sessionToken)
		if !ok {
			return c.JSON(fiber.Map{
				"authenticated": false,
			})
		}

		return c.JSON(fiber.Map{
			"authenticated": true,
			"user": fiber.Map{
				"name":     sessionData.Name,
				"email":    sessionData.Email,
				"provider": sessionData.Provider,
			},
		})
	})

	s.app.Get("/auth/logout", func(c *fiber.Ctx) error {
		sessionToken := c.Cookies("session_token")
		if sessionToken != "" {
			s.auth.DeleteSession(sessionToken)
			c.Cookie(&fiber.Cookie{
				Name:     "session_token",
				Value:    "",
				Path:     "/",
				MaxAge:   -1,
				Secure:   true,
				HTTPOnly: true,
				SameSite: "Lax",
			})
		}
		return c.SendStatus(200)
	})
}

func NewServer() (*Server, error) {
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found")
	}

	db, err := database.New(os.Getenv("DATABASE_URL"))
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %v", err)
	}

	authManager := auth.NewAuthManager(
		os.Getenv("GOOGLE_CLIENT_ID"),
		os.Getenv("GOOGLE_CLIENT_SECRET"),
		os.Getenv("GOOGLE_OAUTH_REDIRECT_URL"),
	)

	app := fiber.New()

	// Настройка CORS
	app.Use(cors.New(cors.Config{
		AllowOrigins:     os.Getenv("FRONTEND_URL"),
		AllowMethods:     "GET,POST,DELETE,PUT,OPTIONS",
		AllowHeaders:     "Origin, Content-Type, Accept, Authorization",
		ExposeHeaders:    "Content-Length",
		AllowCredentials: true,
		MaxAge:           300,
	}))

	os.MkdirAll("./uploads", os.ModePerm)

	server := &Server{
		app:  app,
		db:   db,
		auth: authManager,
	}

	// Настройка маршрутов
	server.setupAuthRoutes()
	server.setupRoutes()

	return server, nil
}

func main() {
	server, err := NewServer()
	if err != nil {
		log.Fatalf("Failed to create server: %v", err)
	}

	port := os.Getenv("PORT")
	if port == "" {
		port = "3000"
	}

	log.Printf("Server running on port %s", port)
	log.Fatal(server.app.Listen(fmt.Sprintf(":%s", port)))
}


--- Содержимое файла: backend/Dockerfile ---

FROM golang:1.21
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN mkdir -p uploads
RUN go mod tidy
RUN CGO_ENABLED=0 GOOS=linux go build -o main .
EXPOSE 3000
CMD ["./main"]


--- Содержимое файла: backend/.env ---

DATABASE_URL=postgres://postgres:c9XWc7Cm@db:5432/hostel_db?sslmode=disable
CORS_ORIGINS=http://landhub.rs,https://landhub.rs


GOOGLE_CLIENT_ID=917315728307-au9ga5fl7o3bbid9nv7e4l92gut194pq.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
GOOGLE_OAUTH_REDIRECT_URL=https://landhub.rs/auth/google/callback
FRONTEND_URL=https://landhub.rs


--- Содержимое файла: backend/.env.local ---

DATABASE_URL=postgres://postgres:password@db:5432/hostel_db?sslmode=disable
CORS_ORIGINS=http://localhost:3001,http://localhost:3000



GOOGLE_CLIENT_ID=917315728307-au9ga5fl7o3bbid9nv7e4l92gut194pq.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
GOOGLE_OAUTH_REDIRECT_URL=http://localhost:3000/auth/google/callback
FRONTEND_URL=http://localhost:3001
PORT=3000


--- Содержимое файла: backend/.dockerignore ---

# backend/.dockerignore
uploads/

--- Содержимое файла: backend/auth/auth.go ---

package auth

import (
	"context"
	"sync"

	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
	oauth2v2 "google.golang.org/api/oauth2/v2"
)

type SessionData struct {
    Token      *oauth2.Token
    UserID     int    `json:"user_id"`
    Name       string `json:"name"`
    Email      string `json:"email"`
    GoogleID   string `json:"google_id"`
    PictureURL string `json:"picture_url"`
    Provider   string `json:"provider"`
}

type AuthManager struct {
	googleConfig *oauth2.Config
	sessions     sync.Map
}

func NewAuthManager(googleClientID, googleClientSecret, googleRedirectURL string) *AuthManager {
	googleConfig := &oauth2.Config{
		ClientID:     googleClientID,
		ClientSecret: googleClientSecret,
		RedirectURL:  googleRedirectURL,
		Scopes: []string{
			"https://www.googleapis.com/auth/userinfo.profile",
			"https://www.googleapis.com/auth/userinfo.email",
		},
		Endpoint: google.Endpoint,
	}

	return &AuthManager{
		googleConfig: googleConfig,
	}
}

func (am *AuthManager) GetGoogleAuthURL() string {
	return am.googleConfig.AuthCodeURL("state")
}

func (am *AuthManager) HandleGoogleCallback(ctx context.Context, code string) (*SessionData, error) {
    token, err := am.googleConfig.Exchange(ctx, code)
    if err != nil {
        return nil, err
    }

    oauth2Service, err := oauth2v2.New(am.googleConfig.Client(ctx, token))
    if err != nil {
        return nil, err
    }

    userInfo, err := oauth2Service.Userinfo.Get().Do()
    if err != nil {
        return nil, err
    }

    return &SessionData{
        Token:      token,
        Name:       userInfo.Name,
        Email:      userInfo.Email,
        GoogleID:   userInfo.Id,
        PictureURL: userInfo.Picture,
        Provider:   "google",
    }, nil
}

func (am *AuthManager) SaveSession(token string, data *SessionData) {
	am.sessions.Store(token, data)
}

func (am *AuthManager) GetSession(token string) (*SessionData, bool) {
	if value, ok := am.sessions.Load(token); ok {
		if sessionData, ok := value.(*SessionData); ok {
			return sessionData, true
		}
	}
	return nil, false
}

func (am *AuthManager) DeleteSession(token string) {
	am.sessions.Delete(token)
}

--- Содержимое файла: backend/database/db.go ---

package database

import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"
	"strconv"
	"github.com/jackc/pgx/v5/pgxpool"
)

type Database struct {
	pool *pgxpool.Pool
}

type Room struct {
	Name               string   `json:"name"`
	Capacity           int      `json:"capacity"`
	PricePerNight     *float64 `json:"price_per_night"`
	AddressStreet     string   `json:"address_street"`
	AddressCity       string   `json:"address_city"`
	AddressState      string   `json:"address_state"`
	AddressCountry    string   `json:"address_country"`
	AddressPostalCode string   `json:"address_postal_code"`
	AccommodationType string   `json:"accommodation_type"`
	IsShared          bool     `json:"is_shared"`
	TotalBeds         *int     `json:"total_beds"`
	AvailableBeds     *int     `json:"available_beds"`
	HasPrivateBathroom bool    `json:"has_private_bathroom"`
	Latitude          *float64 `json:"latitude"`
	Longitude         *float64 `json:"longitude"`
	FormattedAddress  string   `json:"formatted_address"`
}

type RoomImage struct {
	ID          int       `json:"id"`
	RoomID      int       `json:"room_id"`
	FilePath    string    `json:"file_path"`
	FileName    string    `json:"file_name"`
	FileSize    int       `json:"file_size"`
	ContentType string    `json:"content_type"`
	IsMain      bool      `json:"is_main"`
	CreatedAt   time.Time `json:"created_at"`
}

type Bed struct {
	ID            int     `json:"id"`
	RoomID        int     `json:"room_id"`
	BedNumber     string  `json:"bed_number"`
	IsAvailable   bool    `json:"is_available"`
	PricePerNight float64 `json:"price_per_night"`
}

type BedImage struct {
	ID          int       `json:"id"`
	BedID       int       `json:"bed_id"`
	FilePath    string    `json:"file_path"`
	FileName    string    `json:"file_name"`
	FileSize    int       `json:"file_size"`
	ContentType string    `json:"content_type"`
	CreatedAt   time.Time `json:"created_at"`
}

type BookingRequest struct {
	UserID    int    `json:"user_id"`
	RoomID    int    `json:"room_id"`
	BedID     *int   `json:"bed_id,omitempty"`
	StartDate string `json:"start_date"`
	EndDate   string `json:"end_date"`
}

type Booking struct {
	ID             int       `json:"id"`
	UserID         int       `json:"user_id"`
	RoomID         int       `json:"room_id"`
	BedID          *int      `json:"bed_id"`
	StartDate      time.Time `json:"start_date"`
	EndDate        time.Time `json:"end_date"`
	Status         string    `json:"status"`
	RoomName       string    `json:"room_name"`
	AccommodationType string `json:"type"`
	UserName       string    `json:"user_name"`
	UserEmail      string    `json:"user_email"`
	BookingType    string    `json:"booking_type"`
}
type User struct {
    ID         int    `json:"id"`
    Name       string `json:"name"`
    Email      string `json:"email"`
    GoogleID   string `json:"google_id"`
    PictureURL string `json:"picture_url"`
}

func (db *Database) GetOrCreateGoogleUser(ctx context.Context, name, email, googleID, pictureURL string) (int, error) {
    var userID int
    
    // Пробуем найти пользователя по google_id
    err := db.pool.QueryRow(ctx, `
        SELECT id FROM users WHERE google_id = $1
    `, googleID).Scan(&userID)

    if err == nil {
        // Пользователь найден, обновляем информацию
        _, err = db.pool.Exec(ctx, `
            UPDATE users 
            SET name = $1, email = $2, picture_url = $3
            WHERE id = $4
        `, name, email, pictureURL, userID)
        return userID, err
    }

    // Пользователь не найден, создаём нового
    err = db.pool.QueryRow(ctx, `
        INSERT INTO users (name, email, google_id, picture_url)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (email) DO UPDATE 
            SET google_id = $3, 
                picture_url = $4,
                name = $1
        RETURNING id
    `, name, email, googleID, pictureURL).Scan(&userID)

    return userID, err
}

func (db *Database) GetUserIDByEmail(ctx context.Context, email string) (int, error) {
    var userID int
    err := db.pool.QueryRow(ctx, "SELECT id FROM users WHERE email = $1", email).Scan(&userID)
    if err != nil {
        return 0, err
    }
    return userID, nil
}


func New(dbURL string) (*Database, error) {
	pool, err := pgxpool.New(context.Background(), dbURL)
	if err != nil {
		return nil, err
	}
	return &Database{pool: pool}, nil
}

func (db *Database) Close() {
	db.pool.Close()
}

// User methods
func (db *Database) AddUser(ctx context.Context, name, email string) error {
	_, err := db.pool.Exec(ctx, "INSERT INTO users (name, email) VALUES ($1, $2)", name, email)
	return err
}

// Room methods
func (db *Database) AddRoom(ctx context.Context, room Room) (int, error) {
	var roomID int
	totalBeds := 0
	availableBeds := 0
	
	if room.TotalBeds != nil {
		totalBeds = *room.TotalBeds
		if room.AvailableBeds != nil {
			availableBeds = *room.AvailableBeds
		} else {
			availableBeds = totalBeds
		}
	}

	err := db.pool.QueryRow(ctx, `
		INSERT INTO rooms (
			name, capacity, price_per_night,
			address_street, address_city, address_state,
			address_country, address_postal_code,
			accommodation_type, is_shared,
			total_beds, available_beds, has_private_bathroom,
			latitude, longitude, formatted_address
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
			$11, $12, $13, $14, $15, $16)
		RETURNING id
	`, room.Name, room.Capacity, room.PricePerNight,
		room.AddressStreet, room.AddressCity, room.AddressState,
		room.AddressCountry, room.AddressPostalCode,
		room.AccommodationType, room.IsShared,
		totalBeds, availableBeds, room.HasPrivateBathroom,
		room.Latitude, room.Longitude, room.FormattedAddress,
	).Scan(&roomID)

	return roomID, err
}

func (db *Database) DeleteRoom(ctx context.Context, id string) error {
	result, err := db.pool.Exec(ctx, "DELETE FROM rooms WHERE id=$1", id)
	if err != nil {
		return err
	}
	if result.RowsAffected() == 0 {
		return fmt.Errorf("room not found")
	}
	return nil
}

func (db *Database) GetRooms(ctx context.Context, filters map[string]string) ([]map[string]interface{}, error) {
	baseQuery := `
	WITH room_availability AS (
		SELECT 
			r.id,
			COALESCE(r.total_beds, 0) as total_beds,
			CASE 
				WHEN r.accommodation_type = 'bed' THEN 
					COALESCE(
						r.total_beds - COALESCE((
							SELECT COUNT(DISTINCT bb.bed_id)
							FROM beds b2
							LEFT JOIN bed_bookings bb ON b2.id = bb.bed_id
							WHERE b2.room_id = r.id
							AND bb.status = 'confirmed'
							AND bb.start_date <= $2
							AND bb.end_date >= $1
						), 0),
						r.total_beds
					)
				ELSE 
					CASE WHEN EXISTS (
						SELECT 1 FROM bookings b
						WHERE b.room_id = r.id
						AND b.status = 'confirmed'
						AND b.start_date <= $2
						AND b.end_date >= $1
					) THEN 0 ELSE 1 END
			END as available_count,
			CASE 
				WHEN r.accommodation_type = 'bed' THEN
					COALESCE(
						(SELECT MIN(b3.price_per_night) 
						 FROM beds b3 
						 WHERE b3.room_id = r.id 
						 AND b3.is_available = true
						 AND b3.id NOT IN (
							SELECT bb.bed_id
							FROM bed_bookings bb
							WHERE bb.status = 'confirmed'
							AND bb.start_date <= $2
							AND bb.end_date >= $1
						 )),
						r.price_per_night
					)
				ELSE r.price_per_night
			END as actual_price
		FROM rooms r
	)
	SELECT 
		r.id, 
		r.name, 
		r.capacity,
		r.latitude,
		r.longitude,
		ra.actual_price as price_per_night,
		r.address_street, 
		r.address_city, 
		r.address_state,
		r.address_country, 
		r.address_postal_code,
		r.accommodation_type, 
		r.is_shared,
		COALESCE(r.total_beds, 0) as total_beds,
		COALESCE(ra.available_count, 0) as available_beds,
		r.has_private_bathroom,
		r.created_at
	FROM rooms r
	JOIN room_availability ra ON r.id = ra.id
	WHERE 1=1
		AND (
			CASE 
				WHEN r.accommodation_type = 'bed' 
				THEN COALESCE(ra.available_count, 0) > 0 
				ELSE COALESCE(ra.available_count, 1) = 1
			END
		)`

	var conditions []string
	args := []interface{}{filters["start_date"], filters["end_date"]}
	paramCount := 2

	if accommodationType := filters["accommodation_type"]; accommodationType != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("r.accommodation_type = $%d", paramCount))
		args = append(args, accommodationType)

		if accommodationType == "room" && filters["has_private_rooms"] == "true" {
			conditions = append(conditions, "r.is_shared = false")
		}
	}

	if capacity := filters["capacity"]; capacity != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("r.capacity >= $%d", paramCount))
		args = append(args, capacity)
	}

	if minPrice := filters["min_price"]; minPrice != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("ra.actual_price >= $%d", paramCount))
		args = append(args, minPrice)
	}

	if maxPrice := filters["max_price"]; maxPrice != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("ra.actual_price <= $%d", paramCount))
		args = append(args, maxPrice)
	}

	if city := filters["city"]; city != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("r.address_city ILIKE $%d", paramCount))
		args = append(args, "%"+city+"%")
	}

	if country := filters["country"]; country != "" {
		paramCount++
		conditions = append(conditions, fmt.Sprintf("r.address_country ILIKE $%d", paramCount))
		args = append(args, "%"+country+"%")
	}

	if len(conditions) > 0 {
		baseQuery += " AND " + strings.Join(conditions, " AND ")
	}

	baseQuery += " ORDER BY ra.available_count DESC, ra.actual_price ASC, r.created_at DESC"

	rows, err := db.pool.Query(ctx, baseQuery, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var rooms []map[string]interface{}
	for rows.Next() {
		var id, capacity int
		var totalBeds, availableBeds int
		var name, addressStreet, addressCity, addressState,
			addressCountry, addressPostalCode, accommodationType string
		var latitude, longitude float64
		var pricePerNight float64
		var isShared, hasPrivateBathroom bool
		var createdAt time.Time

		if err := rows.Scan(
			&id, &name, &capacity, &latitude, &longitude, &pricePerNight,
			&addressStreet, &addressCity, &addressState,
			&addressCountry, &addressPostalCode,
			&accommodationType, &isShared,
			&totalBeds, &availableBeds,
			&hasPrivateBathroom,
			&createdAt,
		); err != nil {
			log.Printf("Ошибка сканирования строки: %v", err)
			continue
		}

		rooms = append(rooms, map[string]interface{}{
			"id":                   id,
			"name":                 name,
			"capacity":             capacity,
			"latitude":             latitude,
			"longitude":            longitude,
			"price_per_night":      pricePerNight,
			"address_street":       addressStreet,
			"address_city":         addressCity,
			"address_state":        addressState,
			"address_country":      addressCountry,
			"address_postal_code":  addressPostalCode,
			"accommodation_type":   accommodationType,
			"is_shared":           isShared,
			"total_beds":          totalBeds,
			"available_beds":      availableBeds,
			"has_private_bathroom": hasPrivateBathroom,
			"created_at":          createdAt.Format("2006-01-02 15:04:05"),
		})
	}

	return rooms, nil
}

// Room Image methods
func (db *Database) AddRoomImage(ctx context.Context, roomID int, image RoomImage) (int, error) {
	var imageID int
	err := db.pool.QueryRow(ctx, `
		INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main)
		VALUES ($1, $2, $3, $4, $5, $6)
		RETURNING id
	`, roomID, image.FilePath, image.FileName, image.FileSize, image.ContentType, image.IsMain).Scan(&imageID)
	return imageID, err
}

func (db *Database) GetRoomImages(ctx context.Context, roomID string) ([]RoomImage, error) {
	rows, err := db.pool.Query(ctx, `
		SELECT id, room_id, file_path, file_name, file_size, content_type, is_main, created_at
		FROM room_images
		WHERE room_id = $1
		ORDER BY is_main DESC, created_at DESC
	`, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var images []RoomImage
	for rows.Next() {
		var img RoomImage
		err := rows.Scan(
			&img.ID,
			&img.RoomID,
			&img.FilePath,
			&img.FileName,
			&img.FileSize,
			&img.ContentType,
			&img.IsMain,
			&img.CreatedAt,
		)
		if err != nil {
			log.Printf("Ошибка сканирования изображения: %v", err)
			continue
		}
		images = append(images, img)
	}
	return images, rows.Err()
}

func (db *Database) DeleteRoomImage(ctx context.Context, imageID string) (string, error) {
	var filePath string
	err := db.pool.QueryRow(ctx, "SELECT file_path FROM room_images WHERE id = $1", imageID).Scan(&filePath)
	if err != nil {
		return "", err
	}

	_, err = db.pool.Exec(ctx, "DELETE FROM room_images WHERE id = $1", imageID)
	if err != nil {
		return "", err
	}

	return filePath, nil
}

// Bed methods
func (db *Database) AddBed(ctx context.Context, roomID int, bedNumber string, pricePerNight float64) (int, error) {
	var bedID int
	// Проверяем, существует ли комната
	var roomExists bool
	err := db.pool.QueryRow(ctx, 
		"SELECT EXISTS(SELECT 1 FROM rooms WHERE id = $1)", 
		roomID).Scan(&roomExists)
	if err != nil || !roomExists {
		return 0, fmt.Errorf("room not found")
	}

	// Добавляем кровать
	err = db.pool.QueryRow(ctx, `
		INSERT INTO beds (room_id, bed_number, price_per_night, is_available) 
		VALUES ($1, $2, $3, true)
		RETURNING id`,
		roomID, bedNumber, pricePerNight).Scan(&bedID)

	return bedID, err
}

func (db *Database) GetAvailableBeds(ctx context.Context, roomID string, startDate, endDate string) ([]Bed, error) {
	query := `
		SELECT b.id, b.bed_number, b.price_per_night
		FROM beds b
		WHERE b.room_id = $1
		AND b.is_available = true
		AND NOT EXISTS (
			SELECT 1
			FROM bed_bookings bb
			WHERE bb.bed_id = b.id
			AND bb.status = 'confirmed'
			AND (
				(bb.start_date <= $3 AND bb.end_date >= $2)
			)
		)
		ORDER BY b.bed_number
	`

	rows, err := db.pool.Query(ctx, query, roomID, startDate, endDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var beds []Bed
	for rows.Next() {
		var bed Bed
		if err := rows.Scan(&bed.ID, &bed.BedNumber, &bed.PricePerNight); err != nil {
			continue
		}
		bed.RoomID, _ = strconv.Atoi(roomID)
		bed.IsAvailable = true
		beds = append(beds, bed)
	}

	// Обновляем количество доступных кроватей в комнате
	_, err = db.pool.Exec(ctx, `
		UPDATE rooms 
		SET available_beds = $1
		WHERE id = $2
	`, len(beds), roomID)

	return beds, rows.Err()
}

// Bed Image methods
func (db *Database) AddBedImage(ctx context.Context, bedID int, image BedImage) (int, error) {
	var imageID int
	err := db.pool.QueryRow(ctx, `
		INSERT INTO bed_images (bed_id, file_path, file_name, file_size, content_type)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id
	`, bedID, image.FilePath, image.FileName, image.FileSize, image.ContentType).Scan(&imageID)
	return imageID, err
}

func (db *Database) GetBedImages(ctx context.Context, bedID string) ([]BedImage, error) {
	rows, err := db.pool.Query(ctx, `
		SELECT id, bed_id, file_path, file_name, file_size, content_type, created_at
		FROM bed_images
		WHERE bed_id = $1
		ORDER BY created_at DESC
	`, bedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var images []BedImage
	for rows.Next() {
		var img BedImage
		err := rows.Scan(
			&img.ID,
			&img.BedID,
			&img.FilePath,
			&img.FileName,
			&img.FileSize,
			&img.ContentType,
			&img.CreatedAt,
		)
		if err != nil {
			continue
		}
		images = append(images, img)
	}
	return images, rows.Err()
}

// Booking methods
func (db *Database) CreateBooking(ctx context.Context, booking BookingRequest) error {
	tx, err := db.pool.Begin(ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(ctx)

	var userExists bool
	err = tx.QueryRow(ctx,
		"SELECT EXISTS(SELECT 1 FROM users WHERE id = $1)",
		booking.UserID).Scan(&userExists)
	if err != nil || !userExists {
		return fmt.Errorf("user not found")
	}

	var roomType string
	var isShared bool
	err = tx.QueryRow(ctx, `
		SELECT accommodation_type, is_shared 
		FROM rooms 
		WHERE id = $1`,
		booking.RoomID).Scan(&roomType, &isShared)
	if err != nil {
		return err
	}

	if booking.StartDate == booking.EndDate {
		return fmt.Errorf("check-out date must be after check-in date")
	}

	if roomType == "bed" {
		if booking.BedID == nil {
			return fmt.Errorf("bed ID is required for bed booking")
		}

		var isAvailable bool
		err = tx.QueryRow(ctx, `
			SELECT is_available 
			FROM beds 
			WHERE id = $1 AND room_id = $2`,
			*booking.BedID, booking.RoomID).Scan(&isAvailable)
		if err != nil || !isAvailable {
			return fmt.Errorf("bed is not available")
		}

		var conflictCount int
		err = tx.QueryRow(ctx, `
			SELECT COUNT(*) 
			FROM bed_bookings 
			WHERE bed_id = $1 
			AND status = 'confirmed'
			AND (
				(start_date <= $2 AND end_date >= $2) OR
				(start_date <= $3 AND end_date >= $3) OR
				(start_date >= $2 AND end_date <= $3)
			)`,
			*booking.BedID, booking.StartDate, booking.EndDate).Scan(&conflictCount)

		if err != nil || conflictCount > 0 {
			return fmt.Errorf("bed is already booked for these dates")
		}

		_, err = tx.Exec(ctx, `
			INSERT INTO bed_bookings (bed_id, user_id, start_date, end_date, status)
			VALUES ($1, $2, $3, $4, 'confirmed')`,
			*booking.BedID, booking.UserID, booking.StartDate, booking.EndDate)

		_, err = tx.Exec(ctx, `
			UPDATE rooms 
			SET available_beds = available_beds - 1
			WHERE id = $1`,
			booking.RoomID)
	} else {
		var count int
		err = tx.QueryRow(ctx, `
			SELECT COUNT(*) 
			FROM bookings 
			WHERE room_id = $1 
				AND start_date <= $3 
				AND end_date >= $2
				AND status = 'confirmed'`,
			booking.RoomID, booking.StartDate, booking.EndDate).Scan(&count)
		if err != nil || count > 0 {
			return fmt.Errorf("room is already booked for these dates")
		}

		_, err = tx.Exec(ctx, `
			INSERT INTO bookings (user_id, room_id, start_date, end_date, status)
			VALUES ($1, $2, $3, $4, 'confirmed')`,
			booking.UserID, booking.RoomID, booking.StartDate, booking.EndDate)
	}

	if err != nil {
		return err
	}

	return tx.Commit(ctx)
}

func (db *Database) GetAllBookings(ctx context.Context) ([]Booking, error) {
	roomBookingsQuery := `
		SELECT b.id, b.user_id, b.room_id, NULL as bed_id, 
			   b.start_date, b.end_date, b.status,
			   r.name as room_name, r.accommodation_type,
			   u.name as user_name, u.email as user_email
		FROM bookings b
		JOIN rooms r ON b.room_id = r.id
		JOIN users u ON b.user_id = u.id
	`
	bedBookingsQuery := `
		SELECT bb.id, bb.user_id, b.room_id, bb.bed_id,
			   bb.start_date, bb.end_date, bb.status,
			   r.name as room_name, r.accommodation_type,
			   u.name as user_name, u.email as user_email
		FROM bed_bookings bb
		JOIN beds b ON bb.bed_id = b.id
		JOIN rooms r ON b.room_id = r.id
		JOIN users u ON bb.user_id = u.id
	`

	roomRows, err := db.pool.Query(ctx, roomBookingsQuery)
	if err != nil {
		return nil, err
	}
	defer roomRows.Close()

	bedRows, err := db.pool.Query(ctx, bedBookingsQuery)
	if err != nil {
		return nil, err
	}
	defer bedRows.Close()

	var bookings []Booking

	// Process room bookings
	for roomRows.Next() {
		var booking Booking
		err := roomRows.Scan(
			&booking.ID, &booking.UserID, &booking.RoomID, &booking.BedID,
			&booking.StartDate, &booking.EndDate, &booking.Status,
			&booking.RoomName, &booking.AccommodationType,
			&booking.UserName, &booking.UserEmail,
		)
		if err != nil {
			continue
		}
		booking.BookingType = "room"
		bookings = append(bookings, booking)
	}

	// Process bed bookings
	for bedRows.Next() {
		var booking Booking
		err := bedRows.Scan(
			&booking.ID, &booking.UserID, &booking.RoomID, &booking.BedID,
			&booking.StartDate, &booking.EndDate, &booking.Status,
			&booking.RoomName, &booking.AccommodationType,
			&booking.UserName, &booking.UserEmail,
		)
		if err != nil {
			continue
		}
		booking.BookingType = "bed"
		bookings = append(bookings, booking)
	}

	return bookings, nil
}

func (db *Database) DeleteBooking(ctx context.Context, bookingID, bookingType string) error {
	var query string
	if bookingType == "room" {
		query = "DELETE FROM bookings WHERE id = $1"
	} else if bookingType == "bed" {
		query = "DELETE FROM bed_bookings WHERE id = $1"
	} else {
		return fmt.Errorf("invalid booking type")
	}

	_, err := db.pool.Exec(ctx, query, bookingID)
	return err
}

--- Содержимое файла: backend/migrations/0004_update_constraints.down.sql ---


-- Remove the NOT NULL constraint.
ALTER TABLE bookings
ALTER COLUMN user_id DROP NOT NULL,
ALTER COLUMN room_id DROP NOT NULL;

-- Drop the added indexes.
DROP INDEX IF EXISTS idx_bookings_user_id;
DROP INDEX IF EXISTS idx_bookings_room_id;


--- Содержимое файла: backend/migrations/0001_create_tables.up.sql ---

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE rooms (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    capacity INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE bookings (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- Добавить ограничение на длину email
ALTER TABLE users
    ADD CONSTRAINT valid_email 
    CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

-- Добавить ограничение на минимальную длину имени
ALTER TABLE users
    ADD CONSTRAINT valid_name 
    CHECK (length(name) >= 2);

--- Содержимое файла: backend/migrations/0018_add_bed_images.up.sql ---

CREATE TABLE bed_images (
    id SERIAL PRIMARY KEY,
    bed_id INT NOT NULL REFERENCES beds(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_bed_images_bed_id ON bed_images(bed_id);

--- Содержимое файла: backend/migrations/0016_fix_bed_availability.down.sql ---

DROP FUNCTION IF EXISTS get_beds_availability;
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds;

--- Содержимое файла: backend/migrations/0002_add_price_per_night.up.sql ---

ALTER TABLE rooms 
    ADD COLUMN price_per_night NUMERIC(10, 2) NOT NULL DEFAULT 0 
    CHECK (price_per_night >= 0);
CREATE INDEX idx_users_email ON users(email);

-- Добавить составной индекс для фильтрации комнат
CREATE INDEX idx_rooms_capacity_price ON rooms(capacity, price_per_night);

--- Содержимое файла: backend/migrations/0015_fix_available_beds.up.sql ---

-- Удаляем старый триггер и функцию
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds();

-- Создаем улучшенную функцию обновления доступных мест
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    -- Обновляем количество доступных мест для комнаты, связанной с бронированием
    WITH bed_count AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        LEFT JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE 
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = r.total_beds - COALESCE(bc.booked_beds, 0)
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем новый триггер
CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();

-- Создаем функцию для получения количества доступных мест на конкретные даты
CREATE OR REPLACE FUNCTION get_available_beds(
    room_id_param INTEGER,
    start_date_param DATE,
    end_date_param DATE
)
RETURNS INTEGER AS $$
DECLARE
    total_beds INTEGER;
    booked_beds INTEGER;
BEGIN
    -- Получаем общее количество кроватей
    SELECT total_beds INTO total_beds
    FROM rooms
    WHERE id = room_id_param;

    -- Считаем количество забронированных кроватей на указанные даты
    SELECT COUNT(DISTINCT bb.bed_id) INTO booked_beds
    FROM bed_bookings bb
    JOIN beds b ON bb.bed_id = b.id
    WHERE b.room_id = room_id_param
    AND bb.status = 'confirmed'
    AND bb.start_date <= end_date_param
    AND bb.end_date >= start_date_param;

    -- Возвращаем разницу
    RETURN total_beds - COALESCE(booked_beds, 0);
END;
$$ LANGUAGE plpgsql;

-- Функция инициализации доступных мест
CREATE OR REPLACE FUNCTION initialize_available_beds()
RETURNS void AS $$
BEGIN
    WITH bed_count AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        LEFT JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE 
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = r.total_beds - COALESCE(bc.booked_beds, 0)
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';
END;
$$ LANGUAGE plpgsql;

-- Выполняем начальную инициализацию
SELECT initialize_available_beds();

--- Содержимое файла: backend/migrations/0006_add_room_address.down.sql ---

-- 0006_add_room_address.down.sql
DROP INDEX IF EXISTS idx_rooms_city;
DROP INDEX IF EXISTS idx_rooms_country;

ALTER TABLE rooms
    DROP COLUMN address_street,
    DROP COLUMN address_city,
    DROP COLUMN address_state,
    DROP COLUMN address_country,
    DROP COLUMN address_postal_code;

--- Содержимое файла: backend/migrations/0021_add_google_id_to_users.up.sql ---

ALTER TABLE users 
ADD COLUMN google_id VARCHAR(255) UNIQUE,
ADD COLUMN picture_url TEXT;

--- Содержимое файла: backend/migrations/0021_add_google_id_to_users.down.sql ---

ALTER TABLE users 
DROP COLUMN google_id,
DROP COLUMN picture_url;

--- Содержимое файла: backend/migrations/0014_add_beds_trigger.down.sql ---

-- Удаляем триггер
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;

-- Удаляем функцию
DROP FUNCTION IF EXISTS update_available_beds();

--- Содержимое файла: backend/migrations/0014_add_beds_trigger.up.sql ---

-- Создаем функцию для подсчета доступных кроватей
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
            AND (
                (start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE)
            )
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем триггер для таблицы bed_bookings
CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();

--- Содержимое файла: backend/migrations/0005_add_status_and_indexes.down.sql ---

-- 0005_add_status_and_indexes.down.sql
DROP INDEX IF EXISTS idx_bookings_status;
DROP INDEX IF EXISTS idx_bookings_dates;
ALTER TABLE bookings DROP COLUMN status;

--- Содержимое файла: backend/migrations/0017_add_location_fields.up.sql ---

-- Добавляем поля для координат и форматированного адреса
ALTER TABLE rooms
    ADD COLUMN latitude DECIMAL(10, 8),
    ADD COLUMN longitude DECIMAL(11, 8),
    ADD COLUMN formatted_address TEXT;

-- Индекс для географического поиска
CREATE INDEX idx_rooms_location ON rooms(latitude, longitude);

-- Функция для валидации координат
CREATE OR REPLACE FUNCTION validate_coordinates()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.latitude IS NOT NULL AND (NEW.latitude < -90 OR NEW.latitude > 90) THEN
        RAISE EXCEPTION 'Широта должна быть между -90 и 90';
    END IF;
    IF NEW.longitude IS NOT NULL AND (NEW.longitude < -180 OR NEW.longitude > 180) THEN
        RAISE EXCEPTION 'Долгота должна быть между -180 и 180';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Триггер для валидации координат
CREATE TRIGGER validate_coordinates_trigger
    BEFORE INSERT OR UPDATE ON rooms
    FOR EACH ROW
    EXECUTE FUNCTION validate_coordinates();

--- Содержимое файла: backend/migrations/0007_add_room_images.down.sql ---

-- 0007_add_room_images.down.sql
DROP TABLE IF EXISTS room_images;

--- Содержимое файла: backend/migrations/0011_extend_room_types.up.sql ---

ALTER TABLE rooms
    ADD COLUMN accommodation_type VARCHAR(50) NOT NULL DEFAULT 'room'
    CHECK (accommodation_type IN ('bed', 'room', 'apartment')),
    ADD COLUMN is_shared BOOLEAN NOT NULL DEFAULT false,
    ADD COLUMN total_beds INT,
    ADD COLUMN available_beds INT,
    ADD COLUMN has_private_bathroom BOOLEAN NOT NULL DEFAULT true;

CREATE TABLE beds (
    id SERIAL PRIMARY KEY,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    bed_number INT NOT NULL,
    is_available BOOLEAN NOT NULL DEFAULT true,
    price_per_night DECIMAL(10, 2) NOT NULL CHECK (price_per_night >= 0),
    UNIQUE(room_id, bed_number)
);

CREATE TABLE bed_bookings (
    id SERIAL PRIMARY KEY,
    bed_id INT REFERENCES beds(id) ON DELETE CASCADE,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL CHECK (end_date > start_date),
    status VARCHAR(20) NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--- Содержимое файла: backend/migrations/0020_add_demo_data.down.sql ---

-- Удаляем демо данные
DELETE FROM bed_images;
DELETE FROM beds;
DELETE FROM room_images;
DELETE FROM rooms;
DELETE FROM users WHERE email = 'demo@example.com';

-- Восстанавливаем старое ограничение
DROP INDEX IF EXISTS unique_main_image_per_room;
ALTER TABLE room_images ADD CONSTRAINT unique_main_image_per_room UNIQUE (room_id, is_main);

--- Содержимое файла: backend/migrations/0005_add_status_and_indexes.up.sql ---

-- 0005_add_status_and_indexes.up.sql
ALTER TABLE bookings 
    ADD COLUMN status VARCHAR(20) NOT NULL 
    DEFAULT 'pending' 
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

CREATE INDEX idx_bookings_status ON bookings(status);
CREATE INDEX idx_bookings_dates ON bookings(start_date, end_date);

--- Содержимое файла: backend/migrations/0018_add_bed_images.down.sql ---

DROP TABLE IF EXISTS bed_images;


--- Содержимое файла: backend/migrations/0013_update_bed_bookings.down.sql ---

-- 0013_update_bed_bookings.down.sql
DROP INDEX IF EXISTS idx_bed_bookings_dates_status;
ALTER TABLE bed_bookings DROP COLUMN IF EXISTS status;

--- Содержимое файла: backend/migrations/0012_add_accommodation_types.down.sql ---

-- 0012_add_accommodation_types.down.sql
ALTER TABLE bookings DROP COLUMN IF EXISTS status;

--- Содержимое файла: backend/migrations/0004_update_constraints.up.sql ---


-- Add NOT NULL constraint to ensure data integrity.
ALTER TABLE bookings
ALTER COLUMN user_id SET NOT NULL,
ALTER COLUMN room_id SET NOT NULL;

-- Add an index to optimize queries on bookings table.
CREATE INDEX idx_bookings_user_id ON bookings(user_id);
CREATE INDEX idx_bookings_room_id ON bookings(room_id);


--- Содержимое файла: backend/migrations/0019_update_bed_availability_trigger.down.sql ---

CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms r
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--- Содержимое файла: backend/migrations/0012_add_accommodation_types.up.sql ---

-- 0012_add_accommodation_types.up.sql
ALTER TABLE bookings
    ADD COLUMN IF NOT EXISTS status VARCHAR(20) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

--- Содержимое файла: backend/migrations/0013_update_bed_bookings.up.sql ---

-- 0013_update_bed_bookings.up.sql
ALTER TABLE bed_bookings
ADD COLUMN IF NOT EXISTS status VARCHAR(20) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

-- Создаем индекс для оптимизации поиска
CREATE INDEX IF NOT EXISTS idx_bed_bookings_dates_status 
ON bed_bookings(start_date, end_date, status);

--- Содержимое файла: backend/migrations/0003_add_constraints_and_indexes.down.sql ---


-- Remove constraints and indexes added in the up migration
ALTER TABLE bookings DROP CONSTRAINT valid_date_range;

DROP INDEX IF EXISTS idx_rooms_price;
DROP INDEX IF EXISTS idx_bookings_room_date;


--- Содержимое файла: backend/migrations/0017_add_location_fields.down.sql ---

-- Удаляем триггер и функцию
DROP TRIGGER IF EXISTS validate_coordinates_trigger ON rooms;
DROP FUNCTION IF EXISTS validate_coordinates;

-- Удаляем индекс
DROP INDEX IF EXISTS idx_rooms_location;

-- Удаляем колонки
ALTER TABLE rooms
    DROP COLUMN IF EXISTS latitude,
    DROP COLUMN IF EXISTS longitude,
    DROP COLUMN IF EXISTS formatted_address;

--- Содержимое файла: backend/migrations/0001_create_tables.down.sql ---

DROP TABLE IF EXISTS bookings CASCADE;
DROP TABLE IF EXISTS rooms CASCADE;
DROP TABLE IF EXISTS users CASCADE;


--- Содержимое файла: backend/migrations/0007_add_room_images.up.sql ---

-- 0007_add_room_images.up.sql
CREATE TABLE room_images (
    id SERIAL PRIMARY KEY,
    room_id INT NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    is_main BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_main_image_per_room UNIQUE (room_id, is_main) 
        DEFERRABLE INITIALLY DEFERRED
);

CREATE INDEX idx_room_images_room_id ON room_images(room_id);

--- Содержимое файла: backend/migrations/0015_fix_available_beds.down.sql ---

-- Удаляем созданные функции и триггеры
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds();
DROP FUNCTION IF EXISTS get_available_beds(INTEGER, DATE, DATE);
DROP FUNCTION IF EXISTS initialize_available_beds();

-- Возвращаем простой триггер для обновления available_beds
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
            AND (
                (start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE)
            )
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();

--- Содержимое файла: backend/migrations/0011_extend_room_types.down.sql ---

-- 0011_extend_room_types.down.sql
DROP TABLE IF EXISTS bed_bookings;
DROP TABLE IF EXISTS beds;
ALTER TABLE rooms
    DROP COLUMN accommodation_type,
    DROP COLUMN is_shared,
    DROP COLUMN total_beds,
    DROP COLUMN available_beds,
    DROP COLUMN has_private_bathroom;

--- Содержимое файла: backend/migrations/0002_add_price_per_night.down.sql ---

ALTER TABLE rooms DROP COLUMN price_per_night;

--- Содержимое файла: backend/migrations/0016_fix_bed_availability.up.sql ---

-- Название файла: backend/migrations/0016_fix_bed_availability.up.sql

-- Удаляем старую версию функции если она существует
DROP FUNCTION IF EXISTS update_available_beds CASCADE;

-- Создаем новую функцию
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    WITH bed_count AS (
        SELECT 
            b.room_id,
            COUNT(DISTINCT b.id) as total_beds,
            COUNT(DISTINCT CASE 
                WHEN NOT EXISTS (
                    SELECT 1 
                    FROM bed_bookings bb 
                    WHERE bb.bed_id = b.id 
                    AND bb.status = 'confirmed'
                    AND (
                        (bb.start_date <= CURRENT_DATE AND bb.end_date >= CURRENT_DATE) OR
                        (bb.start_date >= CURRENT_DATE AND bb.start_date <= CURRENT_DATE)
                    )
                ) THEN b.id 
            END) as available_beds
        FROM beds b
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET 
        total_beds = bc.total_beds,
        available_beds = bc.available_beds
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Пересоздаем триггер
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
CREATE TRIGGER bed_bookings_update_trigger
    AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
    FOR EACH ROW
    EXECUTE FUNCTION update_available_beds();

-- Создаем функцию для получения количества доступных мест на определенные даты
CREATE OR REPLACE FUNCTION get_beds_availability(
    p_room_id INTEGER,
    p_start_date DATE,
    p_end_date DATE
) RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT COUNT(DISTINCT b.id)
        FROM beds b
        WHERE b.room_id = p_room_id
        AND b.is_available = true
        AND NOT EXISTS (
            SELECT 1
            FROM bed_bookings bb
            WHERE bb.bed_id = b.id
            AND bb.status = 'confirmed'
            AND (
                (bb.start_date <= p_end_date AND bb.end_date >= p_start_date) OR
                (bb.start_date >= p_start_date AND bb.start_date <= p_end_date)
            )
        )
    );
END;
$$ LANGUAGE plpgsql;

--- Содержимое файла: backend/migrations/0006_add_room_address.up.sql ---

-- 0006_add_room_address.up.sql
ALTER TABLE rooms
    ADD COLUMN address_street VARCHAR(255) NOT NULL DEFAULT '',
    ADD COLUMN address_city VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_state VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_country VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_postal_code VARCHAR(20) NOT NULL DEFAULT '';

CREATE INDEX idx_rooms_city ON rooms(address_city);
CREATE INDEX idx_rooms_country ON rooms(address_country);

--- Содержимое файла: backend/migrations/0020_add_demo_data.up.sql ---

-- backend/migrations/0020_add_demo_data.up.sql

-- Сначала фиксим ограничение для изображений
ALTER TABLE room_images DROP CONSTRAINT IF EXISTS unique_main_image_per_room;
CREATE UNIQUE INDEX unique_main_image_per_room ON room_images (room_id) WHERE is_main = true;

-- Очищаем существующие данные
TRUNCATE bed_images, beds, room_images, rooms, users CASCADE;

-- Сбрасываем последовательности
ALTER SEQUENCE rooms_id_seq RESTART WITH 1;
ALTER SEQUENCE beds_id_seq RESTART WITH 1;
ALTER SEQUENCE room_images_id_seq RESTART WITH 1;
ALTER SEQUENCE bed_images_id_seq RESTART WITH 1;
ALTER SEQUENCE users_id_seq RESTART WITH 1;

-- Создаем тестового пользователя
INSERT INTO users (name, email) VALUES
('Demo User', 'demo@example.com');

-- Создаем демонстрационные объекты

-- 1. Апартаменты в центре
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Уютные апартаменты в центре', 4, 80,
    'Dunavska 35', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'apartment', false, true,
    45.255421, 19.845241,
    'Dunavska 35, Novi Sad, Serbia'
);

-- Добавляем изображения для первых апартаментов
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '1.jpg', 'apartment1.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '2.jpg', 'apartment2.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '3.jpg', 'apartment3.jpg', 1024, 'image/jpeg', false);

-- 2. Апартаменты возле парка
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Просторные апартаменты у парка', 6, 120,
    'Futoška 12', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'apartment', false, true,
    45.249877, 19.833657,
    'Futoška 12, Novi Sad, Serbia'
);

-- Добавляем изображения для вторых апартаментов
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '4.jpg', 'apartment4.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '5.jpg', 'apartment5.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '6.jpg', 'apartment6.jpg', 1024, 'image/jpeg', false);

-- 3. Приватная комната в историческом центре
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Уютная комната в историческом центре', 2, 35,
    'Zmaj Jovina 4', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'room', false, true,
    45.254663, 19.844966,
    'Zmaj Jovina 4, Novi Sad, Serbia'
);

-- Добавляем изображения для первой приватной комнаты
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '7.jpg', 'room1.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '8.jpg', 'room2.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '1.jpg', 'room3.jpg', 1024, 'image/jpeg', false);

-- 4. Приватная комната возле набережной
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Комната с видом на Дунай', 2, 40,
    'Beogradski kej 31', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'room', false, true,
    45.256893, 19.861559,
    'Beogradski kej 31, Novi Sad, Serbia'
);

-- Добавляем изображения для второй приватной комнаты
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '2.jpg', 'room4.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '3.jpg', 'room5.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '4.jpg', 'room6.jpg', 1024, 'image/jpeg', false);

-- 5. Хостел в центре (койко-места)
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, total_beds, available_beds, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Центральный хостел', 6, 12,
    'Miletićeva 15', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'bed', true, 6, 6, true,
    45.252558, 19.842895,
    'Miletićeva 15, Novi Sad, Serbia'
);

-- Добавляем изображения для первого хостела
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '5.jpg', 'hostel1.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '6.jpg', 'hostel2.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '7.jpg', 'hostel3.jpg', 1024, 'image/jpeg', false);

-- Добавляем кровати для первого хостела
INSERT INTO beds (room_id, bed_number, price_per_night, is_available) VALUES
((SELECT MAX(id) FROM rooms), 11, 12, true),
((SELECT MAX(id) FROM rooms), 12, 12, true),
((SELECT MAX(id) FROM rooms), 21, 12, true),
((SELECT MAX(id) FROM rooms), 22, 12, true),
((SELECT MAX(id) FROM rooms), 31, 12, true),
((SELECT MAX(id) FROM rooms), 32, 12, true);

-- Добавляем изображения для кроватей первого хостела
INSERT INTO bed_images (bed_id, file_path, file_name, file_size, content_type) VALUES
((SELECT MAX(id) FROM beds), '8.jpg', 'bed1.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) FROM beds), '1.jpg', 'bed2.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 1 FROM beds), '2.jpg', 'bed3.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 2 FROM beds), '3.jpg', 'bed4.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 3 FROM beds), '4.jpg', 'bed5.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 4 FROM beds), '5.jpg', 'bed6.jpg', 1024, 'image/jpeg');

-- 6. Хостел возле вокзала (койко-места)
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, total_beds, available_beds, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Хостел у вокзала', 4, 10,
    'Bulevar Jaše Tomića 5', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'bed', true, 4, 4, true,
    45.260721, 19.831572,
    'Bulevar Jaše Tomića 5, Novi Sad, Serbia'
);

-- Добавляем изображения для второго хостела
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '6.jpg', 'hostel4.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '7.jpg', 'hostel5.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '8.jpg', 'hostel6.jpg', 1024, 'image/jpeg', false);

-- Добавляем кровати для второго хостела
INSERT INTO beds (room_id, bed_number, price_per_night, is_available) VALUES
((SELECT MAX(id) FROM rooms), 1, 10, true),
((SELECT MAX(id) FROM rooms), 2, 10, true),
((SELECT MAX(id) FROM rooms), 3, 10, true),
((SELECT MAX(id) FROM rooms), 4, 10, true);

-- Добавляем изображения для кроватей второго хостела
INSERT INTO bed_images (bed_id, file_path, file_name, file_size, content_type) VALUES
((SELECT MAX(id) FROM beds), '1.jpg', 'bed7.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 1 FROM beds), '2.jpg', 'bed8.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 2 FROM beds), '3.jpg', 'bed9.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 3 FROM beds), '4.jpg', 'bed10.jpg', 1024, 'image/jpeg');



--- Содержимое файла: backend/migrations/0003_add_constraints_and_indexes.up.sql ---


-- Add additional constraints and indexes to fix issues
ALTER TABLE bookings
    ADD CONSTRAINT valid_date_range 
    CHECK (start_date < end_date AND start_date >= CURRENT_DATE);

-- Indexes to optimize queries
CREATE INDEX idx_rooms_price ON rooms (price_per_night);
CREATE INDEX idx_bookings_room_date ON bookings (room_id, start_date, end_date);


--- Содержимое файла: backend/migrations/0019_update_bed_availability_trigger.up.sql ---

-- Обновляем функцию подсчета доступных мест
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    -- Обновляем количество доступных мест для комнаты с учетом текущих броней
    WITH current_bookings AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = COALESCE(r.total_beds, 0) - COALESCE(cb.booked_beds, 0)
    FROM current_bookings cb
    WHERE r.id = cb.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--- Содержимое файла: deploy/docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

  backend:
    build:
      context: ../backend
    ports:
      - "3000:3000"
    env_file:
      - ../backend/.env
    depends_on:
      - db
    command: [ "go", "run", "main.go" ]
    networks:
      - hostel_network

  frontend:
    build:
      context: ../frontend/hostel-frontend
    ports:
      - "3001:3000"
    environment:
      - REACT_APP_API_URL=https://landhub.rs/api
    networks:
      - hostel_network

volumes:
  db_data:


networks:
  hostel_network:
    driver: bridge


--- Содержимое файла: frontend/hostel-frontend/public/bed-marker.svg ---

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32">
  <path fill="#1976d2" d="M12 0C7.58 0 4 3.58 4 8c0 5.25 8 13 8 13s8-7.75 8-13c0-4.42-3.58-8-8-8zm0 2c3.31 0 6 2.69 6 6 0 3.37-4.77 8.93-6 10.46C10.77 16.93 6 11.37 6 8c0-3.31 2.69-6 6-6z"/>
  <path fill="#1976d2" d="M12 4c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/>
  <path fill="white" d="M9 7h6v2H9z"/>
</svg>


--- Содержимое файла: frontend/hostel-frontend/public/logo512.png ---

--- Ошибка чтения файла: frontend/hostel-frontend/public/logo512.png ('utf-8' codec can't decode byte 0x89 in position 0: invalid start byte) ---

--- Содержимое файла: frontend/hostel-frontend/public/index.html ---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>


--- Содержимое файла: frontend/hostel-frontend/public/hotel-marker.svg ---

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32">
  <path fill="#4caf50" d="M12 0C7.58 0 4 3.58 4 8c0 5.25 8 13 8 13s8-7.75 8-13c0-4.42-3.58-8-8-8zm0 2c3.31 0 6 2.69 6 6 0 3.37-4.77 8.93-6 10.46C10.77 16.93 6 11.37 6 8c0-3.31 2.69-6 6-6z"/>
  <path fill="#4caf50" d="M12 4c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/>
  <path fill="white" d="M9 6h6v3H9z"/>
</svg>

--- Содержимое файла: frontend/hostel-frontend/public/favicon.ico ---

--- Ошибка чтения файла: frontend/hostel-frontend/public/favicon.ico ('utf-8' codec can't decode byte 0xe3 in position 14: invalid continuation byte) ---

--- Содержимое файла: frontend/hostel-frontend/public/logo192.png ---

--- Ошибка чтения файла: frontend/hostel-frontend/public/logo192.png ('utf-8' codec can't decode byte 0x89 in position 0: invalid start byte) ---

--- Содержимое файла: frontend/hostel-frontend/public/manifest.json ---

{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}


--- Содержимое файла: frontend/hostel-frontend/public/robots.txt ---

# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:


--- Содержимое файла: frontend/hostel-frontend/src/index.js ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { ThemeProvider } from "@mui/material/styles";
import { CssBaseline } from '@mui/material';
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  // Можно добавить кастомные настройки темы
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <App />
    </ThemeProvider>
  </React.StrictMode>
);

reportWebVitals();

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


--- Содержимое файла: frontend/hostel-frontend/src/logo.svg ---

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>

--- Содержимое файла: frontend/hostel-frontend/src/App.js ---

import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { AuthProvider } from "./contexts/AuthContext";
import Layout from "./components/Layout";
import HomePage from "./pages/HomePage";
import AddRoomPage from "./pages/AddRoomPage";
import AddUserPage from "./pages/AddUserPage";
import BookingsListPage from "./pages/BookingsListPage";
import AdminPanelPage from "./pages/AdminPanelPage";

function App() {
  return (
    <AuthProvider>
      <Router>
        <Layout>
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/bookings" element={<BookingsListPage />} />
            <Route path="/add-room" element={<AddRoomPage />} />
            <Route path="/add-user" element={<AddUserPage />} />
            <Route path="/admin" element={<AdminPanelPage />} />
          </Routes>
        </Layout>
      </Router>
    </AuthProvider>
  );
}

export default App;

--- Содержимое файла: frontend/hostel-frontend/src/index.css ---

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


--- Содержимое файла: frontend/hostel-frontend/src/setupTests.js ---

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


--- Содержимое файла: frontend/hostel-frontend/src/App.test.js ---

import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


--- Содержимое файла: frontend/hostel-frontend/src/reportWebVitals.js ---

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


--- Содержимое файла: frontend/hostel-frontend/src/App.css ---

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


--- Содержимое файла: frontend/hostel-frontend/src/components/MapView.js ---

import React, { useState, useCallback } from 'react';
import { GoogleMap, Marker, InfoWindow } from '@react-google-maps/api';
import {
    Card,
    CardContent,
    Typography,
    Box,
    Button,
    Chip,
    CardMedia,
} from '@mui/material';
import {
    SingleBed as SingleBedIcon,
    Hotel as HotelIcon,
    Apartment as ApartmentIcon,
    PhotoLibrary as PhotoLibraryIcon,
    MyLocation as MyLocationIcon,
} from '@mui/icons-material';

const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;

const mapContainerStyle = {
    width: '100%',
    height: '700px'
};

const defaultCenter = {
    lat: 45.2671, // Нови-Сад
    lng: 19.8335
};

const MapView = ({ rooms, onRoomSelect, onOpenGallery }) => {
    const [map, setMap] = useState(null);
    const [selectedRoom, setSelectedRoom] = useState(null);

    // Выносим опции карты в отдельную функцию для предотвращения проблем с window.google
    const getMapOptions = useCallback(() => ({
        scrollwheel: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
            style: 'DEFAULT', // Убираем прямую ссылку на google.maps
            mapTypeIds: ["roadmap", "satellite", "hybrid"]
        },
        styles: [
            {
                featureType: "poi",
                elementType: "labels",
                stylers: [{ visibility: "off" }]
            }
        ],
        fullscreenControl: true,
        streetViewControl: false,
        zoomControl: true,
    }), []);

    const onMapLoad = useCallback((map) => {
        setMap(map);
        console.log('Map loaded, rooms:', rooms); // Отладка
        if (rooms?.length > 0) {
            const bounds = new window.google.maps.LatLngBounds();
            let hasValidCoords = false;

            rooms.forEach(room => {
                if (room.latitude && room.longitude) {
                    const lat = parseFloat(room.latitude);
                    const lng = parseFloat(room.longitude);

                    if (!isNaN(lat) && !isNaN(lng)) {
                        bounds.extend({ lat, lng });
                        hasValidCoords = true;
                        console.log(`Added to bounds: ${room.name}, lat: ${lat}, lng: ${lng}`); // Отладка
                    }
                }
            });

            if (hasValidCoords) {
                map.fitBounds(bounds);
            }
        }
    }, [rooms]);

    const handleMyLocation = () => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const pos = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };
                    map?.panTo(pos);
                    map?.setZoom(15);
                },
                (error) => {
                    console.error("Error getting location:", error);
                    alert("Не удалось получить местоположение");
                }
            );
        } else {
            alert("Геолокация не поддерживается вашим браузером");
        }
    };

    const InfoWindowContent = ({ room }) => {
        const hasImages = room.images && room.images.length > 0;
        const mainImage = hasImages ? room.images.find(img => img.is_main) || room.images[0] : null;

        return (
            <Card sx={{ width: 300, border: 'none', boxShadow: 'none' }}>
                {mainImage && (
                    <Box
                        sx={{
                            position: 'relative',
                            cursor: 'pointer',
                            '&:hover': {
                                '& .overlay': {
                                    opacity: 1
                                }
                            }
                        }}
                        onClick={(e) => {
                            e.stopPropagation();
                            onOpenGallery(room);
                        }}
                    >
                        <CardMedia
                            component="img"
                            height="160"
                            image={`${BACKEND_URL}/uploads/${mainImage.file_path}`}
                            alt={room.name}
                            sx={{
                                borderRadius: '4px 4px 0 0',
                                objectFit: 'cover'
                            }}
                        />
                        {room.images.length > 1 && (
                            <Box
                                className="overlay"
                                sx={{
                                    position: 'absolute',
                                    bottom: 0,
                                    right: 0,
                                    bgcolor: 'rgba(0, 0, 0, 0.6)',
                                    color: 'white',
                                    px: 1,
                                    py: 0.5,
                                    borderRadius: '4px 0 0 0',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: 0.5,
                                    opacity: 0,
                                    transition: 'opacity 0.2s',
                                }}
                            >
                                <PhotoLibraryIcon fontSize="small" />
                                <Typography variant="caption">
                                    +{room.images.length - 1}
                                </Typography>
                            </Box>
                        )}
                    </Box>
                )}
                <CardContent sx={{ p: 1.5 }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                        {room.accommodation_type === 'bed' ? (
                            <SingleBedIcon sx={{ mr: 1 }} />
                        ) : room.accommodation_type === 'apartment' ? (
                            <ApartmentIcon sx={{ mr: 1 }} />
                        ) : (
                            <HotelIcon sx={{ mr: 1 }} />
                        )}
                        <Typography variant="subtitle1" component="div">
                            {room.name}
                        </Typography>
                    </Box>
                    <Typography variant="body2" color="text.secondary" gutterBottom>
                        {room.address_street}, {room.address_city}
                    </Typography>
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mb: 1.5 }}>
                        <Chip
                            size="small"
                            label={`${room.price_per_night} ₽/ночь`}
                            color="primary"
                        />
                        {room.accommodation_type === 'bed' && (
                            <Chip
                                size="small"
                                label={`${room.available_beds}/${room.total_beds} мест`}
                                color="secondary"
                            />
                        )}
                    </Box>
                    <Button
                        variant="contained"
                        size="small"
                        fullWidth
                        onClick={(e) => {
                            e.stopPropagation();
                            onRoomSelect(room);
                        }}
                    >
                        Забронировать
                    </Button>
                </CardContent>
            </Card>
        );
    };

    return (
        <Box sx={{ position: 'relative' }}>
            <GoogleMap
                mapContainerStyle={mapContainerStyle}
                center={defaultCenter}
                zoom={13}
                onLoad={onMapLoad}
                options={getMapOptions()}
            >
                {rooms?.map((room) => {
                    if (room.latitude && room.longitude) {
                        const lat = parseFloat(room.latitude);
                        const lng = parseFloat(room.longitude);

                        if (!isNaN(lat) && !isNaN(lng)) {
                            const icon = {
                                path: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z",  // SVG path для капли
                                fillColor: room.accommodation_type === 'bed'
                                    ? '#1976d2'
                                    : room.accommodation_type === 'apartment'
                                        ? '#dc004e'
                                        : '#4caf50',
                                fillOpacity: 1,
                                strokeWeight: 1,
                                strokeColor: '#ffffff',
                                scale: 2,
                                anchor: new window.google.maps.Point(12, 22),
                                labelOrigin: new window.google.maps.Point(12, 9)
                            };

                            const label = {
                                text: room.accommodation_type === 'bed'
                                    ? '🛏️'
                                    : room.accommodation_type === 'apartment'
                                        ? '🏢'
                                        : '🏠',
                                color: '#FFFFFF',
                                fontSize: '14px'
                            };

                            return (
                                <Marker
                                    key={room.id}
                                    position={{ lat, lng }}
                                    onClick={() => setSelectedRoom(room)}
                                    icon={icon}
                                    label={label}
                                />
                            );
                        }
                    }
                    return null;
                })}

                {selectedRoom && (
                    <InfoWindow
                        position={{
                            lat: parseFloat(selectedRoom.latitude),
                            lng: parseFloat(selectedRoom.longitude)
                        }}
                        onCloseClick={() => setSelectedRoom(null)}
                    >
                        <InfoWindowContent room={selectedRoom} />
                    </InfoWindow>
                )}
            </GoogleMap>
            <Button
                variant="contained"
                startIcon={<MyLocationIcon />}
                onClick={handleMyLocation}
                sx={{
                    position: 'absolute',
                    top: '15px',
                    right: '60px',
                    backgroundColor: 'white',
                    color: 'black',
                    '&:hover': {
                        backgroundColor: '#f5f5f5',
                    },
                    boxShadow: '0 2px 6px rgba(0,0,0,.3)',
                }}
            >

            </Button>
        </Box>
    );
};

export default MapView;

--- Содержимое файла: frontend/hostel-frontend/src/components/AddBooking.js ---

import React, { useState, useEffect } from "react";
import {
  Container,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  MenuItem,
  Grid
} from "@mui/material";
import axios from "../api/axios";

const AddBooking = () => {
  const [booking, setBooking] = useState({
    user_id: "",
    room_id: "",
    start_date: "",
    end_date: ""
  });
  
  const [rooms, setRooms] = useState([]); // Список всех комнат
  const [users, setUsers] = useState([]); // Список всех пользователей
  const [error, setError] = useState("");
  const [success, setSuccess] = useState(false);

  // Загрузка списка комнат и пользователей
  useEffect(() => {
    const fetchData = async () => {
      try {
        const [roomsResponse, usersResponse] = await Promise.all([
          axios.get("/rooms"),
          axios.get("/users")
        ]);
        setRooms(roomsResponse.data);
        setUsers(usersResponse.data);
      } catch (error) {
        console.error("Ошибка загрузки данных:", error);
      }
    };
    fetchData();
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setSuccess(false);

    try {
      await axios.post("/bookings", {
        ...booking,
        user_id: parseInt(booking.user_id),
        room_id: parseInt(booking.room_id)
      });
      setSuccess(true);
      setBooking({
        user_id: "",
        room_id: "",
        start_date: "",
        end_date: ""
      });
    } catch (error) {
      setError(error.response?.data || "Ошибка добавления бронирования");
      console.error("Ошибка добавления бронирования:", error);
    }
  };

  // Получаем текущую дату для ограничения выбора дат
  const today = new Date().toISOString().split('T')[0];

  return (
    <Container maxWidth="sm">
      <Box sx={{ mt: 4, mb: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Добавить бронирование (Админ)
        </Typography>

        {success && (
          <Alert severity="success" sx={{ mb: 2 }}>
            Бронирование добавлено успешно!
          </Alert>
        )}

        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        <form onSubmit={handleSubmit}>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                select
                label="Пользователь"
                fullWidth
                value={booking.user_id}
                onChange={(e) => setBooking({ ...booking, user_id: e.target.value })}
              >
                {users.map((user) => (
                  <MenuItem key={user.id} value={user.id}>
                    {user.name} ({user.email})
                  </MenuItem>
                ))}
              </TextField>
            </Grid>

            <Grid item xs={12}>
              <TextField
                select
                label="Комната"
                fullWidth
                value={booking.room_id}
                onChange={(e) => setBooking({ ...booking, room_id: e.target.value })}
              >
                {rooms.map((room) => (
                  <MenuItem key={room.id} value={room.id}>
                    {room.name} ({room.address_city}, {room.price_per_night} евро/сутки)
                  </MenuItem>
                ))}
              </TextField>
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                label="Дата заезда"
                type="date"
                fullWidth
                InputLabelProps={{ shrink: true }}
                value={booking.start_date}
                onChange={(e) => setBooking({ ...booking, start_date: e.target.value })}
                inputProps={{ min: today }}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                label="Дата выезда"
                type="date"
                fullWidth
                InputLabelProps={{ shrink: true }}
                value={booking.end_date}
                onChange={(e) => setBooking({ ...booking, end_date: e.target.value })}
                inputProps={{ min: booking.start_date || today }}
              />
            </Grid>

            <Grid item xs={12}>
              <Button
                type="submit"
                variant="contained"
                color="primary"
                fullWidth
                size="large"
              >
                Добавить бронирование
              </Button>
            </Grid>
          </Grid>
        </form>
      </Box>
    </Container>
  );
};

export default AddBooking;

--- Содержимое файла: frontend/hostel-frontend/src/components/BookRoom.js ---



--- Содержимое файла: frontend/hostel-frontend/src/components/BookingDialog.js ---

import React, { useState, useEffect } from 'react';
import { useAuth } from '../contexts/AuthContext';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Button,
    TextField,
    Box,
    Typography,
    Alert,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Grid,
    //    Tooltip,
    Popover,
} from '@mui/material';
import axios from "../api/axios";

const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;

const BookingDialog = ({ open, onClose, room, startDate, endDate }) => {
    const { user } = useAuth(); // Получаем данные пользователя из контекста
    const [error, setError] = useState('');
    const [success, setSuccess] = useState(false);
    const [selectedBed, setSelectedBed] = useState('');
    const [availableBeds, setAvailableBeds] = useState([]);
    const [bedImages, setBedImages] = useState({});
    const [anchorEl, setAnchorEl] = useState(null);
    const [activeBed, setActiveBed] = useState(null);
    const [bookingStartDate, setBookingStartDate] = useState(startDate);
    const [bookingEndDate, setBookingEndDate] = useState(endDate);

    useEffect(() => {
        if (open && room && room.accommodation_type === 'bed' && bookingStartDate && bookingEndDate) {
            // Сбрасываем предыдущий выбор койки при изменении дат
            setSelectedBed('');
            setError('');

            axios.get(`/rooms/${room.id}/available-beds`, {
                params: {
                    start_date: bookingStartDate,
                    end_date: bookingEndDate
                }
            })
                .then(response => {
                    setAvailableBeds(response.data);
                    response.data.forEach(bed => {
                        axios.get(`/beds/${bed.id}/images`)
                            .then(imgResponse => {
                                setBedImages(prev => ({
                                    ...prev,
                                    [bed.id]: imgResponse.data
                                }));
                            })
                            .catch(console.error);
                    });
                })
                .catch(err => {
                    console.error('Ошибка загрузки доступных койко-мест:', err);
                    setError('Не удалось загрузить список доступных койко-мест');
                });
        }
    }, [open, room, bookingStartDate, bookingEndDate]);
    const handleMouseEnter = (event, bed) => {
        if (bedImages[bed.id]?.length > 0) {
            setActiveBed(bed);
            setAnchorEl(event.currentTarget);
        }
    };

    const handleMouseLeave = () => {
        setActiveBed(null);
        setAnchorEl(null);
    };

    const renderBedImage = () => {
        if (!activeBed || !bedImages[activeBed.id]?.length) return null;

        const image = bedImages[activeBed.id][0];
        return (
            <Box sx={{ p: 1 }}>
                <img
                    src={`${BACKEND_URL}/uploads/${image.file_path}`}
                    alt={`Койко-место ${activeBed.bed_number}`}
                    style={{
                        width: '200px',
                        height: '150px',
                        objectFit: 'cover',
                        borderRadius: '4px'
                    }}
                />
            </Box>
        );
    };

    const calculateTotalPrice = () => {
        if (!bookingStartDate || !bookingEndDate) return 0;
    
        const start = new Date(bookingStartDate);
        const end = new Date(bookingEndDate);
        const daysCount = Math.ceil((end - start) / (1000 * 60 * 60 * 24));

        let pricePerNight;
        if (room.accommodation_type === 'bed' && selectedBed) {
            const selectedBedData = availableBeds.find(bed => bed.id === selectedBed);
            pricePerNight = selectedBedData ? selectedBedData.price_per_night : 0;
        } else {
            pricePerNight = room.price_per_night;
        }

        return pricePerNight * daysCount;
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setSuccess(false);

        if (!user) {
            setError('Необходимо войти в систему для бронирования');
            return;
        }

        if (!bookingStartDate || !bookingEndDate) {
            setError('Выберите даты проживания');
            return;
        }

        if (room.accommodation_type === 'bed' && !selectedBed) {
            setError('Выберите койко-место');
            return;
        }

        if (bookingStartDate === bookingEndDate) {
            setError('Дата выезда должна быть позже даты заезда');
            return;
        }

        try {
            const bookingData = {
                room_id: room.id,
                start_date: bookingStartDate,
                end_date: bookingEndDate
            };

            if (room.accommodation_type === 'bed') {
                bookingData.bed_id = selectedBed;
            }

            // Отправляем запрос с куками для авторизации
            const response = await axios.post('/bookings', bookingData, {
                withCredentials: true
            });

            setSuccess(true);
            setTimeout(() => {
                onClose();
                setSelectedBed('');
                setError('');
                setSuccess(false);
            }, 2000);
        } catch (error) {
            if (error.response?.status === 401) {
                setError('Необходимо войти в систему');
            } else {
                setError(error.response?.data || 'Произошла ошибка при бронировании');
            }
        }
    };

    const getDialogTitle = () => {
        switch (room?.accommodation_type) {
            case 'bed':
                return 'Бронирование койко-места';
            case 'apartment':
                return 'Бронирование квартиры';
            default:
                return 'Бронирование комнаты';
        }
    };

    const today = new Date().toISOString().split('T')[0];

    return (
        <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
            <DialogTitle>{getDialogTitle()}</DialogTitle>
            <DialogContent>
                {!user ? (
                    <Alert severity="warning" sx={{ mt: 2 }}>
                        Для бронирования необходимо войти в систему
                    </Alert>
                ) : (
                    <>
                        {success && (
                            <Alert severity="success" sx={{ mt: 2 }}>
                                Бронирование успешно создано!
                            </Alert>
                        )}
                        {error && (
                            <Alert severity="error" sx={{ mt: 2 }}>
                                {error}
                            </Alert>
                        )}
                        {room && (
                            <Box sx={{ mt: 2 }}>
                                <Typography variant="h6">{room.name}</Typography>
                                <Typography variant="body2" color="text.secondary">
                                    {room.address_street}, {room.address_city}
                                </Typography>
    
                                <Grid container spacing={2} sx={{ mt: 1, mb: 2 }}>
                                    <Grid item xs={12} sm={6}>
                                        <TextField
                                            label="Дата заезда"
                                            type="date"
                                            fullWidth
                                            value={bookingStartDate}
                                            onChange={(e) => setBookingStartDate(e.target.value)}
                                            inputProps={{ min: today }}
                                            InputLabelProps={{ shrink: true }}
                                        />
                                    </Grid>
                                    <Grid item xs={12} sm={6}>
                                        <TextField
                                            label="Дата выезда"
                                            type="date"
                                            fullWidth
                                            value={bookingEndDate}
                                            onChange={(e) => setBookingEndDate(e.target.value)}
                                            inputProps={{ min: bookingStartDate || today }}
                                            InputLabelProps={{ shrink: true }}
                                        />
                                    </Grid>
                                </Grid>
    
                                {room.accommodation_type === 'bed' && (
                                    <FormControl fullWidth sx={{ mt: 2 }}>
                                        <InputLabel>Выберите койко-место</InputLabel>
                                        <Select
                                            value={selectedBed}
                                            onChange={(e) => setSelectedBed(e.target.value)}
                                            label="Выберите койко-место"
                                        >
                                            {availableBeds.map(bed => (
                                                <MenuItem
                                                    key={bed.id}
                                                    value={bed.id}
                                                    onMouseEnter={(e) => handleMouseEnter(e, bed)}
                                                    onMouseLeave={handleMouseLeave}
                                                >
                                                    Место {bed.bed_number} - {bed.price_per_night} руб./ночь
                                                </MenuItem>
                                            ))}
                                        </Select>
                                    </FormControl>
                                )}
    
                                <Typography variant="h6" sx={{ mt: 2 }}>
                                    Итого к оплате: {calculateTotalPrice()} руб.
                                </Typography>
                            </Box>
                        )}
                    </>
                )}
    
                <Popover
                    open={Boolean(anchorEl)}
                    anchorEl={anchorEl}
                    onClose={handleMouseLeave}
                    anchorOrigin={{
                        vertical: 'center',
                        horizontal: 'right',
                    }}
                    transformOrigin={{
                        vertical: 'center',
                        horizontal: 'left',
                    }}
                    sx={{
                        pointerEvents: 'none',
                    }}
                >
                    {renderBedImage()}
                </Popover>
            </DialogContent>
            <DialogActions>
                <Button onClick={onClose} color="inherit">
                    Отмена
                </Button>
                <Button
                    onClick={handleSubmit}
                    color="primary"
                    variant="contained"
                    disabled={!user ||
                        !bookingStartDate ||
                        !bookingEndDate ||
                        bookingStartDate === bookingEndDate ||
                        (room?.accommodation_type === 'bed' && !selectedBed)}
                >
                    Забронировать
                </Button>
            </DialogActions>
        </Dialog>
    );
};

export default BookingDialog;

--- Содержимое файла: frontend/hostel-frontend/src/components/AdminPanel.js ---



--- Содержимое файла: frontend/hostel-frontend/src/components/LocationPicker.js ---

import React, { useState, useCallback } from 'react';
import { GoogleMap, LoadScript, Marker } from '@react-google-maps/api';
import {
    Box,
    TextField,
    Paper,
    Typography,
    InputAdornment,
    IconButton,
} from '@mui/material';
import { Search as SearchIcon, MyLocation as MyLocationIcon } from '@mui/icons-material';

const libraries = ["places", "geometry"];

const LocationPicker = ({ onLocationSelect }) => {
    const [map, setMap] = useState(null);
    const [marker, setMarker] = useState(null);
    const [address, setAddress] = useState('');
    const [searchBox, setSearchBox] = useState(null);

    const mapContainerStyle = {
        width: '100%',
        height: '400px'
    };

    const defaultCenter = {
        lat: 45.2671, // Нови-Сад
        lng: 19.8335
    };

    const mapOptions = {
        scrollwheel: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
            style: 'DEFAULT',
            mapTypeIds: ["roadmap", "satellite", "hybrid"]
        },
        streetViewControl: false,
        fullscreenControl: false,
    };

    // Добавьте новую функцию handleLocationSelect перед onMapLoad
    const handleLocationSelect = (location) => {
        const getAddressComponent = (type) => {
            return location.address_components?.find(
                component => component.types.includes(type)
            )?.long_name || '';
        };

        // Получаем номер дома и улицу отдельно
        const streetNumber = getAddressComponent('street_number');
        const route = getAddressComponent('route');

        // Формируем полный адрес улицы с номером дома
        const fullStreetAddress = route
            ? (streetNumber ? `${route}, ${streetNumber}` : route)
            : '';

        // Передаем данные в родительский компонент
        onLocationSelect({
            latitude: location.latitude,
            longitude: location.longitude,
            formatted_address: location.formatted_address,
            // Передаем сформированный адрес с номером дома
            address_components: {
                street: fullStreetAddress || getAddressComponent('sublocality') || '',
                city: getAddressComponent('locality'),
                state: getAddressComponent('administrative_area_level_1'),
                country: getAddressComponent('country'),
                postal_code: getAddressComponent('postal_code')
            }
        });
    };

    const onMapLoad = useCallback((map) => {
        setMap(map);
        // Инициализируем поисковую строку после загрузки карты
        const searchInput = document.getElementById('location-search');
        if (searchInput && window.google) {
            const searchBoxInstance = new window.google.maps.places.SearchBox(searchInput);
            setSearchBox(searchBoxInstance);

            searchBoxInstance.addListener('places_changed', () => {
                const places = searchBoxInstance.getPlaces();
                if (places.length === 0) return;

                const place = places[0];
                if (!place.geometry) return;

                // Центрируем карту на найденном месте
                map.setCenter(place.geometry.location);
                map.setZoom(17);

                // Устанавливаем маркер
                setMarker({
                    lat: place.geometry.location.lat(),
                    lng: place.geometry.location.lng()
                });

                // Обновляем адрес
                setAddress(place.formatted_address);

                // Вызываем обработчик с данными места
                handleLocationSelect({
                    latitude: place.geometry.location.lat(),
                    longitude: place.geometry.location.lng(),
                    formatted_address: place.formatted_address,
                    address_components: place.address_components
                });
            });
        }
    }, [onLocationSelect]);

    const handleMapClick = useCallback((e) => {
        const lat = e.latLng.lat();
        const lng = e.latLng.lng();

        setMarker({ lat, lng });

        if (window.google) {
            const geocoder = new window.google.maps.Geocoder();
            geocoder.geocode(
                { location: { lat, lng } },
                (results, status) => {
                    if (status === 'OK' && results[0]) {
                        const place = results[0];
                        setAddress(place.formatted_address);
                        const location = {
                            latitude: lat,
                            longitude: lng,
                            formatted_address: place.formatted_address,
                            address_components: place.address_components
                        };
                        handleLocationSelect(location);
                    }
                }
            );
        }
    }, []);

    const handleCurrentLocation = () => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;

                    // Центрируем карту и устанавливаем маркер
                    if (map) {
                        map.setCenter({ lat, lng });
                        map.setZoom(17);
                        setMarker({ lat, lng });
                    }

                    // Получаем адрес по координатам
                    if (window.google) {
                        const geocoder = new window.google.maps.Geocoder();
                        geocoder.geocode(
                            { location: { lat, lng } },
                            (results, status) => {
                                if (status === 'OK' && results[0]) {
                                    const place = results[0];
                                    setAddress(place.formatted_address);
                                    handleLocationSelect({
                                        latitude: lat,
                                        longitude: lng,
                                        formatted_address: place.formatted_address,
                                        address_components: place.address_components
                                    });
                                }
                            }
                        );
                    }
                },
                (error) => {
                    console.error("Error getting current location:", error);
                    alert("Не удалось получить текущее местоположение");
                }
            );
        } else {
            alert("Геолокация не поддерживается вашим браузером");
        }
    };

    return (
        <Paper sx={{ p: 2 }}>
            <Typography variant="h6" gutterBottom>
                Выберите местоположение объекта
            </Typography>
            <Box sx={{ mb: 2 }}>
                <TextField
                    id="location-search"
                    fullWidth
                    placeholder="Поиск по адресу..."
                    value={address}
                    onChange={(e) => setAddress(e.target.value)}
                    InputProps={{
                        startAdornment: (
                            <InputAdornment position="start">
                                <SearchIcon />
                            </InputAdornment>
                        ),
                        endAdornment: (
                            <InputAdornment position="end">
                                <IconButton
                                    onClick={handleCurrentLocation}
                                    title="Мое местоположение"
                                >
                                    <MyLocationIcon />
                                </IconButton>
                            </InputAdornment>
                        )
                    }}
                />
            </Box>
            <LoadScript
                googleMapsApiKey={process.env.REACT_APP_GOOGLE_MAPS_API_KEY}
                libraries={libraries}
            >
                <GoogleMap
                    mapContainerStyle={mapContainerStyle}
                    center={defaultCenter}
                    zoom={13}
                    onLoad={onMapLoad}
                    onClick={handleMapClick}
                    options={mapOptions}
                >
                    {marker && (
                        <Marker
                            position={marker}
                            draggable={true}
                            onDragEnd={(e) => handleMapClick(e)}
                        />
                    )}
                </GoogleMap>
            </LoadScript>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Кликните по карте или введите адрес для выбора местоположения
            </Typography>
        </Paper>
    );
};

export default LocationPicker;

--- Содержимое файла: frontend/hostel-frontend/src/components/AddUser.js ---

import React, { useState } from "react";
import { TextField, Button, Container, Typography, Alert } from "@mui/material";
import axios from "../api/axios";
import { useAuth } from "../contexts/AuthContext";

const AddUser = () => {
  const { user } = useAuth();
  const [userForm, setUserForm] = useState({ name: "", email: "" });
  const [error, setError] = useState("");
  const [success, setSuccess] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setSuccess(false);

    if (!user) {
      setError("Необходимо войти в систему");
      return;
    }

    try {
      await axios.post('/users', userForm, {
        withCredentials: true
      });
      setSuccess(true);
      setUserForm({ name: "", email: "" });
    } catch (err) {
      setError(err.response?.data || "Ошибка при добавлении пользователя");
    }
  };

  if (!user) {
    return (
      <Container>
        <Alert severity="warning">
          Для добавления пользователей необходимо войти в систему
        </Alert>
      </Container>
    );
  }

  return (
    <Container>
      <Typography variant="h4" gutterBottom>
        Добавить пользователя
      </Typography>
      {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
      {success && <Alert severity="success" sx={{ mb: 2 }}>Пользователь успешно добавлен!</Alert>}
      <form onSubmit={handleSubmit}>
        <TextField
          label="Имя"
          fullWidth
          margin="normal"
          value={userForm.name}
          onChange={(e) => setUserForm({ ...userForm, name: e.target.value })}
          required
        />
        <TextField
          label="Email"
          type="email"
          fullWidth
          margin="normal"
          value={userForm.email}
          onChange={(e) => setUserForm({ ...userForm, email: e.target.value })}
          required
        />
        <Button 
          type="submit" 
          variant="contained" 
          color="primary"
          sx={{ mt: 2 }}
        >
          Добавить
        </Button>
      </form>
    </Container>
  );
};

export default AddUser;

--- Содержимое файла: frontend/hostel-frontend/src/components/RoomList.js ---

import React, { useState, useEffect, useCallback } from 'react';
import axios from "../api/axios";
import { Chip } from '@mui/material';
import { LoadScript } from '@react-google-maps/api';
import {
    Grid, Card, CardContent, Typography, TextField,
    Button, Divider, Box, Dialog, DialogContent, IconButton,
    MobileStepper, CardMedia,
    ToggleButton,
    ToggleButtonGroup,
    Paper,
    ButtonGroup
} from "@mui/material";
import {
    KeyboardArrowLeft, KeyboardArrowRight,
    Close as CloseIcon,
    SingleBed as HotelIcon,
    Hotel as SingleBedIcon,
    Apartment as ApartmentIcon,
    Home as HomeIcon,
    ViewList as ViewListIcon,
    Map as MapIcon,
    Search as SearchIcon
} from '@mui/icons-material';
import BookingDialog from "./BookingDialog";
import MapView from './MapView';


const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;

const ImageGallery = ({ images, open, onClose }) => {
    const [activeStep, setActiveStep] = useState(0);
    const maxSteps = images.length;

    const handleNext = () => {
        setActiveStep((prevStep) => (prevStep + 1) % maxSteps);
    };

    const handleBack = () => {
        setActiveStep((prevStep) => (prevStep - 1 + maxSteps) % maxSteps);
    };

    if (!images.length) return null;

    return (
        <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
            <DialogContent sx={{ position: 'relative', p: 0 }}>
                <IconButton
                    onClick={onClose}
                    sx={{
                        position: 'absolute',
                        right: 8,
                        top: 8,
                        color: 'white',
                        bgcolor: 'rgba(0, 0, 0, 0.5)',
                        '&:hover': {
                            bgcolor: 'rgba(0, 0, 0, 0.7)',
                        },
                    }}
                >
                    <CloseIcon />
                </IconButton>
                <Box sx={{ height: '80vh', display: 'flex', flexDirection: 'column', justifyContent: 'center' }}>
                    <img
                        src={`${BACKEND_URL}/uploads/${images[activeStep].file_path}`} // Исправлено здесь
                        alt={images[activeStep].file_name}
                        style={{
                            width: '100%',
                            height: '100%',
                            objectFit: 'contain',
                        }}
                    />
                    <MobileStepper
                        steps={maxSteps}
                        position="static"
                        activeStep={activeStep}
                        sx={{
                            bgcolor: 'background.default',
                            position: 'absolute',
                            bottom: 0,
                            width: '100%',
                        }}
                        nextButton={
                            <Button size="small" onClick={handleNext}>
                                Следующее
                                <KeyboardArrowRight />
                            </Button>
                        }
                        backButton={
                            <Button size="small" onClick={handleBack}>
                                <KeyboardArrowLeft />
                                Предыдущее
                            </Button>
                        }
                    />
                </Box>
            </DialogContent>
        </Dialog>
    );
};

const RoomList = () => {
    const [rooms, setRooms] = useState([]);
    const [filters, setFilters] = useState({
        capacity: "",
        min_price: "",
        max_price: "",
        city: "",
        country: "",
        start_date: "",
        end_date: "",
        type: ''
    });

    const handleTypeFilter = (type) => {
        setFilters(prev => ({
            ...prev,
            type: prev.type === type ? '' : type // сброс фильтра при повторном нажатии
        }));
    };


    const [viewMode, setViewMode] = useState('list'); // 'list' или 'map'
    const [roomsWithCoordinates, setRoomsWithCoordinates] = useState([]);
    const geocodeRooms = async (rooms) => {
        if (!window.google) return rooms;

        const geocoder = new window.google.maps.Geocoder();
        const geocodeAddress = async (room) => {
            const address = `${room.address_street}, ${room.address_city}, ${room.address_country}`;
            try {
                const result = await new Promise((resolve, reject) => {
                    geocoder.geocode({ address }, (results, status) => {
                        if (status === 'OK') {
                            resolve(results[0].geometry.location);
                        } else {
                            reject(status);
                        }
                    });
                });

                return {
                    ...room,
                    latitude: result.lat(),
                    longitude: result.lng()
                };
            } catch (error) {
                console.error(`Error geocoding address: ${address}`, error);
                return room;
            }
        };

        const roomsWithCoords = await Promise.all(rooms.map(geocodeAddress));
        return roomsWithCoords;
    };
    const [selectedRoom, setSelectedRoom] = useState(null);
    const [galleryOpen, setGalleryOpen] = useState(false);
    const [bookingDialogOpen, setBookingDialogOpen] = useState(false);

    const fetchRooms = useCallback(async () => {
        try {
            const params = new URLSearchParams();

            // Добавляем базовые параметры
            if (filters.capacity && parseInt(filters.capacity) > 0) {
                params.append('capacity', filters.capacity);
            }
            if (filters.min_price && parseFloat(filters.min_price) > 0) {
                params.append('min_price', filters.min_price);
            }
            if (filters.max_price && parseFloat(filters.max_price) > 0) {
                params.append('max_price', filters.max_price);
            }
            if (filters.city?.trim()) {
                params.append('city', filters.city.trim());
            }
            if (filters.country?.trim()) {
                params.append('country', filters.country.trim());
            }

            // Добавляем фильтр по типу размещения
            if (filters.type) {
                params.append('accommodation_type', filters.type);
                if (filters.type === 'room') {
                    params.append('has_private_rooms', 'true');
                }
            }

            // Всегда отправляем даты для проверки доступности
            const today = new Date().toISOString().split('T')[0];
            params.append('start_date', filters.start_date || today);
            params.append('end_date', filters.end_date || today);

            const response = await axios.get(`/rooms?${params.toString()}`);
            const roomsData = response.data || [];

            // Фильтрация на фронтенде
            const filteredRooms = roomsData.filter(room => {
                // Базовая проверка доступности
                if (room.accommodation_type === 'bed' && room.available_beds <= 0) {
                    return false;
                }

                // Проверка типа размещения
                if (filters.type && room.accommodation_type !== filters.type) {
                    return false;
                }

                // Проверка для приватных комнат
                if (filters.type === 'room' && room.is_shared) {
                    return false;
                }

                return true;
            });

            // Получаем изображения для отфильтрованных комнат
            const roomsWithImages = await Promise.all(
                filteredRooms.map(async (room) => {
                    const imagesResponse = await axios.get(`/rooms/${room.id}/images`);
                    return {
                        ...room,
                        images: imagesResponse.data || []
                    };
                })
            );

            setRooms(roomsWithImages);
            setRoomsWithCoordinates(roomsWithImages.filter(room =>
                room.latitude && room.longitude));

        } catch (error) {
            console.error("Ошибка при получении списка комнат:", error);
        }
    }, [filters]);

    const handleDateChange = (field, value) => {
        setFilters(prev => {
            const newFilters = { ...prev, [field]: value };

            if (field === 'end_date' && newFilters.start_date && value < newFilters.start_date) {
                return prev;
            }

            if (field === 'start_date' && newFilters.end_date && value > newFilters.end_date) {
                return prev;
            }

            return newFilters;
        });
    };

    const handleBooking = (room) => {
        if (!filters.start_date || !filters.end_date) {
            alert('Пожалуйста, выберите даты заезда и выезда');
            return;
        }
        setSelectedRoom(room);
        setBookingDialogOpen(true);
    };

// долой протечки памяти
    useEffect(() => {
        let isSubscribed = true;
        
        const fetchData = async () => {
            try {
                const response = await fetchRooms();
                if (isSubscribed) {
                    setRooms(response.data);
                }
            } catch (error) {
                if (isSubscribed) {
                    console.error(error);
                }
            }
        };
        
        fetchData();
        
        return () => {
            isSubscribed = false;
        };
    }, [fetchRooms]);

    const AccommodationInfo = ({ room }) => {
        const getAccommodationInfo = () => {
            switch (room.accommodation_type) {
                case 'bed':
                    return {
                        title: 'Койко-место',
                        details: `Доступно ${room.available_beds} из ${room.total_beds} мест`,
                        icon: <HotelIcon />,
                        shared: true
                    };
                case 'room':
                    return {
                        title: room.is_shared ? 'Общая комната' : 'Отдельная комната',
                        details: `Вместимость: ${room.capacity} чел.`,
                        icon: <SingleBedIcon />,
                        shared: room.is_shared
                    };
                case 'apartment':
                    return {
                        title: 'Квартира',
                        details: `${room.capacity} комнат`,
                        icon: <ApartmentIcon />,
                        shared: false
                    };
                default:
                    return {
                        title: 'Помещение',
                        details: `Вместимость: ${room.capacity} чел.`,
                        icon: <HomeIcon />,
                        shared: false
                    };
            }
        };

        const info = getAccommodationInfo();

        return (
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                {info.icon}
                <Box>
                    <Typography variant="subtitle2" sx={{ fontWeight: 'medium' }}>
                        {info.title}
                        {info.shared && (
                            <Chip
                                size="small"
                                label="Общее помещение"
                                color="secondary"
                                sx={{ ml: 1 }}
                            />
                        )}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                        {info.details}
                    </Typography>
                </Box>
            </Box>
        );
    };


    const today = new Date().toISOString().split('T')[0];

    return (
        <div>

            <Grid container spacing={2} sx={{ mb: 3, mt: 1 }}>
                {/* Первая строка с датами, городом, страной и ценами */}
                <Grid item container spacing={2} xs={12}>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Дата заезда"
                            type="date"
                            size="small"
                            fullWidth
                            InputLabelProps={{ shrink: true }}
                            value={filters.start_date}
                            onChange={(e) => handleDateChange('start_date', e.target.value)}
                            inputProps={{ min: today }}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Дата выезда"
                            type="date"
                            size="small"
                            fullWidth
                            InputLabelProps={{ shrink: true }}
                            value={filters.end_date}
                            onChange={(e) => handleDateChange('end_date', e.target.value)}
                            inputProps={{ min: filters.start_date || today }}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Город"
                            size="small"
                            fullWidth
                            value={filters.city}
                            onChange={(e) => setFilters({ ...filters, city: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Страна"
                            size="small"
                            fullWidth
                            value={filters.country}
                            onChange={(e) => setFilters({ ...filters, country: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Мин. цена"
                            type="number"
                            size="small"
                            fullWidth
                            value={filters.min_price}
                            onChange={(e) => setFilters({ ...filters, min_price: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Макс. цена"
                            type="number"
                            size="small"
                            fullWidth
                            value={filters.max_price}
                            onChange={(e) => setFilters({ ...filters, max_price: e.target.value })}
                        />
                    </Grid>
                </Grid>

                {/* Вторая строка с кнопками */}
                <Grid item container xs={12} spacing={2} alignItems="center">
                    <Grid item>
                        <Button
                            variant="contained"
                            color="primary"
                            onClick={fetchRooms}
                            startIcon={<SearchIcon />}
                        >
                            Найти
                        </Button>
                    </Grid>
                    <Grid item>
                        <ButtonGroup
                            variant="outlined"
                            sx={{
                                '& .MuiButton-root': {
                                    borderColor: '#1976d2',
                                    '&:hover': {
                                        borderColor: '#1976d2',
                                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                    }
                                }
                            }}
                        >
                            <Button
                                onClick={() => handleTypeFilter('apartment')}
                                startIcon={<ApartmentIcon />}
                                color={filters.type === 'apartment' ? 'primary' : 'inherit'}
                            >
                                Аппарты
                            </Button>
                            <Button
                                onClick={() => handleTypeFilter('room')}
                                startIcon={<HotelIcon />}
                                color={filters.type === 'room' ? 'primary' : 'inherit'}
                            >
                                Приватка
                            </Button>
                            <Button
                                onClick={() => handleTypeFilter('bed')}
                                startIcon={<SingleBedIcon />}
                                color={filters.type === 'bed' ? 'primary' : 'inherit'}
                            >
                                Кровать
                            </Button>
                        </ButtonGroup>
                    </Grid>
                    <Grid item sx={{ marginLeft: 'auto' }}>
                        <ToggleButtonGroup
                            value={viewMode}
                            exclusive
                            onChange={(e, newMode) => newMode && setViewMode(newMode)}
                            aria-label="view mode"
                            size="small"
                            sx={{
                                border: '1px solid rgba(25, 118, 210, 0.5)',
                                '& .MuiToggleButton-root': {
                                    '&.Mui-selected': {
                                        backgroundColor: '#1976d2',
                                        color: 'white',
                                        '&:hover': {
                                            backgroundColor: '#1565c0',
                                        }
                                    },
                                    '&:hover': {
                                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                    }
                                }
                            }}
                        >
                            <ToggleButton value="list" aria-label="list view">
                                <ViewListIcon /> Список
                            </ToggleButton>
                            <ToggleButton value="map" aria-label="map view">
                                <MapIcon /> Карта
                            </ToggleButton>
                        </ToggleButtonGroup>
                    </Grid>
                </Grid>
            </Grid>
            <Box>
                {viewMode === 'map' ? (
                    <LoadScript
                        googleMapsApiKey={process.env.REACT_APP_GOOGLE_MAPS_API_KEY}
                        libraries={["places", "geometry"]}
                    >
                        <MapView
                            rooms={roomsWithCoordinates}
                            onRoomSelect={(room) => {
                                setSelectedRoom(room);
                                setBookingDialogOpen(true);
                            }}
                            onOpenGallery={(room) => {
                                setSelectedRoom(room);
                                setGalleryOpen(true);
                            }}
                        />
                    </LoadScript>
                ) : (
                    <Grid container spacing={2}>
                        {rooms.map((room) => (
                            <Grid item xs={12} md={6} lg={4} key={room.id}>
                                <Card sx={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    height: '100%',
                                    border: '1px solid rgba(25, 118, 210, 0.2)',
                                    boxShadow: '0 2px 4px rgba(25, 118, 210, 0.1)',
                                    '&:hover': {
                                        boxShadow: '0 4px 8px rgba(25, 118, 210, 0.2)',
                                    },
                                    '& .MuiCardContent-root': {
                                        padding: '12px',
                                    },
                                    '& .MuiTypography-root': {
                                        lineHeight: '1.3',
                                    }
                                }}>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', p: 1.5 }}>
                                        <Box sx={{ flex: 1, pr: 1.5 }}>
                                            <AccommodationInfo room={room} />
                                            <Typography variant="h6" sx={{
                                                mb: 0.5,
                                                fontSize: '1.1rem'
                                            }}>
                                                {room.name}
                                            </Typography>
                                            {room.accommodation_type === 'bed' ? (
                                                <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
                                                    Цена за койко-место: {room.price_per_night} евро/сутки
                                                </Typography>
                                            ) : (
                                                <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
                                                    Цена за {room.accommodation_type === 'apartment' ? 'квартиру' : 'комнату'}: {room.price_per_night} евро/сутки
                                                </Typography>
                                            )}
                                        </Box>

                                        {/* Правый верхний угол: эскиз */}
                                        <Box sx={{
                                            width: '100px',
                                            height: '100px',
                                            flexShrink: 0,
                                            p: room.images?.length ? 0 : 1
                                        }}>
                                            {room.images && room.images.length > 0 ? (
                                                <CardMedia
                                                    component="img"
                                                    sx={{
                                                        width: '100%',
                                                        height: '100%',
                                                        objectFit: 'cover',
                                                        borderRadius: '4px',
                                                        '&:hover': {
                                                            opacity: 0.8,
                                                            transition: 'opacity 0.2s ease-in-out',
                                                        },
                                                    }}
                                                    image={`${BACKEND_URL}/uploads/${room.images[0].file_path}`}
                                                    alt={room.name}
                                                    onClick={() => {
                                                        setSelectedRoom(room);
                                                        setGalleryOpen(true);
                                                    }}
                                                />
                                            ) : (
                                                <Box
                                                    sx={{
                                                        width: '100%',
                                                        height: '100%',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        bgcolor: 'grey.100',
                                                        borderRadius: '4px',
                                                        fontSize: '0.8rem'
                                                    }}
                                                >
                                                    <Typography variant="body2" color="text.secondary">
                                                        Нет фото
                                                    </Typography>
                                                </Box>
                                            )}
                                        </Box>
                                    </Box>

                                    <Divider />

                                    {/* Нижняя часть карточки с адресом и кнопками */}
                                    <CardContent sx={{
                                        pt: 1,
                                        pb: '8px !important',
                                        display: 'flex',
                                        justifyContent: 'space-between',
                                        alignItems: 'center'
                                    }}>
                                        <Typography variant="body2" color="text.secondary" sx={{
                                            fontSize: '0.85rem',
                                            flex: 1,
                                            mr: 1
                                        }}>
                                            {room.address_street}
                                            {room.address_city && `, ${room.address_city}`}
                                            {room.address_state && `, ${room.address_state}`}
                                            {room.address_country && `, ${room.address_country}`}
                                            {room.address_postal_code && ` (${room.address_postal_code})`}
                                        </Typography>
                                        <Box sx={{ display: 'flex', gap: 0.5 }}>
                                            {room.images && room.images.length > 1 && (
                                                <Button
                                                    size="small"
                                                    sx={{
                                                        minWidth: 'auto',
                                                        padding: '4px 8px',
                                                        fontSize: '0.8rem',
                                                        borderColor: '#1976d2',
                                                        color: '#1976d2',
                                                        '&:hover': {
                                                            borderColor: '#1565c0',
                                                            backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                                        }
                                                    }}
                                                    onClick={() => {
                                                        setSelectedRoom(room);
                                                        setGalleryOpen(true);
                                                    }}
                                                >
                                                    Все ({room.images.length})
                                                </Button> 
                                            )}
                                            <Button
                                                variant="contained"
                                                color="primary"
                                                size="small"
                                                sx={{
                                                    minWidth: 'auto',
                                                    padding: '4px 8px',
                                                    fontSize: '0.8rem',
                                                    boxShadow: '0 2px 4px rgba(25, 118, 210, 0.2)',
                                                    '&:hover': {
                                                        boxShadow: '0 4px 8px rgba(25, 118, 210, 0.3)',
                                                    }
                                                }}
                                                onClick={() => handleBooking(room)}
                                                disabled={!filters.start_date || !filters.end_date}
                                            >
                                                Забронировать
                                            </Button>
                                        </Box>
                                    </CardContent>
                                </Card>
                            </Grid>

                        ))}
                    </Grid>
                )}
            </Box>
            {selectedRoom && (
                <>
                    <ImageGallery
                        images={selectedRoom.images || []}
                        open={galleryOpen}
                        onClose={() => {
                            setGalleryOpen(false);
                            setSelectedRoom(null);
                        }}
                    />
                    <BookingDialog
                        open={bookingDialogOpen}
                        onClose={() => {
                            setBookingDialogOpen(false);
                            setSelectedRoom(null);
                        }}
                        room={selectedRoom}
                        startDate={filters.start_date}
                        endDate={filters.end_date}
                    />
                </>
            )}
        </div>
    );
};

export default RoomList;

--- Содержимое файла: frontend/hostel-frontend/src/components/AddRoom.js ---

import React, { useState } from "react";
import LocationPicker from './LocationPicker';
import {
    TextField,
    Button,
    Container,
    Typography,
    Box,
    Alert,
    Grid,
    IconButton,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    FormControlLabel,
    Switch
} from "@mui/material";
import { Delete as DeleteIcon, CloudUpload as CloudUploadIcon } from '@mui/icons-material';
import axios from "../api/axios";

const AddRoom = () => {
    const [room, setRoom] = useState({
        name: "",
        accommodation_type: "room",
        capacity: 0,
        price_per_night: 0,
        address_street: "",
        address_city: "",
        address_state: "",
        address_country: "",
        address_postal_code: "",
        is_shared: false,
        total_beds: null,
        available_beds: null,
        has_private_bathroom: true,
        latitude: null,
        longitude: null,
        formatted_address: ''
    });

    const [beds, setBeds] = useState([
        { bed_number: "1", price_per_night: 0, images: [], imagePreviewUrls: [] }
    ]);
    const [images, setImages] = useState([]);
    const [previewUrls, setPreviewUrls] = useState([]);
    const [errorMessage, setErrorMessage] = useState("");
    const [isSuccess, setIsSuccess] = useState(false);

    const handleBedImageChange = (index, e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;

        const validFiles = files.filter(file => {
            if (!file.type.startsWith('image/')) {
                setErrorMessage("Можно загружать только изображения");
                return false;
            }
            if (file.size > 5 * 1024 * 1024) {
                setErrorMessage("Размер файла не должен превышать 5MB");
                return false;
            }
            return true;
        });

        if (validFiles.length === 0) return;

        const newBeds = [...beds];
        newBeds[index] = {
            ...newBeds[index],
            images: [...(newBeds[index].images || []), ...validFiles]
        };

        // Создаем превью для изображений
        validFiles.forEach(file => {
            const reader = new FileReader();
            reader.onloadend = () => {
                newBeds[index].imagePreviewUrls = [
                    ...(newBeds[index].imagePreviewUrls || []),
                    reader.result
                ];
                setBeds([...newBeds]);
            };
            reader.readAsDataURL(file);
        });
    };

    const handleLocationSelect = (location) => {
        setRoom(prev => ({
            ...prev,
            latitude: location.latitude,
            longitude: location.longitude,
            formatted_address: location.formatted_address,
            address_street: location.address_components?.street || '',
            address_city: location.address_components?.city || '',
            address_state: location.address_components?.state || '',
            address_country: location.address_components?.country || '',
            address_postal_code: location.address_components?.postal_code || ''
        }));
    };

    const handleImageChange = (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;

        const validFiles = files.filter(file => {
            if (!file.type.startsWith('image/')) {
                setErrorMessage("Можно загружать только изображения");
                return false;
            }
            if (file.size > 5 * 1024 * 1024) {
                setErrorMessage("Размер файла не должен превышать 5MB");
                return false;
            }
            return true;
        });

        if (validFiles.length === 0) return;

        setImages(prev => [...prev, ...validFiles]);

        validFiles.forEach(file => {
            const reader = new FileReader();
            reader.onloadend = () => {
                setPreviewUrls(prev => [...prev, reader.result]);
            };
            reader.onerror = () => {
                setErrorMessage("Ошибка при чтении файла: " + file.name);
            };
            reader.readAsDataURL(file);
        });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setErrorMessage("");
        setIsSuccess(false);

        try {
            if (room.accommodation_type === 'bed' && (!room.total_beds || beds.length === 0)) {
                setErrorMessage("Добавьте информацию о кроватях");
                return;
            }

            const roomData = {
                ...room,
                latitude: parseFloat(room.latitude),
                longitude: parseFloat(room.longitude)
            };

            // Создаем комнату
            const roomResponse = await axios.post("/rooms", roomData);
            const roomId = roomResponse.data.id;

            // Если тип размещения - койко-места, создаем кровати и загружаем их изображения
            if (room.accommodation_type === 'bed' && beds.length > 0) {
                await Promise.all(
                    beds.map(async (bed) => {
                        try {
                            // Создаем койко-место
                            const bedResponse = await axios.post(`/rooms/${roomId}/beds`, {
                                bed_number: bed.bed_number,
                                price_per_night: parseFloat(bed.price_per_night)
                            });

                            // Если есть изображения для койко-места, загружаем их
                            if (bed.images && bed.images.length > 0) {
                                const formData = new FormData();
                                bed.images.forEach(image => {
                                    formData.append('images', image);
                                });

                                await axios.post(`/beds/${bedResponse.data.id}/images`, formData, {
                                    headers: {
                                        'Content-Type': 'multipart/form-data'
                                    }
                                });
                            }
                        } catch (error) {
                            console.error('Ошибка добавления кровати или её изображений:', error);
                            throw error;
                        }
                    })
                );
            }

            // Загружаем общие изображения комнаты
            if (images.length > 0) {
                const formData = new FormData();
                images.forEach(image => {
                    formData.append('images', image);
                });

                await axios.post(`/rooms/${roomId}/images`, formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                });
            }

            setIsSuccess(true);
            // Сброс формы
            setRoom({
                name: "",
                accommodation_type: "room",
                capacity: 0,
                price_per_night: 0,
                address_street: "",
                address_city: "",
                address_state: "",
                address_country: "",
                address_postal_code: "",
                is_shared: false,
                total_beds: null,
                available_beds: null,
                has_private_bathroom: true,
                latitude: null,
                longitude: null,
                formatted_address: ''
            });
            setBeds([{ bed_number: "1", price_per_night: 0, images: [], imagePreviewUrls: [] }]);
            setImages([]);
            setPreviewUrls([]);
        } catch (error) {
            console.error('Ошибка при добавлении:', error);
            setErrorMessage(error.response?.data || "Ошибка при добавлении объекта размещения");
        }
    };

    return (
        <Container>
            <Typography variant="h4" gutterBottom>
                Добавить объект размещения
            </Typography>
            {errorMessage && (
                <Alert severity="error" sx={{ mb: 2 }}>
                    {errorMessage}
                </Alert>
            )}
            {isSuccess && (
                <Alert severity="success" sx={{ mb: 2 }}>
                    Объект размещения успешно добавлен
                </Alert>
            )}
            <form onSubmit={handleSubmit}>
                <Grid container spacing={2}>
                    {/* Базовая информация */}
                    <Grid item xs={12}>
                        <TextField
                            label="Название"
                            fullWidth
                            required
                            value={room.name}
                            onChange={(e) => setRoom({ ...room, name: e.target.value })}
                        />
                    </Grid>

                    {/* Тип размещения */}
                    <Grid item xs={12}>
                        <FormControl fullWidth>
                            <InputLabel>Тип размещения</InputLabel>
                            <Select
                                value={room.accommodation_type}
                                onChange={(e) => {
                                    const newType = e.target.value;
                                    setRoom(prev => ({
                                        ...prev,
                                        accommodation_type: newType,
                                        total_beds: newType === 'bed' ? prev.total_beds : null,
                                        available_beds: newType === 'bed' ? prev.available_beds : null,
                                        is_shared: newType === 'bed' ? true : false,
                                    }));
                                }}
                            >
                                <MenuItem value="bed">Койко-место</MenuItem>
                                <MenuItem value="room">Комната</MenuItem>
                                <MenuItem value="apartment">Квартира</MenuItem>
                            </Select>
                        </FormControl>
                    </Grid>

                    {room.accommodation_type === 'bed' ? (
                        <>
                            <Grid item xs={12} md={6}>
                                <TextField
                                    label="Всего кроватей"
                                    type="number"
                                    fullWidth
                                    required
                                    value={room.total_beds || ''}
                                    onChange={(e) => setRoom({
                                        ...room,
                                        total_beds: parseInt(e.target.value) || 0,
                                        available_beds: parseInt(e.target.value) || 0
                                    })}
                                />
                            </Grid>
                            <Grid item xs={12}>
                                {beds.map((bed, index) => (
                                    <Box key={index} sx={{ display: 'flex', gap: 2, mb: 2 }}>
                                        <TextField
                                            label={`Номер кровати ${index + 1}`}
                                            value={bed.bed_number}
                                            onChange={(e) => {
                                                const newBeds = [...beds];
                                                newBeds[index].bed_number = e.target.value;
                                                setBeds(newBeds);
                                            }}
                                        />
                                        <TextField
                                            label="Цена за ночь"
                                            type="number"
                                            value={bed.price_per_night}
                                            onChange={(e) => {
                                                const newBeds = [...beds];
                                                newBeds[index].price_per_night = parseFloat(e.target.value);
                                                setBeds(newBeds);
                                            }}
                                        />
                                        <Box>
                                            <Button
                                                variant="contained"
                                                component="label"
                                                size="small"
                                            >
                                                Фото кровати
                                                <input
                                                    type="file"
                                                    hidden
                                                    multiple
                                                    accept="image/*"
                                                    onChange={(e) => handleBedImageChange(index, e)}
                                                />
                                            </Button>
                                            {bed.imagePreviewUrls && bed.imagePreviewUrls.length > 0 && (
                                                <Box sx={{ mt: 1, display: 'flex', gap: 1 }}>
                                                    {bed.imagePreviewUrls.map((url, imgIndex) => (
                                                        <Box
                                                            key={imgIndex}
                                                            sx={{
                                                                position: 'relative',
                                                                width: 60,
                                                                height: 60
                                                            }}
                                                        >
                                                            <img
                                                                src={url}
                                                                alt={`Preview ${imgIndex}`}
                                                                style={{
                                                                    width: '100%',
                                                                    height: '100%',
                                                                    objectFit: 'cover',
                                                                    borderRadius: '4px'
                                                                }}
                                                            />
                                                            <IconButton
                                                                size="small"
                                                                sx={{
                                                                    position: 'absolute',
                                                                    top: -8,
                                                                    right: -8,
                                                                    bgcolor: 'background.paper'
                                                                }}
                                                                onClick={() => {
                                                                    const newBeds = [...beds];
                                                                    newBeds[index].images.splice(imgIndex, 1);
                                                                    newBeds[index].imagePreviewUrls.splice(imgIndex, 1);
                                                                    setBeds(newBeds);
                                                                }}
                                                            >
                                                                <DeleteIcon fontSize="small" />
                                                            </IconButton>
                                                        </Box>
                                                    ))}
                                                </Box>
                                            )}
                                        </Box>
                                        <IconButton onClick={() => {
                                            const newBeds = [...beds];
                                            newBeds.splice(index, 1);
                                            setBeds(newBeds);
                                        }}>
                                            <DeleteIcon />
                                        </IconButton>
                                    </Box>
                                ))}

                                <Button
                                    variant="outlined"
                                    onClick={() => setBeds([...beds, { bed_number: `${beds.length + 1}`, price_per_night: 0 }])}
                                >
                                    Добавить кровать
                                </Button>
                            </Grid>
                        </>
                    ) : (
                        <>
                            <Grid item xs={12} md={6}>
                                <TextField
                                    label="Вместимость"
                                    type="number"
                                    fullWidth
                                    required
                                    value={room.capacity}
                                    onChange={(e) => setRoom({ ...room, capacity: parseInt(e.target.value) || 0 })}
                                />
                            </Grid>
                            <Grid item xs={12} md={6}>
                                <TextField
                                    label="Цена за ночь"
                                    type="number"
                                    fullWidth
                                    required
                                    value={room.price_per_night}
                                    onChange={(e) => setRoom({ ...room, price_per_night: parseFloat(e.target.value) || 0 })}
                                />
                            </Grid>
                        </>
                    )}

                    <Grid item xs={12}>
                        <FormControlLabel
                            control={
                                <Switch
                                    checked={room.is_shared}
                                    onChange={(e) => setRoom({ ...room, is_shared: e.target.checked })}
                                />
                            }
                            label="Общее помещение"
                        />
                    </Grid>

                    <Grid item xs={12}>
                        <FormControlLabel
                            control={
                                <Switch
                                    checked={room.has_private_bathroom}
                                    onChange={(e) => setRoom({ ...room, has_private_bathroom: e.target.checked })}
                                />
                            }
                            label="Отдельная ванная комната"
                        />
                    </Grid>

                    {/* Выбор местоположения */}
                    <Grid item xs={12}>
                        <LocationPicker onLocationSelect={handleLocationSelect} />
                    </Grid>

                    {/* Адрес */}
                    <Grid item xs={12}>
                        <Typography variant="h6">Адрес</Typography>
                    </Grid>
                    <Grid item xs={12}>
                        <TextField
                            label="Улица"
                            fullWidth
                            required
                            value={room.address_street}
                            onChange={(e) => setRoom({ ...room, address_street: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Город"
                            fullWidth
                            required
                            value={room.address_city}
                            onChange={(e) => setRoom({ ...room, address_city: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Область/Регион"
                            fullWidth
                            value={room.address_state}
                            onChange={(e) => setRoom({ ...room, address_state: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Страна"
                            fullWidth
                            required
                            value={room.address_country}
                            onChange={(e) => setRoom({ ...room, address_country: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Почтовый индекс"
                            fullWidth
                            value={room.address_postal_code}
                            onChange={(e) => setRoom({ ...room, address_postal_code: e.target.value })}
                        />
                    </Grid>

                    {/* Изображения */}
                    <Grid item xs={12}>
                        <Typography variant="h6">Фотографии</Typography>
                        <Box sx={{ mt: 1, mb: 2 }}>
                            <Button
                                variant="contained"
                                component="label"
                                startIcon={<CloudUploadIcon />}
                            >
                                Загрузить изображения
                                <input
                                    type="file"
                                    hidden
                                    multiple
                                    accept="image/*"
                                    onChange={handleImageChange}
                                />
                            </Button>
                        </Box>
                        <Grid container spacing={2}>
                            {previewUrls.map((url, index) => (
                                <Grid item xs={12} sm={4} key={index}>
                                    <Box sx={{ position: 'relative' }}>
                                        <img
                                            src={url}
                                            alt={`Preview ${index}`}
                                            style={{
                                                width: '100%',
                                                height: '200px',
                                                objectFit: 'cover',
                                                borderRadius: '4px'
                                            }}
                                        />
                                        <IconButton
                                            sx={{
                                                position: 'absolute',
                                                top: 8,
                                                right: 8,
                                                bgcolor: 'rgba(255, 255, 255, 0.8)'
                                            }}
                                            onClick={() => {
                                                setImages(prev => prev.filter((_, i) => i !== index));
                                                setPreviewUrls(prev => prev.filter((_, i) => i !== index));
                                            }}
                                        >
                                            <DeleteIcon />
                                        </IconButton>
                                    </Box>
                                </Grid>
                            ))}
                        </Grid>
                    </Grid>

                    <Grid item xs={12}>
                        <Button
                            type="submit"
                            variant="contained"
                            color="primary"
                            fullWidth
                            size="large"
                            disabled={!room.name ||
                                !room.latitude ||
                                !room.longitude ||
                                !room.address_city ||
                                !room.address_country ||
                                (room.accommodation_type === 'bed' && (!room.total_beds || beds.length === 0))}
                        >
                            Добавить
                        </Button>
                    </Grid>
                </Grid>
            </form>
        </Container>
    );
};

export default AddRoom;

--- Содержимое файла: frontend/hostel-frontend/src/components/Layout.js ---

import React from "react";
import { Link } from "react-router-dom";
import { 
  AppBar, 
  Toolbar, 
  Typography, 
  Button, 
  Avatar,
  Menu,
  MenuItem,
  Box,
} from "@mui/material";
import { useAuth } from "../contexts/AuthContext";

const Layout = ({ children }) => {
  const { user, login, logout } = useAuth();
  const [anchorEl, setAnchorEl] = React.useState(null);

  const handleMenu = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  return (
    <Box>
      <AppBar position="static">
        <Toolbar>
          <Typography
            variant="h6"
            component={Link}
            to="/"
            sx={{
              flexGrow: 1,
              textDecoration: 'none',
              color: 'inherit'
            }}
          >
            Hostel Booking System
          </Typography>

          {user ? (
            <>
              <Button
                color="inherit"
                component={Link}
                to="/bookings"
              >
                Все бронирования
              </Button>
              <Button
                color="inherit"
                component={Link}
                to="/add-room"
              >
                Добавить объявление
              </Button>

              <Box 
                onClick={handleMenu}
                sx={{ 
                  display: 'flex',
                  alignItems: 'center',
                  ml: 2,
                  cursor: 'pointer'
                }}
              >
                <Avatar
                  sx={{ 
                    width: 32,
                    height: 32,
                    bgcolor: 'primary.dark'
                  }}
                >
                  {user.name.charAt(0)}
                </Avatar>
              </Box>
              <Menu
                id="menu-appbar"
                anchorEl={anchorEl}
                anchorOrigin={{
                  vertical: 'bottom',
                  horizontal: 'right',
                }}
                keepMounted
                transformOrigin={{
                  vertical: 'top',
                  horizontal: 'right',
                }}
                open={Boolean(anchorEl)}
                onClose={handleClose}
              >
                <MenuItem disabled>
                  <Typography variant="body2">{user.email}</Typography>
                </MenuItem>
                <MenuItem onClick={logout}>Выйти</MenuItem>
              </Menu>
            </>
          ) : (
            <Button 
              color="inherit"
              onClick={login}
            >
              ВОЙТИ ЧЕРЕЗ GOOGLE
            </Button>
          )}
        </Toolbar>
      </AppBar>
      {children}
    </Box>
  );
};

export default Layout;

--- Содержимое файла: frontend/hostel-frontend/src/components/BookingsList.js ---

import React, { useState, useEffect } from 'react';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    Typography,
    Chip,
    Box
} from '@mui/material';
import {
    Apartment as ApartmentIcon,
    Hotel as HotelIcon,
    SingleBed as SingleBedIcon
} from '@mui/icons-material';
import axios from '../api/axios';

const BookingsList = () => {
    const [bookings, setBookings] = useState([]);

    useEffect(() => {
        const fetchBookings = async () => {
            try {
                const response = await axios.get('/bookings', { withCredentials: true });
                setBookings(response.data);
            } catch (error) {
                console.error('Ошибка получения списка бронирований:', error);
            }
        };

        fetchBookings();
    }, []);

    const getAccommodationIcon = (type) => {
        switch (type) {
            case 'bed':
                return <SingleBedIcon color="primary" />;
            case 'room':
                return <HotelIcon color="primary" />;
            case 'apartment':
                return <ApartmentIcon color="primary" />;
            default:
                return null;
        }
    };

    const formatDate = (dateString) => {
        return new Date(dateString).toLocaleDateString('ru-RU', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit'
        });
    };

    return (
        <Box>
            <Typography variant="h5" gutterBottom>
                Список бронирований
            </Typography>
            <TableContainer component={Paper}>
                <Table>
                    <TableHead>
                        <TableRow>
                            <TableCell>Тип размещения</TableCell>
                            <TableCell>Комната</TableCell>
                            <TableCell>Клиент</TableCell>
                            <TableCell>Даты проживания</TableCell>
                            <TableCell>Статус</TableCell>
                        </TableRow>
                    </TableHead>
                    <TableBody>
                        {bookings.map((booking) => (
                            <TableRow key={booking.id} hover>
                                <TableCell>
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                        {getAccommodationIcon(booking.type)}
                                        <Typography variant="body2">
                                            {booking.type === 'bed' 
                                                ? 'Койко-место' 
                                                : booking.type === 'room' 
                                                    ? 'Комната' 
                                                    : 'Квартира'}
                                        </Typography>
                                    </Box>
                                </TableCell>
                                <TableCell>
                                    <Typography variant="body2">
                                        {booking.room_name}
                                        {booking.bed_id && (
                                            <Typography variant="caption" display="block" color="text.secondary">
                                                Место {booking.bed_id}
                                            </Typography>
                                        )}
                                    </Typography>
                                </TableCell>
                                <TableCell>
                                    <Typography variant="body2">
                                        {booking.user_name}
                                        <Typography variant="caption" display="block" color="text.secondary">
                                            {booking.user_email}
                                        </Typography>
                                    </Typography>
                                </TableCell>
                                <TableCell>
                                    <Box>
                                        <Typography variant="body2">
                                            {`${formatDate(booking.start_date)} - ${formatDate(booking.end_date)}`}
                                        </Typography>
                                        <Typography variant="caption" color="text.secondary">
                                            {Math.ceil(
                                                (new Date(booking.end_date) - new Date(booking.start_date)) / 
                                                (1000 * 60 * 60 * 24)
                                            )} дней
                                        </Typography>
                                    </Box>
                                </TableCell>
                                <TableCell>
                                    <Chip
                                        size="small"
                                        label={booking.status === 'confirmed' ? 'Подтверждено' : 'В обработке'}
                                        color={booking.status === 'confirmed' ? 'success' : 'warning'}
                                    />
                                </TableCell>
                            </TableRow>
                        ))}
                    </TableBody>
                </Table>
            </TableContainer>
        </Box>
    );
};

export default BookingsList;

--- Содержимое файла: frontend/hostel-frontend/src/api/axios.js ---

import axios from 'axios';

const instance = axios.create({
  baseURL: process.env.REACT_APP_BACKEND_URL,
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json'
  }
});

export default instance;

--- Содержимое файла: frontend/hostel-frontend/src/contexts/AuthContext.js ---

import React, { createContext, useState, useContext, useEffect } from 'react';
import axios from '../api/axios';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const checkAuth = async () => {
    try {
      const response = await axios.get('/auth/session', { withCredentials: true });
      if (response.data.authenticated) {
        setUser(response.data.user);
      }
    } catch (error) {
      console.error('Auth check failed:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    checkAuth();
  }, []);

  const login = () => {
    window.location.href = `${process.env.REACT_APP_BACKEND_URL}/auth/google`;
  };

  const logout = async () => {
    try {
      await axios.get('/auth/logout', { withCredentials: true });
      setUser(null);
    } catch (error) {
      console.error('Logout failed:', error);
    }
  };

  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

--- Содержимое файла: frontend/hostel-frontend/src/pages/AddBookingPage.js ---

import React from "react";
import AddBooking from "../components/AddBooking";

const AddBookingPage = () => <AddBooking />;

export default AddBookingPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/AddRoomPage.js ---

import React from "react";
import AddRoom from "../components/AddRoom";

const AddRoomPage = () => <AddRoom />;

export default AddRoomPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/AddUserPage.js ---

import React from "react";
import AddUser from "../components/AddUser";

const AddUserPage = () => <AddUser />;

export default AddUserPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/HomePage.js ---

import React from "react";
import { Container } from "@mui/material";
import RoomList from "../components/RoomList";

const HomePage = () => (
  <Container sx={{ marginTop: 4 }}>
    <RoomList />
  </Container>
);

export default HomePage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/BookingsListPage.js ---

// frontend/hostel-frontend/src/pages/BookingsListPage.js
import React from 'react';
import { Container } from '@mui/material';
import BookingsList from '../components/BookingsList';

const BookingsListPage = () => {
  return (
    <Container sx={{ mt: 4 }}>
      <BookingsList />
    </Container>
  );
};

export default BookingsListPage;

--- Содержимое файла: frontend/hostel-frontend/src/pages/BookRoomPage.js ---



--- Содержимое файла: frontend/hostel-frontend/src/pages/AdminPanelPage.js ---

import React from "react";
import AddRoom from "../components/AddRoom";
import AddUser from "../components/AddUser";
import AddBooking from "../components/AddBooking";

const AdminPanelPage = () => (
  <div>
    <h1>Админ-панель</h1>
    <AddRoom />
    <AddUser />
    <AddBooking />
  </div>
);

export default AdminPanelPage;


--- Содержимое файла: frontend/hostel-frontend/src/api/axios.js ---

import axios from 'axios';

const instance = axios.create({
  baseURL: process.env.REACT_APP_BACKEND_URL,
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json'
  }
});

export default instance;

--- Содержимое файла: frontend/hostel-frontend/src/components/MapView.js ---

import React, { useState, useCallback } from 'react';
import { GoogleMap, Marker, InfoWindow } from '@react-google-maps/api';
import {
    Card,
    CardContent,
    Typography,
    Box,
    Button,
    Chip,
    CardMedia,
} from '@mui/material';
import {
    SingleBed as SingleBedIcon,
    Hotel as HotelIcon,
    Apartment as ApartmentIcon,
    PhotoLibrary as PhotoLibraryIcon,
    MyLocation as MyLocationIcon,
} from '@mui/icons-material';

const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;

const mapContainerStyle = {
    width: '100%',
    height: '700px'
};

const defaultCenter = {
    lat: 45.2671, // Нови-Сад
    lng: 19.8335
};

const MapView = ({ rooms, onRoomSelect, onOpenGallery }) => {
    const [map, setMap] = useState(null);
    const [selectedRoom, setSelectedRoom] = useState(null);

    // Выносим опции карты в отдельную функцию для предотвращения проблем с window.google
    const getMapOptions = useCallback(() => ({
        scrollwheel: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
            style: 'DEFAULT', // Убираем прямую ссылку на google.maps
            mapTypeIds: ["roadmap", "satellite", "hybrid"]
        },
        styles: [
            {
                featureType: "poi",
                elementType: "labels",
                stylers: [{ visibility: "off" }]
            }
        ],
        fullscreenControl: true,
        streetViewControl: false,
        zoomControl: true,
    }), []);

    const onMapLoad = useCallback((map) => {
        setMap(map);
        console.log('Map loaded, rooms:', rooms); // Отладка
        if (rooms?.length > 0) {
            const bounds = new window.google.maps.LatLngBounds();
            let hasValidCoords = false;

            rooms.forEach(room => {
                if (room.latitude && room.longitude) {
                    const lat = parseFloat(room.latitude);
                    const lng = parseFloat(room.longitude);

                    if (!isNaN(lat) && !isNaN(lng)) {
                        bounds.extend({ lat, lng });
                        hasValidCoords = true;
                        console.log(`Added to bounds: ${room.name}, lat: ${lat}, lng: ${lng}`); // Отладка
                    }
                }
            });

            if (hasValidCoords) {
                map.fitBounds(bounds);
            }
        }
    }, [rooms]);

    const handleMyLocation = () => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const pos = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };
                    map?.panTo(pos);
                    map?.setZoom(15);
                },
                (error) => {
                    console.error("Error getting location:", error);
                    alert("Не удалось получить местоположение");
                }
            );
        } else {
            alert("Геолокация не поддерживается вашим браузером");
        }
    };

    const InfoWindowContent = ({ room }) => {
        const hasImages = room.images && room.images.length > 0;
        const mainImage = hasImages ? room.images.find(img => img.is_main) || room.images[0] : null;

        return (
            <Card sx={{ width: 300, border: 'none', boxShadow: 'none' }}>
                {mainImage && (
                    <Box
                        sx={{
                            position: 'relative',
                            cursor: 'pointer',
                            '&:hover': {
                                '& .overlay': {
                                    opacity: 1
                                }
                            }
                        }}
                        onClick={(e) => {
                            e.stopPropagation();
                            onOpenGallery(room);
                        }}
                    >
                        <CardMedia
                            component="img"
                            height="160"
                            image={`${BACKEND_URL}/uploads/${mainImage.file_path}`}
                            alt={room.name}
                            sx={{
                                borderRadius: '4px 4px 0 0',
                                objectFit: 'cover'
                            }}
                        />
                        {room.images.length > 1 && (
                            <Box
                                className="overlay"
                                sx={{
                                    position: 'absolute',
                                    bottom: 0,
                                    right: 0,
                                    bgcolor: 'rgba(0, 0, 0, 0.6)',
                                    color: 'white',
                                    px: 1,
                                    py: 0.5,
                                    borderRadius: '4px 0 0 0',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: 0.5,
                                    opacity: 0,
                                    transition: 'opacity 0.2s',
                                }}
                            >
                                <PhotoLibraryIcon fontSize="small" />
                                <Typography variant="caption">
                                    +{room.images.length - 1}
                                </Typography>
                            </Box>
                        )}
                    </Box>
                )}
                <CardContent sx={{ p: 1.5 }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                        {room.accommodation_type === 'bed' ? (
                            <SingleBedIcon sx={{ mr: 1 }} />
                        ) : room.accommodation_type === 'apartment' ? (
                            <ApartmentIcon sx={{ mr: 1 }} />
                        ) : (
                            <HotelIcon sx={{ mr: 1 }} />
                        )}
                        <Typography variant="subtitle1" component="div">
                            {room.name}
                        </Typography>
                    </Box>
                    <Typography variant="body2" color="text.secondary" gutterBottom>
                        {room.address_street}, {room.address_city}
                    </Typography>
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mb: 1.5 }}>
                        <Chip
                            size="small"
                            label={`${room.price_per_night} ₽/ночь`}
                            color="primary"
                        />
                        {room.accommodation_type === 'bed' && (
                            <Chip
                                size="small"
                                label={`${room.available_beds}/${room.total_beds} мест`}
                                color="secondary"
                            />
                        )}
                    </Box>
                    <Button
                        variant="contained"
                        size="small"
                        fullWidth
                        onClick={(e) => {
                            e.stopPropagation();
                            onRoomSelect(room);
                        }}
                    >
                        Забронировать
                    </Button>
                </CardContent>
            </Card>
        );
    };

    return (
        <Box sx={{ position: 'relative' }}>
            <GoogleMap
                mapContainerStyle={mapContainerStyle}
                center={defaultCenter}
                zoom={13}
                onLoad={onMapLoad}
                options={getMapOptions()}
            >
                {rooms?.map((room) => {
                    if (room.latitude && room.longitude) {
                        const lat = parseFloat(room.latitude);
                        const lng = parseFloat(room.longitude);

                        if (!isNaN(lat) && !isNaN(lng)) {
                            const icon = {
                                path: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z",  // SVG path для капли
                                fillColor: room.accommodation_type === 'bed'
                                    ? '#1976d2'
                                    : room.accommodation_type === 'apartment'
                                        ? '#dc004e'
                                        : '#4caf50',
                                fillOpacity: 1,
                                strokeWeight: 1,
                                strokeColor: '#ffffff',
                                scale: 2,
                                anchor: new window.google.maps.Point(12, 22),
                                labelOrigin: new window.google.maps.Point(12, 9)
                            };

                            const label = {
                                text: room.accommodation_type === 'bed'
                                    ? '🛏️'
                                    : room.accommodation_type === 'apartment'
                                        ? '🏢'
                                        : '🏠',
                                color: '#FFFFFF',
                                fontSize: '14px'
                            };

                            return (
                                <Marker
                                    key={room.id}
                                    position={{ lat, lng }}
                                    onClick={() => setSelectedRoom(room)}
                                    icon={icon}
                                    label={label}
                                />
                            );
                        }
                    }
                    return null;
                })}

                {selectedRoom && (
                    <InfoWindow
                        position={{
                            lat: parseFloat(selectedRoom.latitude),
                            lng: parseFloat(selectedRoom.longitude)
                        }}
                        onCloseClick={() => setSelectedRoom(null)}
                    >
                        <InfoWindowContent room={selectedRoom} />
                    </InfoWindow>
                )}
            </GoogleMap>
            <Button
                variant="contained"
                startIcon={<MyLocationIcon />}
                onClick={handleMyLocation}
                sx={{
                    position: 'absolute',
                    top: '15px',
                    right: '60px',
                    backgroundColor: 'white',
                    color: 'black',
                    '&:hover': {
                        backgroundColor: '#f5f5f5',
                    },
                    boxShadow: '0 2px 6px rgba(0,0,0,.3)',
                }}
            >

            </Button>
        </Box>
    );
};

export default MapView;

--- Содержимое файла: frontend/hostel-frontend/src/components/AddBooking.js ---

import React, { useState, useEffect } from "react";
import {
  Container,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  MenuItem,
  Grid
} from "@mui/material";
import axios from "../api/axios";

const AddBooking = () => {
  const [booking, setBooking] = useState({
    user_id: "",
    room_id: "",
    start_date: "",
    end_date: ""
  });
  
  const [rooms, setRooms] = useState([]); // Список всех комнат
  const [users, setUsers] = useState([]); // Список всех пользователей
  const [error, setError] = useState("");
  const [success, setSuccess] = useState(false);

  // Загрузка списка комнат и пользователей
  useEffect(() => {
    const fetchData = async () => {
      try {
        const [roomsResponse, usersResponse] = await Promise.all([
          axios.get("/rooms"),
          axios.get("/users")
        ]);
        setRooms(roomsResponse.data);
        setUsers(usersResponse.data);
      } catch (error) {
        console.error("Ошибка загрузки данных:", error);
      }
    };
    fetchData();
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setSuccess(false);

    try {
      await axios.post("/bookings", {
        ...booking,
        user_id: parseInt(booking.user_id),
        room_id: parseInt(booking.room_id)
      });
      setSuccess(true);
      setBooking({
        user_id: "",
        room_id: "",
        start_date: "",
        end_date: ""
      });
    } catch (error) {
      setError(error.response?.data || "Ошибка добавления бронирования");
      console.error("Ошибка добавления бронирования:", error);
    }
  };

  // Получаем текущую дату для ограничения выбора дат
  const today = new Date().toISOString().split('T')[0];

  return (
    <Container maxWidth="sm">
      <Box sx={{ mt: 4, mb: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Добавить бронирование (Админ)
        </Typography>

        {success && (
          <Alert severity="success" sx={{ mb: 2 }}>
            Бронирование добавлено успешно!
          </Alert>
        )}

        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        <form onSubmit={handleSubmit}>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                select
                label="Пользователь"
                fullWidth
                value={booking.user_id}
                onChange={(e) => setBooking({ ...booking, user_id: e.target.value })}
              >
                {users.map((user) => (
                  <MenuItem key={user.id} value={user.id}>
                    {user.name} ({user.email})
                  </MenuItem>
                ))}
              </TextField>
            </Grid>

            <Grid item xs={12}>
              <TextField
                select
                label="Комната"
                fullWidth
                value={booking.room_id}
                onChange={(e) => setBooking({ ...booking, room_id: e.target.value })}
              >
                {rooms.map((room) => (
                  <MenuItem key={room.id} value={room.id}>
                    {room.name} ({room.address_city}, {room.price_per_night} евро/сутки)
                  </MenuItem>
                ))}
              </TextField>
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                label="Дата заезда"
                type="date"
                fullWidth
                InputLabelProps={{ shrink: true }}
                value={booking.start_date}
                onChange={(e) => setBooking({ ...booking, start_date: e.target.value })}
                inputProps={{ min: today }}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                label="Дата выезда"
                type="date"
                fullWidth
                InputLabelProps={{ shrink: true }}
                value={booking.end_date}
                onChange={(e) => setBooking({ ...booking, end_date: e.target.value })}
                inputProps={{ min: booking.start_date || today }}
              />
            </Grid>

            <Grid item xs={12}>
              <Button
                type="submit"
                variant="contained"
                color="primary"
                fullWidth
                size="large"
              >
                Добавить бронирование
              </Button>
            </Grid>
          </Grid>
        </form>
      </Box>
    </Container>
  );
};

export default AddBooking;

--- Содержимое файла: frontend/hostel-frontend/src/components/BookRoom.js ---



--- Содержимое файла: frontend/hostel-frontend/src/components/BookingDialog.js ---

import React, { useState, useEffect } from 'react';
import { useAuth } from '../contexts/AuthContext';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Button,
    TextField,
    Box,
    Typography,
    Alert,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Grid,
    //    Tooltip,
    Popover,
} from '@mui/material';
import axios from "../api/axios";

const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;

const BookingDialog = ({ open, onClose, room, startDate, endDate }) => {
    const { user } = useAuth(); // Получаем данные пользователя из контекста
    const [error, setError] = useState('');
    const [success, setSuccess] = useState(false);
    const [selectedBed, setSelectedBed] = useState('');
    const [availableBeds, setAvailableBeds] = useState([]);
    const [bedImages, setBedImages] = useState({});
    const [anchorEl, setAnchorEl] = useState(null);
    const [activeBed, setActiveBed] = useState(null);
    const [bookingStartDate, setBookingStartDate] = useState(startDate);
    const [bookingEndDate, setBookingEndDate] = useState(endDate);

    useEffect(() => {
        if (open && room && room.accommodation_type === 'bed' && bookingStartDate && bookingEndDate) {
            // Сбрасываем предыдущий выбор койки при изменении дат
            setSelectedBed('');
            setError('');

            axios.get(`/rooms/${room.id}/available-beds`, {
                params: {
                    start_date: bookingStartDate,
                    end_date: bookingEndDate
                }
            })
                .then(response => {
                    setAvailableBeds(response.data);
                    response.data.forEach(bed => {
                        axios.get(`/beds/${bed.id}/images`)
                            .then(imgResponse => {
                                setBedImages(prev => ({
                                    ...prev,
                                    [bed.id]: imgResponse.data
                                }));
                            })
                            .catch(console.error);
                    });
                })
                .catch(err => {
                    console.error('Ошибка загрузки доступных койко-мест:', err);
                    setError('Не удалось загрузить список доступных койко-мест');
                });
        }
    }, [open, room, bookingStartDate, bookingEndDate]);
    const handleMouseEnter = (event, bed) => {
        if (bedImages[bed.id]?.length > 0) {
            setActiveBed(bed);
            setAnchorEl(event.currentTarget);
        }
    };

    const handleMouseLeave = () => {
        setActiveBed(null);
        setAnchorEl(null);
    };

    const renderBedImage = () => {
        if (!activeBed || !bedImages[activeBed.id]?.length) return null;

        const image = bedImages[activeBed.id][0];
        return (
            <Box sx={{ p: 1 }}>
                <img
                    src={`${BACKEND_URL}/uploads/${image.file_path}`}
                    alt={`Койко-место ${activeBed.bed_number}`}
                    style={{
                        width: '200px',
                        height: '150px',
                        objectFit: 'cover',
                        borderRadius: '4px'
                    }}
                />
            </Box>
        );
    };

    const calculateTotalPrice = () => {
        if (!bookingStartDate || !bookingEndDate) return 0;
    
        const start = new Date(bookingStartDate);
        const end = new Date(bookingEndDate);
        const daysCount = Math.ceil((end - start) / (1000 * 60 * 60 * 24));

        let pricePerNight;
        if (room.accommodation_type === 'bed' && selectedBed) {
            const selectedBedData = availableBeds.find(bed => bed.id === selectedBed);
            pricePerNight = selectedBedData ? selectedBedData.price_per_night : 0;
        } else {
            pricePerNight = room.price_per_night;
        }

        return pricePerNight * daysCount;
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setSuccess(false);

        if (!user) {
            setError('Необходимо войти в систему для бронирования');
            return;
        }

        if (!bookingStartDate || !bookingEndDate) {
            setError('Выберите даты проживания');
            return;
        }

        if (room.accommodation_type === 'bed' && !selectedBed) {
            setError('Выберите койко-место');
            return;
        }

        if (bookingStartDate === bookingEndDate) {
            setError('Дата выезда должна быть позже даты заезда');
            return;
        }

        try {
            const bookingData = {
                room_id: room.id,
                start_date: bookingStartDate,
                end_date: bookingEndDate
            };

            if (room.accommodation_type === 'bed') {
                bookingData.bed_id = selectedBed;
            }

            // Отправляем запрос с куками для авторизации
            const response = await axios.post('/bookings', bookingData, {
                withCredentials: true
            });

            setSuccess(true);
            setTimeout(() => {
                onClose();
                setSelectedBed('');
                setError('');
                setSuccess(false);
            }, 2000);
        } catch (error) {
            if (error.response?.status === 401) {
                setError('Необходимо войти в систему');
            } else {
                setError(error.response?.data || 'Произошла ошибка при бронировании');
            }
        }
    };

    const getDialogTitle = () => {
        switch (room?.accommodation_type) {
            case 'bed':
                return 'Бронирование койко-места';
            case 'apartment':
                return 'Бронирование квартиры';
            default:
                return 'Бронирование комнаты';
        }
    };

    const today = new Date().toISOString().split('T')[0];

    return (
        <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
            <DialogTitle>{getDialogTitle()}</DialogTitle>
            <DialogContent>
                {!user ? (
                    <Alert severity="warning" sx={{ mt: 2 }}>
                        Для бронирования необходимо войти в систему
                    </Alert>
                ) : (
                    <>
                        {success && (
                            <Alert severity="success" sx={{ mt: 2 }}>
                                Бронирование успешно создано!
                            </Alert>
                        )}
                        {error && (
                            <Alert severity="error" sx={{ mt: 2 }}>
                                {error}
                            </Alert>
                        )}
                        {room && (
                            <Box sx={{ mt: 2 }}>
                                <Typography variant="h6">{room.name}</Typography>
                                <Typography variant="body2" color="text.secondary">
                                    {room.address_street}, {room.address_city}
                                </Typography>
    
                                <Grid container spacing={2} sx={{ mt: 1, mb: 2 }}>
                                    <Grid item xs={12} sm={6}>
                                        <TextField
                                            label="Дата заезда"
                                            type="date"
                                            fullWidth
                                            value={bookingStartDate}
                                            onChange={(e) => setBookingStartDate(e.target.value)}
                                            inputProps={{ min: today }}
                                            InputLabelProps={{ shrink: true }}
                                        />
                                    </Grid>
                                    <Grid item xs={12} sm={6}>
                                        <TextField
                                            label="Дата выезда"
                                            type="date"
                                            fullWidth
                                            value={bookingEndDate}
                                            onChange={(e) => setBookingEndDate(e.target.value)}
                                            inputProps={{ min: bookingStartDate || today }}
                                            InputLabelProps={{ shrink: true }}
                                        />
                                    </Grid>
                                </Grid>
    
                                {room.accommodation_type === 'bed' && (
                                    <FormControl fullWidth sx={{ mt: 2 }}>
                                        <InputLabel>Выберите койко-место</InputLabel>
                                        <Select
                                            value={selectedBed}
                                            onChange={(e) => setSelectedBed(e.target.value)}
                                            label="Выберите койко-место"
                                        >
                                            {availableBeds.map(bed => (
                                                <MenuItem
                                                    key={bed.id}
                                                    value={bed.id}
                                                    onMouseEnter={(e) => handleMouseEnter(e, bed)}
                                                    onMouseLeave={handleMouseLeave}
                                                >
                                                    Место {bed.bed_number} - {bed.price_per_night} руб./ночь
                                                </MenuItem>
                                            ))}
                                        </Select>
                                    </FormControl>
                                )}
    
                                <Typography variant="h6" sx={{ mt: 2 }}>
                                    Итого к оплате: {calculateTotalPrice()} руб.
                                </Typography>
                            </Box>
                        )}
                    </>
                )}
    
                <Popover
                    open={Boolean(anchorEl)}
                    anchorEl={anchorEl}
                    onClose={handleMouseLeave}
                    anchorOrigin={{
                        vertical: 'center',
                        horizontal: 'right',
                    }}
                    transformOrigin={{
                        vertical: 'center',
                        horizontal: 'left',
                    }}
                    sx={{
                        pointerEvents: 'none',
                    }}
                >
                    {renderBedImage()}
                </Popover>
            </DialogContent>
            <DialogActions>
                <Button onClick={onClose} color="inherit">
                    Отмена
                </Button>
                <Button
                    onClick={handleSubmit}
                    color="primary"
                    variant="contained"
                    disabled={!user ||
                        !bookingStartDate ||
                        !bookingEndDate ||
                        bookingStartDate === bookingEndDate ||
                        (room?.accommodation_type === 'bed' && !selectedBed)}
                >
                    Забронировать
                </Button>
            </DialogActions>
        </Dialog>
    );
};

export default BookingDialog;

--- Содержимое файла: frontend/hostel-frontend/src/components/AdminPanel.js ---



--- Содержимое файла: frontend/hostel-frontend/src/components/LocationPicker.js ---

import React, { useState, useCallback } from 'react';
import { GoogleMap, LoadScript, Marker } from '@react-google-maps/api';
import {
    Box,
    TextField,
    Paper,
    Typography,
    InputAdornment,
    IconButton,
} from '@mui/material';
import { Search as SearchIcon, MyLocation as MyLocationIcon } from '@mui/icons-material';

const libraries = ["places", "geometry"];

const LocationPicker = ({ onLocationSelect }) => {
    const [map, setMap] = useState(null);
    const [marker, setMarker] = useState(null);
    const [address, setAddress] = useState('');
    const [searchBox, setSearchBox] = useState(null);

    const mapContainerStyle = {
        width: '100%',
        height: '400px'
    };

    const defaultCenter = {
        lat: 45.2671, // Нови-Сад
        lng: 19.8335
    };

    const mapOptions = {
        scrollwheel: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
            style: 'DEFAULT',
            mapTypeIds: ["roadmap", "satellite", "hybrid"]
        },
        streetViewControl: false,
        fullscreenControl: false,
    };

    // Добавьте новую функцию handleLocationSelect перед onMapLoad
    const handleLocationSelect = (location) => {
        const getAddressComponent = (type) => {
            return location.address_components?.find(
                component => component.types.includes(type)
            )?.long_name || '';
        };

        // Получаем номер дома и улицу отдельно
        const streetNumber = getAddressComponent('street_number');
        const route = getAddressComponent('route');

        // Формируем полный адрес улицы с номером дома
        const fullStreetAddress = route
            ? (streetNumber ? `${route}, ${streetNumber}` : route)
            : '';

        // Передаем данные в родительский компонент
        onLocationSelect({
            latitude: location.latitude,
            longitude: location.longitude,
            formatted_address: location.formatted_address,
            // Передаем сформированный адрес с номером дома
            address_components: {
                street: fullStreetAddress || getAddressComponent('sublocality') || '',
                city: getAddressComponent('locality'),
                state: getAddressComponent('administrative_area_level_1'),
                country: getAddressComponent('country'),
                postal_code: getAddressComponent('postal_code')
            }
        });
    };

    const onMapLoad = useCallback((map) => {
        setMap(map);
        // Инициализируем поисковую строку после загрузки карты
        const searchInput = document.getElementById('location-search');
        if (searchInput && window.google) {
            const searchBoxInstance = new window.google.maps.places.SearchBox(searchInput);
            setSearchBox(searchBoxInstance);

            searchBoxInstance.addListener('places_changed', () => {
                const places = searchBoxInstance.getPlaces();
                if (places.length === 0) return;

                const place = places[0];
                if (!place.geometry) return;

                // Центрируем карту на найденном месте
                map.setCenter(place.geometry.location);
                map.setZoom(17);

                // Устанавливаем маркер
                setMarker({
                    lat: place.geometry.location.lat(),
                    lng: place.geometry.location.lng()
                });

                // Обновляем адрес
                setAddress(place.formatted_address);

                // Вызываем обработчик с данными места
                handleLocationSelect({
                    latitude: place.geometry.location.lat(),
                    longitude: place.geometry.location.lng(),
                    formatted_address: place.formatted_address,
                    address_components: place.address_components
                });
            });
        }
    }, [onLocationSelect]);

    const handleMapClick = useCallback((e) => {
        const lat = e.latLng.lat();
        const lng = e.latLng.lng();

        setMarker({ lat, lng });

        if (window.google) {
            const geocoder = new window.google.maps.Geocoder();
            geocoder.geocode(
                { location: { lat, lng } },
                (results, status) => {
                    if (status === 'OK' && results[0]) {
                        const place = results[0];
                        setAddress(place.formatted_address);
                        const location = {
                            latitude: lat,
                            longitude: lng,
                            formatted_address: place.formatted_address,
                            address_components: place.address_components
                        };
                        handleLocationSelect(location);
                    }
                }
            );
        }
    }, []);

    const handleCurrentLocation = () => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;

                    // Центрируем карту и устанавливаем маркер
                    if (map) {
                        map.setCenter({ lat, lng });
                        map.setZoom(17);
                        setMarker({ lat, lng });
                    }

                    // Получаем адрес по координатам
                    if (window.google) {
                        const geocoder = new window.google.maps.Geocoder();
                        geocoder.geocode(
                            { location: { lat, lng } },
                            (results, status) => {
                                if (status === 'OK' && results[0]) {
                                    const place = results[0];
                                    setAddress(place.formatted_address);
                                    handleLocationSelect({
                                        latitude: lat,
                                        longitude: lng,
                                        formatted_address: place.formatted_address,
                                        address_components: place.address_components
                                    });
                                }
                            }
                        );
                    }
                },
                (error) => {
                    console.error("Error getting current location:", error);
                    alert("Не удалось получить текущее местоположение");
                }
            );
        } else {
            alert("Геолокация не поддерживается вашим браузером");
        }
    };

    return (
        <Paper sx={{ p: 2 }}>
            <Typography variant="h6" gutterBottom>
                Выберите местоположение объекта
            </Typography>
            <Box sx={{ mb: 2 }}>
                <TextField
                    id="location-search"
                    fullWidth
                    placeholder="Поиск по адресу..."
                    value={address}
                    onChange={(e) => setAddress(e.target.value)}
                    InputProps={{
                        startAdornment: (
                            <InputAdornment position="start">
                                <SearchIcon />
                            </InputAdornment>
                        ),
                        endAdornment: (
                            <InputAdornment position="end">
                                <IconButton
                                    onClick={handleCurrentLocation}
                                    title="Мое местоположение"
                                >
                                    <MyLocationIcon />
                                </IconButton>
                            </InputAdornment>
                        )
                    }}
                />
            </Box>
            <LoadScript
                googleMapsApiKey={process.env.REACT_APP_GOOGLE_MAPS_API_KEY}
                libraries={libraries}
            >
                <GoogleMap
                    mapContainerStyle={mapContainerStyle}
                    center={defaultCenter}
                    zoom={13}
                    onLoad={onMapLoad}
                    onClick={handleMapClick}
                    options={mapOptions}
                >
                    {marker && (
                        <Marker
                            position={marker}
                            draggable={true}
                            onDragEnd={(e) => handleMapClick(e)}
                        />
                    )}
                </GoogleMap>
            </LoadScript>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Кликните по карте или введите адрес для выбора местоположения
            </Typography>
        </Paper>
    );
};

export default LocationPicker;

--- Содержимое файла: frontend/hostel-frontend/src/components/AddUser.js ---

import React, { useState } from "react";
import { TextField, Button, Container, Typography, Alert } from "@mui/material";
import axios from "../api/axios";
import { useAuth } from "../contexts/AuthContext";

const AddUser = () => {
  const { user } = useAuth();
  const [userForm, setUserForm] = useState({ name: "", email: "" });
  const [error, setError] = useState("");
  const [success, setSuccess] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setSuccess(false);

    if (!user) {
      setError("Необходимо войти в систему");
      return;
    }

    try {
      await axios.post('/users', userForm, {
        withCredentials: true
      });
      setSuccess(true);
      setUserForm({ name: "", email: "" });
    } catch (err) {
      setError(err.response?.data || "Ошибка при добавлении пользователя");
    }
  };

  if (!user) {
    return (
      <Container>
        <Alert severity="warning">
          Для добавления пользователей необходимо войти в систему
        </Alert>
      </Container>
    );
  }

  return (
    <Container>
      <Typography variant="h4" gutterBottom>
        Добавить пользователя
      </Typography>
      {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
      {success && <Alert severity="success" sx={{ mb: 2 }}>Пользователь успешно добавлен!</Alert>}
      <form onSubmit={handleSubmit}>
        <TextField
          label="Имя"
          fullWidth
          margin="normal"
          value={userForm.name}
          onChange={(e) => setUserForm({ ...userForm, name: e.target.value })}
          required
        />
        <TextField
          label="Email"
          type="email"
          fullWidth
          margin="normal"
          value={userForm.email}
          onChange={(e) => setUserForm({ ...userForm, email: e.target.value })}
          required
        />
        <Button 
          type="submit" 
          variant="contained" 
          color="primary"
          sx={{ mt: 2 }}
        >
          Добавить
        </Button>
      </form>
    </Container>
  );
};

export default AddUser;

--- Содержимое файла: frontend/hostel-frontend/src/components/RoomList.js ---

import React, { useState, useEffect, useCallback } from 'react';
import axios from "../api/axios";
import { Chip } from '@mui/material';
import { LoadScript } from '@react-google-maps/api';
import {
    Grid, Card, CardContent, Typography, TextField,
    Button, Divider, Box, Dialog, DialogContent, IconButton,
    MobileStepper, CardMedia,
    ToggleButton,
    ToggleButtonGroup,
    Paper,
    ButtonGroup
} from "@mui/material";
import {
    KeyboardArrowLeft, KeyboardArrowRight,
    Close as CloseIcon,
    SingleBed as HotelIcon,
    Hotel as SingleBedIcon,
    Apartment as ApartmentIcon,
    Home as HomeIcon,
    ViewList as ViewListIcon,
    Map as MapIcon,
    Search as SearchIcon
} from '@mui/icons-material';
import BookingDialog from "./BookingDialog";
import MapView from './MapView';


const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;

const ImageGallery = ({ images, open, onClose }) => {
    const [activeStep, setActiveStep] = useState(0);
    const maxSteps = images.length;

    const handleNext = () => {
        setActiveStep((prevStep) => (prevStep + 1) % maxSteps);
    };

    const handleBack = () => {
        setActiveStep((prevStep) => (prevStep - 1 + maxSteps) % maxSteps);
    };

    if (!images.length) return null;

    return (
        <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
            <DialogContent sx={{ position: 'relative', p: 0 }}>
                <IconButton
                    onClick={onClose}
                    sx={{
                        position: 'absolute',
                        right: 8,
                        top: 8,
                        color: 'white',
                        bgcolor: 'rgba(0, 0, 0, 0.5)',
                        '&:hover': {
                            bgcolor: 'rgba(0, 0, 0, 0.7)',
                        },
                    }}
                >
                    <CloseIcon />
                </IconButton>
                <Box sx={{ height: '80vh', display: 'flex', flexDirection: 'column', justifyContent: 'center' }}>
                    <img
                        src={`${BACKEND_URL}/uploads/${images[activeStep].file_path}`} // Исправлено здесь
                        alt={images[activeStep].file_name}
                        style={{
                            width: '100%',
                            height: '100%',
                            objectFit: 'contain',
                        }}
                    />
                    <MobileStepper
                        steps={maxSteps}
                        position="static"
                        activeStep={activeStep}
                        sx={{
                            bgcolor: 'background.default',
                            position: 'absolute',
                            bottom: 0,
                            width: '100%',
                        }}
                        nextButton={
                            <Button size="small" onClick={handleNext}>
                                Следующее
                                <KeyboardArrowRight />
                            </Button>
                        }
                        backButton={
                            <Button size="small" onClick={handleBack}>
                                <KeyboardArrowLeft />
                                Предыдущее
                            </Button>
                        }
                    />
                </Box>
            </DialogContent>
        </Dialog>
    );
};

const RoomList = () => {
    const [rooms, setRooms] = useState([]);
    const [filters, setFilters] = useState({
        capacity: "",
        min_price: "",
        max_price: "",
        city: "",
        country: "",
        start_date: "",
        end_date: "",
        type: ''
    });

    const handleTypeFilter = (type) => {
        setFilters(prev => ({
            ...prev,
            type: prev.type === type ? '' : type // сброс фильтра при повторном нажатии
        }));
    };


    const [viewMode, setViewMode] = useState('list'); // 'list' или 'map'
    const [roomsWithCoordinates, setRoomsWithCoordinates] = useState([]);
    const geocodeRooms = async (rooms) => {
        if (!window.google) return rooms;

        const geocoder = new window.google.maps.Geocoder();
        const geocodeAddress = async (room) => {
            const address = `${room.address_street}, ${room.address_city}, ${room.address_country}`;
            try {
                const result = await new Promise((resolve, reject) => {
                    geocoder.geocode({ address }, (results, status) => {
                        if (status === 'OK') {
                            resolve(results[0].geometry.location);
                        } else {
                            reject(status);
                        }
                    });
                });

                return {
                    ...room,
                    latitude: result.lat(),
                    longitude: result.lng()
                };
            } catch (error) {
                console.error(`Error geocoding address: ${address}`, error);
                return room;
            }
        };

        const roomsWithCoords = await Promise.all(rooms.map(geocodeAddress));
        return roomsWithCoords;
    };
    const [selectedRoom, setSelectedRoom] = useState(null);
    const [galleryOpen, setGalleryOpen] = useState(false);
    const [bookingDialogOpen, setBookingDialogOpen] = useState(false);

    const fetchRooms = useCallback(async () => {
        try {
            const params = new URLSearchParams();

            // Добавляем базовые параметры
            if (filters.capacity && parseInt(filters.capacity) > 0) {
                params.append('capacity', filters.capacity);
            }
            if (filters.min_price && parseFloat(filters.min_price) > 0) {
                params.append('min_price', filters.min_price);
            }
            if (filters.max_price && parseFloat(filters.max_price) > 0) {
                params.append('max_price', filters.max_price);
            }
            if (filters.city?.trim()) {
                params.append('city', filters.city.trim());
            }
            if (filters.country?.trim()) {
                params.append('country', filters.country.trim());
            }

            // Добавляем фильтр по типу размещения
            if (filters.type) {
                params.append('accommodation_type', filters.type);
                if (filters.type === 'room') {
                    params.append('has_private_rooms', 'true');
                }
            }

            // Всегда отправляем даты для проверки доступности
            const today = new Date().toISOString().split('T')[0];
            params.append('start_date', filters.start_date || today);
            params.append('end_date', filters.end_date || today);

            const response = await axios.get(`/rooms?${params.toString()}`);
            const roomsData = response.data || [];

            // Фильтрация на фронтенде
            const filteredRooms = roomsData.filter(room => {
                // Базовая проверка доступности
                if (room.accommodation_type === 'bed' && room.available_beds <= 0) {
                    return false;
                }

                // Проверка типа размещения
                if (filters.type && room.accommodation_type !== filters.type) {
                    return false;
                }

                // Проверка для приватных комнат
                if (filters.type === 'room' && room.is_shared) {
                    return false;
                }

                return true;
            });

            // Получаем изображения для отфильтрованных комнат
            const roomsWithImages = await Promise.all(
                filteredRooms.map(async (room) => {
                    const imagesResponse = await axios.get(`/rooms/${room.id}/images`);
                    return {
                        ...room,
                        images: imagesResponse.data || []
                    };
                })
            );

            setRooms(roomsWithImages);
            setRoomsWithCoordinates(roomsWithImages.filter(room =>
                room.latitude && room.longitude));

        } catch (error) {
            console.error("Ошибка при получении списка комнат:", error);
        }
    }, [filters]);

    const handleDateChange = (field, value) => {
        setFilters(prev => {
            const newFilters = { ...prev, [field]: value };

            if (field === 'end_date' && newFilters.start_date && value < newFilters.start_date) {
                return prev;
            }

            if (field === 'start_date' && newFilters.end_date && value > newFilters.end_date) {
                return prev;
            }

            return newFilters;
        });
    };

    const handleBooking = (room) => {
        if (!filters.start_date || !filters.end_date) {
            alert('Пожалуйста, выберите даты заезда и выезда');
            return;
        }
        setSelectedRoom(room);
        setBookingDialogOpen(true);
    };

// долой протечки памяти
    useEffect(() => {
        let isSubscribed = true;
        
        const fetchData = async () => {
            try {
                const response = await fetchRooms();
                if (isSubscribed) {
                    setRooms(response.data);
                }
            } catch (error) {
                if (isSubscribed) {
                    console.error(error);
                }
            }
        };
        
        fetchData();
        
        return () => {
            isSubscribed = false;
        };
    }, [fetchRooms]);

    const AccommodationInfo = ({ room }) => {
        const getAccommodationInfo = () => {
            switch (room.accommodation_type) {
                case 'bed':
                    return {
                        title: 'Койко-место',
                        details: `Доступно ${room.available_beds} из ${room.total_beds} мест`,
                        icon: <HotelIcon />,
                        shared: true
                    };
                case 'room':
                    return {
                        title: room.is_shared ? 'Общая комната' : 'Отдельная комната',
                        details: `Вместимость: ${room.capacity} чел.`,
                        icon: <SingleBedIcon />,
                        shared: room.is_shared
                    };
                case 'apartment':
                    return {
                        title: 'Квартира',
                        details: `${room.capacity} комнат`,
                        icon: <ApartmentIcon />,
                        shared: false
                    };
                default:
                    return {
                        title: 'Помещение',
                        details: `Вместимость: ${room.capacity} чел.`,
                        icon: <HomeIcon />,
                        shared: false
                    };
            }
        };

        const info = getAccommodationInfo();

        return (
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                {info.icon}
                <Box>
                    <Typography variant="subtitle2" sx={{ fontWeight: 'medium' }}>
                        {info.title}
                        {info.shared && (
                            <Chip
                                size="small"
                                label="Общее помещение"
                                color="secondary"
                                sx={{ ml: 1 }}
                            />
                        )}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                        {info.details}
                    </Typography>
                </Box>
            </Box>
        );
    };


    const today = new Date().toISOString().split('T')[0];

    return (
        <div>

            <Grid container spacing={2} sx={{ mb: 3, mt: 1 }}>
                {/* Первая строка с датами, городом, страной и ценами */}
                <Grid item container spacing={2} xs={12}>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Дата заезда"
                            type="date"
                            size="small"
                            fullWidth
                            InputLabelProps={{ shrink: true }}
                            value={filters.start_date}
                            onChange={(e) => handleDateChange('start_date', e.target.value)}
                            inputProps={{ min: today }}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Дата выезда"
                            type="date"
                            size="small"
                            fullWidth
                            InputLabelProps={{ shrink: true }}
                            value={filters.end_date}
                            onChange={(e) => handleDateChange('end_date', e.target.value)}
                            inputProps={{ min: filters.start_date || today }}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Город"
                            size="small"
                            fullWidth
                            value={filters.city}
                            onChange={(e) => setFilters({ ...filters, city: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Страна"
                            size="small"
                            fullWidth
                            value={filters.country}
                            onChange={(e) => setFilters({ ...filters, country: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Мин. цена"
                            type="number"
                            size="small"
                            fullWidth
                            value={filters.min_price}
                            onChange={(e) => setFilters({ ...filters, min_price: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Макс. цена"
                            type="number"
                            size="small"
                            fullWidth
                            value={filters.max_price}
                            onChange={(e) => setFilters({ ...filters, max_price: e.target.value })}
                        />
                    </Grid>
                </Grid>

                {/* Вторая строка с кнопками */}
                <Grid item container xs={12} spacing={2} alignItems="center">
                    <Grid item>
                        <Button
                            variant="contained"
                            color="primary"
                            onClick={fetchRooms}
                            startIcon={<SearchIcon />}
                        >
                            Найти
                        </Button>
                    </Grid>
                    <Grid item>
                        <ButtonGroup
                            variant="outlined"
                            sx={{
                                '& .MuiButton-root': {
                                    borderColor: '#1976d2',
                                    '&:hover': {
                                        borderColor: '#1976d2',
                                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                    }
                                }
                            }}
                        >
                            <Button
                                onClick={() => handleTypeFilter('apartment')}
                                startIcon={<ApartmentIcon />}
                                color={filters.type === 'apartment' ? 'primary' : 'inherit'}
                            >
                                Аппарты
                            </Button>
                            <Button
                                onClick={() => handleTypeFilter('room')}
                                startIcon={<HotelIcon />}
                                color={filters.type === 'room' ? 'primary' : 'inherit'}
                            >
                                Приватка
                            </Button>
                            <Button
                                onClick={() => handleTypeFilter('bed')}
                                startIcon={<SingleBedIcon />}
                                color={filters.type === 'bed' ? 'primary' : 'inherit'}
                            >
                                Кровать
                            </Button>
                        </ButtonGroup>
                    </Grid>
                    <Grid item sx={{ marginLeft: 'auto' }}>
                        <ToggleButtonGroup
                            value={viewMode}
                            exclusive
                            onChange={(e, newMode) => newMode && setViewMode(newMode)}
                            aria-label="view mode"
                            size="small"
                            sx={{
                                border: '1px solid rgba(25, 118, 210, 0.5)',
                                '& .MuiToggleButton-root': {
                                    '&.Mui-selected': {
                                        backgroundColor: '#1976d2',
                                        color: 'white',
                                        '&:hover': {
                                            backgroundColor: '#1565c0',
                                        }
                                    },
                                    '&:hover': {
                                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                    }
                                }
                            }}
                        >
                            <ToggleButton value="list" aria-label="list view">
                                <ViewListIcon /> Список
                            </ToggleButton>
                            <ToggleButton value="map" aria-label="map view">
                                <MapIcon /> Карта
                            </ToggleButton>
                        </ToggleButtonGroup>
                    </Grid>
                </Grid>
            </Grid>
            <Box>
                {viewMode === 'map' ? (
                    <LoadScript
                        googleMapsApiKey={process.env.REACT_APP_GOOGLE_MAPS_API_KEY}
                        libraries={["places", "geometry"]}
                    >
                        <MapView
                            rooms={roomsWithCoordinates}
                            onRoomSelect={(room) => {
                                setSelectedRoom(room);
                                setBookingDialogOpen(true);
                            }}
                            onOpenGallery={(room) => {
                                setSelectedRoom(room);
                                setGalleryOpen(true);
                            }}
                        />
                    </LoadScript>
                ) : (
                    <Grid container spacing={2}>
                        {rooms.map((room) => (
                            <Grid item xs={12} md={6} lg={4} key={room.id}>
                                <Card sx={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    height: '100%',
                                    border: '1px solid rgba(25, 118, 210, 0.2)',
                                    boxShadow: '0 2px 4px rgba(25, 118, 210, 0.1)',
                                    '&:hover': {
                                        boxShadow: '0 4px 8px rgba(25, 118, 210, 0.2)',
                                    },
                                    '& .MuiCardContent-root': {
                                        padding: '12px',
                                    },
                                    '& .MuiTypography-root': {
                                        lineHeight: '1.3',
                                    }
                                }}>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', p: 1.5 }}>
                                        <Box sx={{ flex: 1, pr: 1.5 }}>
                                            <AccommodationInfo room={room} />
                                            <Typography variant="h6" sx={{
                                                mb: 0.5,
                                                fontSize: '1.1rem'
                                            }}>
                                                {room.name}
                                            </Typography>
                                            {room.accommodation_type === 'bed' ? (
                                                <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
                                                    Цена за койко-место: {room.price_per_night} евро/сутки
                                                </Typography>
                                            ) : (
                                                <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
                                                    Цена за {room.accommodation_type === 'apartment' ? 'квартиру' : 'комнату'}: {room.price_per_night} евро/сутки
                                                </Typography>
                                            )}
                                        </Box>

                                        {/* Правый верхний угол: эскиз */}
                                        <Box sx={{
                                            width: '100px',
                                            height: '100px',
                                            flexShrink: 0,
                                            p: room.images?.length ? 0 : 1
                                        }}>
                                            {room.images && room.images.length > 0 ? (
                                                <CardMedia
                                                    component="img"
                                                    sx={{
                                                        width: '100%',
                                                        height: '100%',
                                                        objectFit: 'cover',
                                                        borderRadius: '4px',
                                                        '&:hover': {
                                                            opacity: 0.8,
                                                            transition: 'opacity 0.2s ease-in-out',
                                                        },
                                                    }}
                                                    image={`${BACKEND_URL}/uploads/${room.images[0].file_path}`}
                                                    alt={room.name}
                                                    onClick={() => {
                                                        setSelectedRoom(room);
                                                        setGalleryOpen(true);
                                                    }}
                                                />
                                            ) : (
                                                <Box
                                                    sx={{
                                                        width: '100%',
                                                        height: '100%',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        bgcolor: 'grey.100',
                                                        borderRadius: '4px',
                                                        fontSize: '0.8rem'
                                                    }}
                                                >
                                                    <Typography variant="body2" color="text.secondary">
                                                        Нет фото
                                                    </Typography>
                                                </Box>
                                            )}
                                        </Box>
                                    </Box>

                                    <Divider />

                                    {/* Нижняя часть карточки с адресом и кнопками */}
                                    <CardContent sx={{
                                        pt: 1,
                                        pb: '8px !important',
                                        display: 'flex',
                                        justifyContent: 'space-between',
                                        alignItems: 'center'
                                    }}>
                                        <Typography variant="body2" color="text.secondary" sx={{
                                            fontSize: '0.85rem',
                                            flex: 1,
                                            mr: 1
                                        }}>
                                            {room.address_street}
                                            {room.address_city && `, ${room.address_city}`}
                                            {room.address_state && `, ${room.address_state}`}
                                            {room.address_country && `, ${room.address_country}`}
                                            {room.address_postal_code && ` (${room.address_postal_code})`}
                                        </Typography>
                                        <Box sx={{ display: 'flex', gap: 0.5 }}>
                                            {room.images && room.images.length > 1 && (
                                                <Button
                                                    size="small"
                                                    sx={{
                                                        minWidth: 'auto',
                                                        padding: '4px 8px',
                                                        fontSize: '0.8rem',
                                                        borderColor: '#1976d2',
                                                        color: '#1976d2',
                                                        '&:hover': {
                                                            borderColor: '#1565c0',
                                                            backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                                        }
                                                    }}
                                                    onClick={() => {
                                                        setSelectedRoom(room);
                                                        setGalleryOpen(true);
                                                    }}
                                                >
                                                    Все ({room.images.length})
                                                </Button> 
                                            )}
                                            <Button
                                                variant="contained"
                                                color="primary"
                                                size="small"
                                                sx={{
                                                    minWidth: 'auto',
                                                    padding: '4px 8px',
                                                    fontSize: '0.8rem',
                                                    boxShadow: '0 2px 4px rgba(25, 118, 210, 0.2)',
                                                    '&:hover': {
                                                        boxShadow: '0 4px 8px rgba(25, 118, 210, 0.3)',
                                                    }
                                                }}
                                                onClick={() => handleBooking(room)}
                                                disabled={!filters.start_date || !filters.end_date}
                                            >
                                                Забронировать
                                            </Button>
                                        </Box>
                                    </CardContent>
                                </Card>
                            </Grid>

                        ))}
                    </Grid>
                )}
            </Box>
            {selectedRoom && (
                <>
                    <ImageGallery
                        images={selectedRoom.images || []}
                        open={galleryOpen}
                        onClose={() => {
                            setGalleryOpen(false);
                            setSelectedRoom(null);
                        }}
                    />
                    <BookingDialog
                        open={bookingDialogOpen}
                        onClose={() => {
                            setBookingDialogOpen(false);
                            setSelectedRoom(null);
                        }}
                        room={selectedRoom}
                        startDate={filters.start_date}
                        endDate={filters.end_date}
                    />
                </>
            )}
        </div>
    );
};

export default RoomList;

--- Содержимое файла: frontend/hostel-frontend/src/components/AddRoom.js ---

import React, { useState } from "react";
import LocationPicker from './LocationPicker';
import {
    TextField,
    Button,
    Container,
    Typography,
    Box,
    Alert,
    Grid,
    IconButton,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    FormControlLabel,
    Switch
} from "@mui/material";
import { Delete as DeleteIcon, CloudUpload as CloudUploadIcon } from '@mui/icons-material';
import axios from "../api/axios";

const AddRoom = () => {
    const [room, setRoom] = useState({
        name: "",
        accommodation_type: "room",
        capacity: 0,
        price_per_night: 0,
        address_street: "",
        address_city: "",
        address_state: "",
        address_country: "",
        address_postal_code: "",
        is_shared: false,
        total_beds: null,
        available_beds: null,
        has_private_bathroom: true,
        latitude: null,
        longitude: null,
        formatted_address: ''
    });

    const [beds, setBeds] = useState([
        { bed_number: "1", price_per_night: 0, images: [], imagePreviewUrls: [] }
    ]);
    const [images, setImages] = useState([]);
    const [previewUrls, setPreviewUrls] = useState([]);
    const [errorMessage, setErrorMessage] = useState("");
    const [isSuccess, setIsSuccess] = useState(false);

    const handleBedImageChange = (index, e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;

        const validFiles = files.filter(file => {
            if (!file.type.startsWith('image/')) {
                setErrorMessage("Можно загружать только изображения");
                return false;
            }
            if (file.size > 5 * 1024 * 1024) {
                setErrorMessage("Размер файла не должен превышать 5MB");
                return false;
            }
            return true;
        });

        if (validFiles.length === 0) return;

        const newBeds = [...beds];
        newBeds[index] = {
            ...newBeds[index],
            images: [...(newBeds[index].images || []), ...validFiles]
        };

        // Создаем превью для изображений
        validFiles.forEach(file => {
            const reader = new FileReader();
            reader.onloadend = () => {
                newBeds[index].imagePreviewUrls = [
                    ...(newBeds[index].imagePreviewUrls || []),
                    reader.result
                ];
                setBeds([...newBeds]);
            };
            reader.readAsDataURL(file);
        });
    };

    const handleLocationSelect = (location) => {
        setRoom(prev => ({
            ...prev,
            latitude: location.latitude,
            longitude: location.longitude,
            formatted_address: location.formatted_address,
            address_street: location.address_components?.street || '',
            address_city: location.address_components?.city || '',
            address_state: location.address_components?.state || '',
            address_country: location.address_components?.country || '',
            address_postal_code: location.address_components?.postal_code || ''
        }));
    };

    const handleImageChange = (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;

        const validFiles = files.filter(file => {
            if (!file.type.startsWith('image/')) {
                setErrorMessage("Можно загружать только изображения");
                return false;
            }
            if (file.size > 5 * 1024 * 1024) {
                setErrorMessage("Размер файла не должен превышать 5MB");
                return false;
            }
            return true;
        });

        if (validFiles.length === 0) return;

        setImages(prev => [...prev, ...validFiles]);

        validFiles.forEach(file => {
            const reader = new FileReader();
            reader.onloadend = () => {
                setPreviewUrls(prev => [...prev, reader.result]);
            };
            reader.onerror = () => {
                setErrorMessage("Ошибка при чтении файла: " + file.name);
            };
            reader.readAsDataURL(file);
        });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setErrorMessage("");
        setIsSuccess(false);

        try {
            if (room.accommodation_type === 'bed' && (!room.total_beds || beds.length === 0)) {
                setErrorMessage("Добавьте информацию о кроватях");
                return;
            }

            const roomData = {
                ...room,
                latitude: parseFloat(room.latitude),
                longitude: parseFloat(room.longitude)
            };

            // Создаем комнату
            const roomResponse = await axios.post("/rooms", roomData);
            const roomId = roomResponse.data.id;

            // Если тип размещения - койко-места, создаем кровати и загружаем их изображения
            if (room.accommodation_type === 'bed' && beds.length > 0) {
                await Promise.all(
                    beds.map(async (bed) => {
                        try {
                            // Создаем койко-место
                            const bedResponse = await axios.post(`/rooms/${roomId}/beds`, {
                                bed_number: bed.bed_number,
                                price_per_night: parseFloat(bed.price_per_night)
                            });

                            // Если есть изображения для койко-места, загружаем их
                            if (bed.images && bed.images.length > 0) {
                                const formData = new FormData();
                                bed.images.forEach(image => {
                                    formData.append('images', image);
                                });

                                await axios.post(`/beds/${bedResponse.data.id}/images`, formData, {
                                    headers: {
                                        'Content-Type': 'multipart/form-data'
                                    }
                                });
                            }
                        } catch (error) {
                            console.error('Ошибка добавления кровати или её изображений:', error);
                            throw error;
                        }
                    })
                );
            }

            // Загружаем общие изображения комнаты
            if (images.length > 0) {
                const formData = new FormData();
                images.forEach(image => {
                    formData.append('images', image);
                });

                await axios.post(`/rooms/${roomId}/images`, formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                });
            }

            setIsSuccess(true);
            // Сброс формы
            setRoom({
                name: "",
                accommodation_type: "room",
                capacity: 0,
                price_per_night: 0,
                address_street: "",
                address_city: "",
                address_state: "",
                address_country: "",
                address_postal_code: "",
                is_shared: false,
                total_beds: null,
                available_beds: null,
                has_private_bathroom: true,
                latitude: null,
                longitude: null,
                formatted_address: ''
            });
            setBeds([{ bed_number: "1", price_per_night: 0, images: [], imagePreviewUrls: [] }]);
            setImages([]);
            setPreviewUrls([]);
        } catch (error) {
            console.error('Ошибка при добавлении:', error);
            setErrorMessage(error.response?.data || "Ошибка при добавлении объекта размещения");
        }
    };

    return (
        <Container>
            <Typography variant="h4" gutterBottom>
                Добавить объект размещения
            </Typography>
            {errorMessage && (
                <Alert severity="error" sx={{ mb: 2 }}>
                    {errorMessage}
                </Alert>
            )}
            {isSuccess && (
                <Alert severity="success" sx={{ mb: 2 }}>
                    Объект размещения успешно добавлен
                </Alert>
            )}
            <form onSubmit={handleSubmit}>
                <Grid container spacing={2}>
                    {/* Базовая информация */}
                    <Grid item xs={12}>
                        <TextField
                            label="Название"
                            fullWidth
                            required
                            value={room.name}
                            onChange={(e) => setRoom({ ...room, name: e.target.value })}
                        />
                    </Grid>

                    {/* Тип размещения */}
                    <Grid item xs={12}>
                        <FormControl fullWidth>
                            <InputLabel>Тип размещения</InputLabel>
                            <Select
                                value={room.accommodation_type}
                                onChange={(e) => {
                                    const newType = e.target.value;
                                    setRoom(prev => ({
                                        ...prev,
                                        accommodation_type: newType,
                                        total_beds: newType === 'bed' ? prev.total_beds : null,
                                        available_beds: newType === 'bed' ? prev.available_beds : null,
                                        is_shared: newType === 'bed' ? true : false,
                                    }));
                                }}
                            >
                                <MenuItem value="bed">Койко-место</MenuItem>
                                <MenuItem value="room">Комната</MenuItem>
                                <MenuItem value="apartment">Квартира</MenuItem>
                            </Select>
                        </FormControl>
                    </Grid>

                    {room.accommodation_type === 'bed' ? (
                        <>
                            <Grid item xs={12} md={6}>
                                <TextField
                                    label="Всего кроватей"
                                    type="number"
                                    fullWidth
                                    required
                                    value={room.total_beds || ''}
                                    onChange={(e) => setRoom({
                                        ...room,
                                        total_beds: parseInt(e.target.value) || 0,
                                        available_beds: parseInt(e.target.value) || 0
                                    })}
                                />
                            </Grid>
                            <Grid item xs={12}>
                                {beds.map((bed, index) => (
                                    <Box key={index} sx={{ display: 'flex', gap: 2, mb: 2 }}>
                                        <TextField
                                            label={`Номер кровати ${index + 1}`}
                                            value={bed.bed_number}
                                            onChange={(e) => {
                                                const newBeds = [...beds];
                                                newBeds[index].bed_number = e.target.value;
                                                setBeds(newBeds);
                                            }}
                                        />
                                        <TextField
                                            label="Цена за ночь"
                                            type="number"
                                            value={bed.price_per_night}
                                            onChange={(e) => {
                                                const newBeds = [...beds];
                                                newBeds[index].price_per_night = parseFloat(e.target.value);
                                                setBeds(newBeds);
                                            }}
                                        />
                                        <Box>
                                            <Button
                                                variant="contained"
                                                component="label"
                                                size="small"
                                            >
                                                Фото кровати
                                                <input
                                                    type="file"
                                                    hidden
                                                    multiple
                                                    accept="image/*"
                                                    onChange={(e) => handleBedImageChange(index, e)}
                                                />
                                            </Button>
                                            {bed.imagePreviewUrls && bed.imagePreviewUrls.length > 0 && (
                                                <Box sx={{ mt: 1, display: 'flex', gap: 1 }}>
                                                    {bed.imagePreviewUrls.map((url, imgIndex) => (
                                                        <Box
                                                            key={imgIndex}
                                                            sx={{
                                                                position: 'relative',
                                                                width: 60,
                                                                height: 60
                                                            }}
                                                        >
                                                            <img
                                                                src={url}
                                                                alt={`Preview ${imgIndex}`}
                                                                style={{
                                                                    width: '100%',
                                                                    height: '100%',
                                                                    objectFit: 'cover',
                                                                    borderRadius: '4px'
                                                                }}
                                                            />
                                                            <IconButton
                                                                size="small"
                                                                sx={{
                                                                    position: 'absolute',
                                                                    top: -8,
                                                                    right: -8,
                                                                    bgcolor: 'background.paper'
                                                                }}
                                                                onClick={() => {
                                                                    const newBeds = [...beds];
                                                                    newBeds[index].images.splice(imgIndex, 1);
                                                                    newBeds[index].imagePreviewUrls.splice(imgIndex, 1);
                                                                    setBeds(newBeds);
                                                                }}
                                                            >
                                                                <DeleteIcon fontSize="small" />
                                                            </IconButton>
                                                        </Box>
                                                    ))}
                                                </Box>
                                            )}
                                        </Box>
                                        <IconButton onClick={() => {
                                            const newBeds = [...beds];
                                            newBeds.splice(index, 1);
                                            setBeds(newBeds);
                                        }}>
                                            <DeleteIcon />
                                        </IconButton>
                                    </Box>
                                ))}

                                <Button
                                    variant="outlined"
                                    onClick={() => setBeds([...beds, { bed_number: `${beds.length + 1}`, price_per_night: 0 }])}
                                >
                                    Добавить кровать
                                </Button>
                            </Grid>
                        </>
                    ) : (
                        <>
                            <Grid item xs={12} md={6}>
                                <TextField
                                    label="Вместимость"
                                    type="number"
                                    fullWidth
                                    required
                                    value={room.capacity}
                                    onChange={(e) => setRoom({ ...room, capacity: parseInt(e.target.value) || 0 })}
                                />
                            </Grid>
                            <Grid item xs={12} md={6}>
                                <TextField
                                    label="Цена за ночь"
                                    type="number"
                                    fullWidth
                                    required
                                    value={room.price_per_night}
                                    onChange={(e) => setRoom({ ...room, price_per_night: parseFloat(e.target.value) || 0 })}
                                />
                            </Grid>
                        </>
                    )}

                    <Grid item xs={12}>
                        <FormControlLabel
                            control={
                                <Switch
                                    checked={room.is_shared}
                                    onChange={(e) => setRoom({ ...room, is_shared: e.target.checked })}
                                />
                            }
                            label="Общее помещение"
                        />
                    </Grid>

                    <Grid item xs={12}>
                        <FormControlLabel
                            control={
                                <Switch
                                    checked={room.has_private_bathroom}
                                    onChange={(e) => setRoom({ ...room, has_private_bathroom: e.target.checked })}
                                />
                            }
                            label="Отдельная ванная комната"
                        />
                    </Grid>

                    {/* Выбор местоположения */}
                    <Grid item xs={12}>
                        <LocationPicker onLocationSelect={handleLocationSelect} />
                    </Grid>

                    {/* Адрес */}
                    <Grid item xs={12}>
                        <Typography variant="h6">Адрес</Typography>
                    </Grid>
                    <Grid item xs={12}>
                        <TextField
                            label="Улица"
                            fullWidth
                            required
                            value={room.address_street}
                            onChange={(e) => setRoom({ ...room, address_street: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Город"
                            fullWidth
                            required
                            value={room.address_city}
                            onChange={(e) => setRoom({ ...room, address_city: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Область/Регион"
                            fullWidth
                            value={room.address_state}
                            onChange={(e) => setRoom({ ...room, address_state: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Страна"
                            fullWidth
                            required
                            value={room.address_country}
                            onChange={(e) => setRoom({ ...room, address_country: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Почтовый индекс"
                            fullWidth
                            value={room.address_postal_code}
                            onChange={(e) => setRoom({ ...room, address_postal_code: e.target.value })}
                        />
                    </Grid>

                    {/* Изображения */}
                    <Grid item xs={12}>
                        <Typography variant="h6">Фотографии</Typography>
                        <Box sx={{ mt: 1, mb: 2 }}>
                            <Button
                                variant="contained"
                                component="label"
                                startIcon={<CloudUploadIcon />}
                            >
                                Загрузить изображения
                                <input
                                    type="file"
                                    hidden
                                    multiple
                                    accept="image/*"
                                    onChange={handleImageChange}
                                />
                            </Button>
                        </Box>
                        <Grid container spacing={2}>
                            {previewUrls.map((url, index) => (
                                <Grid item xs={12} sm={4} key={index}>
                                    <Box sx={{ position: 'relative' }}>
                                        <img
                                            src={url}
                                            alt={`Preview ${index}`}
                                            style={{
                                                width: '100%',
                                                height: '200px',
                                                objectFit: 'cover',
                                                borderRadius: '4px'
                                            }}
                                        />
                                        <IconButton
                                            sx={{
                                                position: 'absolute',
                                                top: 8,
                                                right: 8,
                                                bgcolor: 'rgba(255, 255, 255, 0.8)'
                                            }}
                                            onClick={() => {
                                                setImages(prev => prev.filter((_, i) => i !== index));
                                                setPreviewUrls(prev => prev.filter((_, i) => i !== index));
                                            }}
                                        >
                                            <DeleteIcon />
                                        </IconButton>
                                    </Box>
                                </Grid>
                            ))}
                        </Grid>
                    </Grid>

                    <Grid item xs={12}>
                        <Button
                            type="submit"
                            variant="contained"
                            color="primary"
                            fullWidth
                            size="large"
                            disabled={!room.name ||
                                !room.latitude ||
                                !room.longitude ||
                                !room.address_city ||
                                !room.address_country ||
                                (room.accommodation_type === 'bed' && (!room.total_beds || beds.length === 0))}
                        >
                            Добавить
                        </Button>
                    </Grid>
                </Grid>
            </form>
        </Container>
    );
};

export default AddRoom;

--- Содержимое файла: frontend/hostel-frontend/src/components/Layout.js ---

import React from "react";
import { Link } from "react-router-dom";
import { 
  AppBar, 
  Toolbar, 
  Typography, 
  Button, 
  Avatar,
  Menu,
  MenuItem,
  Box,
} from "@mui/material";
import { useAuth } from "../contexts/AuthContext";

const Layout = ({ children }) => {
  const { user, login, logout } = useAuth();
  const [anchorEl, setAnchorEl] = React.useState(null);

  const handleMenu = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  return (
    <Box>
      <AppBar position="static">
        <Toolbar>
          <Typography
            variant="h6"
            component={Link}
            to="/"
            sx={{
              flexGrow: 1,
              textDecoration: 'none',
              color: 'inherit'
            }}
          >
            Hostel Booking System
          </Typography>

          {user ? (
            <>
              <Button
                color="inherit"
                component={Link}
                to="/bookings"
              >
                Все бронирования
              </Button>
              <Button
                color="inherit"
                component={Link}
                to="/add-room"
              >
                Добавить объявление
              </Button>

              <Box 
                onClick={handleMenu}
                sx={{ 
                  display: 'flex',
                  alignItems: 'center',
                  ml: 2,
                  cursor: 'pointer'
                }}
              >
                <Avatar
                  sx={{ 
                    width: 32,
                    height: 32,
                    bgcolor: 'primary.dark'
                  }}
                >
                  {user.name.charAt(0)}
                </Avatar>
              </Box>
              <Menu
                id="menu-appbar"
                anchorEl={anchorEl}
                anchorOrigin={{
                  vertical: 'bottom',
                  horizontal: 'right',
                }}
                keepMounted
                transformOrigin={{
                  vertical: 'top',
                  horizontal: 'right',
                }}
                open={Boolean(anchorEl)}
                onClose={handleClose}
              >
                <MenuItem disabled>
                  <Typography variant="body2">{user.email}</Typography>
                </MenuItem>
                <MenuItem onClick={logout}>Выйти</MenuItem>
              </Menu>
            </>
          ) : (
            <Button 
              color="inherit"
              onClick={login}
            >
              ВОЙТИ ЧЕРЕЗ GOOGLE
            </Button>
          )}
        </Toolbar>
      </AppBar>
      {children}
    </Box>
  );
};

export default Layout;

--- Содержимое файла: frontend/hostel-frontend/src/components/BookingsList.js ---

import React, { useState, useEffect } from 'react';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    Typography,
    Chip,
    Box
} from '@mui/material';
import {
    Apartment as ApartmentIcon,
    Hotel as HotelIcon,
    SingleBed as SingleBedIcon
} from '@mui/icons-material';
import axios from '../api/axios';

const BookingsList = () => {
    const [bookings, setBookings] = useState([]);

    useEffect(() => {
        const fetchBookings = async () => {
            try {
                const response = await axios.get('/bookings', { withCredentials: true });
                setBookings(response.data);
            } catch (error) {
                console.error('Ошибка получения списка бронирований:', error);
            }
        };

        fetchBookings();
    }, []);

    const getAccommodationIcon = (type) => {
        switch (type) {
            case 'bed':
                return <SingleBedIcon color="primary" />;
            case 'room':
                return <HotelIcon color="primary" />;
            case 'apartment':
                return <ApartmentIcon color="primary" />;
            default:
                return null;
        }
    };

    const formatDate = (dateString) => {
        return new Date(dateString).toLocaleDateString('ru-RU', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit'
        });
    };

    return (
        <Box>
            <Typography variant="h5" gutterBottom>
                Список бронирований
            </Typography>
            <TableContainer component={Paper}>
                <Table>
                    <TableHead>
                        <TableRow>
                            <TableCell>Тип размещения</TableCell>
                            <TableCell>Комната</TableCell>
                            <TableCell>Клиент</TableCell>
                            <TableCell>Даты проживания</TableCell>
                            <TableCell>Статус</TableCell>
                        </TableRow>
                    </TableHead>
                    <TableBody>
                        {bookings.map((booking) => (
                            <TableRow key={booking.id} hover>
                                <TableCell>
                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                        {getAccommodationIcon(booking.type)}
                                        <Typography variant="body2">
                                            {booking.type === 'bed' 
                                                ? 'Койко-место' 
                                                : booking.type === 'room' 
                                                    ? 'Комната' 
                                                    : 'Квартира'}
                                        </Typography>
                                    </Box>
                                </TableCell>
                                <TableCell>
                                    <Typography variant="body2">
                                        {booking.room_name}
                                        {booking.bed_id && (
                                            <Typography variant="caption" display="block" color="text.secondary">
                                                Место {booking.bed_id}
                                            </Typography>
                                        )}
                                    </Typography>
                                </TableCell>
                                <TableCell>
                                    <Typography variant="body2">
                                        {booking.user_name}
                                        <Typography variant="caption" display="block" color="text.secondary">
                                            {booking.user_email}
                                        </Typography>
                                    </Typography>
                                </TableCell>
                                <TableCell>
                                    <Box>
                                        <Typography variant="body2">
                                            {`${formatDate(booking.start_date)} - ${formatDate(booking.end_date)}`}
                                        </Typography>
                                        <Typography variant="caption" color="text.secondary">
                                            {Math.ceil(
                                                (new Date(booking.end_date) - new Date(booking.start_date)) / 
                                                (1000 * 60 * 60 * 24)
                                            )} дней
                                        </Typography>
                                    </Box>
                                </TableCell>
                                <TableCell>
                                    <Chip
                                        size="small"
                                        label={booking.status === 'confirmed' ? 'Подтверждено' : 'В обработке'}
                                        color={booking.status === 'confirmed' ? 'success' : 'warning'}
                                    />
                                </TableCell>
                            </TableRow>
                        ))}
                    </TableBody>
                </Table>
            </TableContainer>
        </Box>
    );
};

export default BookingsList;

--- Содержимое файла: frontend/hostel-frontend/src/contexts/AuthContext.js ---

import React, { createContext, useState, useContext, useEffect } from 'react';
import axios from '../api/axios';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const checkAuth = async () => {
    try {
      const response = await axios.get('/auth/session', { withCredentials: true });
      if (response.data.authenticated) {
        setUser(response.data.user);
      }
    } catch (error) {
      console.error('Auth check failed:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    checkAuth();
  }, []);

  const login = () => {
    window.location.href = `${process.env.REACT_APP_BACKEND_URL}/auth/google`;
  };

  const logout = async () => {
    try {
      await axios.get('/auth/logout', { withCredentials: true });
      setUser(null);
    } catch (error) {
      console.error('Logout failed:', error);
    }
  };

  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

--- Содержимое файла: frontend/hostel-frontend/src/pages/AddBookingPage.js ---

import React from "react";
import AddBooking from "../components/AddBooking";

const AddBookingPage = () => <AddBooking />;

export default AddBookingPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/AddRoomPage.js ---

import React from "react";
import AddRoom from "../components/AddRoom";

const AddRoomPage = () => <AddRoom />;

export default AddRoomPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/AddUserPage.js ---

import React from "react";
import AddUser from "../components/AddUser";

const AddUserPage = () => <AddUser />;

export default AddUserPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/HomePage.js ---

import React from "react";
import { Container } from "@mui/material";
import RoomList from "../components/RoomList";

const HomePage = () => (
  <Container sx={{ marginTop: 4 }}>
    <RoomList />
  </Container>
);

export default HomePage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/BookingsListPage.js ---

// frontend/hostel-frontend/src/pages/BookingsListPage.js
import React from 'react';
import { Container } from '@mui/material';
import BookingsList from '../components/BookingsList';

const BookingsListPage = () => {
  return (
    <Container sx={{ mt: 4 }}>
      <BookingsList />
    </Container>
  );
};

export default BookingsListPage;

--- Содержимое файла: frontend/hostel-frontend/src/pages/BookRoomPage.js ---



--- Содержимое файла: frontend/hostel-frontend/src/pages/AdminPanelPage.js ---

import React from "react";
import AddRoom from "../components/AddRoom";
import AddUser from "../components/AddUser";
import AddBooking from "../components/AddBooking";

const AdminPanelPage = () => (
  <div>
    <h1>Админ-панель</h1>
    <AddRoom />
    <AddUser />
    <AddBooking />
  </div>
);

export default AdminPanelPage;


--- Содержимое файла: frontend/hostel-frontend/.env ---

REACT_APP_GOOGLE_MAPS_API_KEY=AIzaSyBISWAfMMEdWSIKL9WASQIWeKbSQo4Dv48
REACT_APP_API_URL=https://landhub.rs/api
REACT_APP_BACKEND_URL=https://landhub.rs

--- Содержимое файла: frontend/hostel-frontend/.env.local ---

REACT_APP_API_URL=http://localhost:3000
REACT_APP_BACKEND_URL=http://localhost:3000



tw=Z3Y733JX5KN65B5D8ZXJ1EDD
GOOGLE_CLIENT_ID=917315728307-au9ga5fl7o3bbid9nv7e4l92gut194pq.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
GOOGLE_OAUTH_REDIRECT_URL=http://localhost:3000/auth/google/callback
FRONTEND_URL=http://localhost:3001
PORT=3000

--- Содержимое файла: frontend/hostel-frontend/.gitignore ---

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*
.env.local
.env.development.local
.env.test.local
.env.production.local


--- Содержимое файла: frontend/hostel-frontend/package.json ---

{
  "name": "hostel-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@mui/icons-material": "^5.15.0",
    "@mui/material": "^5.16.7",
    "@react-google-maps/api": "^2.19.3",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.7.7",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.28.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

--- Содержимое файла: .gitignore ---

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local


npm-debug.log*
yarn-debug.log*
yarn-error.log*
# Node.js
node_modules/
build/
dist/
.cache/

# SSL certificates and related files
/certbot/

# Uploads directory
/backend/uploads/

# Editor files
.vscode/
.idea/
.DS_Store

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
collected_content.txt

# Build directories
/frontend/hostel-frontend/build/
/frontend/hostel-frontend/node_modules/

--- Содержимое файла: deploy.sh ---

#!/bin/bash
set -e  # Останавливаем выполнение при ошибках

echo "Starting deployment..."

# Переходим в папку проекта
cd /opt/hostel-booking-system

# Настраиваем git pull strategy
echo "Configuring git..."
git config pull.rebase false

# Создаем необходимые директории
echo "Creating required directories..."
mkdir -p backend/uploads
mkdir -p frontend/hostel-frontend/build
mkdir -p certbot/conf
mkdir -p certbot/www

# Сохраняем важные файлы
echo "Backing up environment files and SSL certificates..."
mkdir -p /tmp/hostel-backup
cp -f backend/.env /tmp/hostel-backup/backend.env 2>/dev/null || true
cp -f frontend/hostel-frontend/.env /tmp/hostel-backup/frontend.env 2>/dev/null || true

# Сохраняем SSL сертификаты
if [ -d "certbot/conf" ]; then
    cp -r certbot/conf /tmp/hostel-backup/ 2>/dev/null || true
fi

# Сохраняем загруженные изображения
cp -r backend/uploads /tmp/hostel-backup/ 2>/dev/null || true

# Обеспечиваем чистое состояние git
echo "Resetting git state..."
git fetch origin
git reset --hard origin/main
git clean -fdx -e "*.env*" -e "uploads/" -e "certbot/"

# Восстанавливаем файлы
echo "Restoring backups..."
cp -f /tmp/hostel-backup/backend.env backend/.env 2>/dev/null || true
cp -f /tmp/hostel-backup/frontend.env frontend/hostel-frontend/.env 2>/dev/null || true
if [ -d "/tmp/hostel-backup/conf" ]; then
    rm -rf certbot/conf
    cp -r /tmp/hostel-backup/conf certbot/ 2>/dev/null || true
fi

# Собираем фронтенд
echo "Building frontend..."
cd frontend/hostel-frontend
NODE_ENV=production docker run -v $(pwd):/app -w /app node:18 sh -c "npm install --legacy-peer-deps && npm install @babel/plugin-proposal-private-property-in-object && npm run build"
cd ../..

# Останавливаем все контейнеры
echo "Stopping all containers..."
docker-compose -f docker-compose.prod.yml down -v

# Создаем сеть если её нет
docker network create hostel-booking-system_hostel_network 2>/dev/null || true

# Запускаем только базу данных
echo "Starting database..."
docker-compose -f docker-compose.prod.yml up -d db

# Функция для проверки готовности базы данных
check_db() {
    echo "Checking database connection..."
    docker-compose -f docker-compose.prod.yml exec -T db pg_isready -U postgres
}

# Ждем готовности базы данных
echo "Waiting for database to start..."
for i in {1..30}; do
    if check_db > /dev/null 2>&1; then
        echo "Database is ready!"
        break
    fi
    echo "Waiting for database... Attempt $i/30"
    sleep 2
done

# Проверяем финальную готовность
if ! check_db > /dev/null 2>&1; then
    echo "Database failed to start"
    exit 1
fi

# Выполняем миграции
echo "Running migrations..."
docker run --rm \
    --network hostel-booking-system_hostel_network \
    -v $(pwd)/backend/migrations:/migrations \
    migrate/migrate \
    -path=/migrations/ \
    -database="postgres://postgres:c9XWc7Cm@db:5432/hostel_db?sslmode=disable" \
    up

# Проверяем результат миграций
if [ $? -eq 0 ]; then
    echo "Migrations successful! Starting other services..."
    
    # Запускаем остальные сервисы
    docker-compose -f docker-compose.prod.yml up -d

    # Проверяем структуру базы данных
    echo "Checking database structure..."
    sleep 5
    docker-compose -f docker-compose.prod.yml exec -T db psql -U postgres -d hostel_db -c "\dt"
    
    echo "Checking container status..."
    docker-compose -f docker-compose.prod.yml ps
else
    echo "Migration failed!"
    exit 1
fi

# Устанавливаем права на директории
echo "Setting permissions..."
chmod -R 755 backend/uploads || true
chmod -R 755 frontend/hostel-frontend/build || true
chmod -R 755 certbot/conf || true

# Удаляем бэкапы
rm -rf /tmp/hostel-backup

echo "Deployment completed!"

--- Содержимое файла: docker-compose.prod.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    container_name: hostel_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: c9XWc7Cm
      POSTGRES_DB: hostel_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - hostel_network

  backend:
    build: ./backend
    container_name: hostel_backend
    env_file:
        - ./backend/.env
    networks:
        - hostel_network
    environment:
      - DATABASE_URL=postgres://postgres:c9XWc7Cm@db:5432/hostel_db?sslmode=disable
    volumes:
      - ./backend/uploads:/app/uploads
    depends_on:
      - db

  nginx:
    image: nginx:alpine
    container_name: hostel_nginx
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf
      - ./frontend/hostel-frontend/build:/usr/share/nginx/html:ro
      - ./backend/uploads:/usr/share/nginx/uploads
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - backend
    networks:
      - hostel_network
    command: "/bin/sh -c 'while :; do sleep 6h & wait $${!}; nginx -s reload; done & nginx -g \"daemon off;\"'"

  certbot:
    image: certbot/certbot
    container_name: hostel_certbot
    volumes:
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew; sleep 12h & wait $${!}; done;'"
    networks:
      - hostel_network

volumes:
  postgres_data:

networks:
  hostel_network:
    driver: bridge

--- Содержимое файла: docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    container_name: hostel_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build:
      context: ./backend
    ports:
      - "3000:3000"
    env_file:
      - ./backend/.env.local
    depends_on:
      - db
    volumes:
      - ./backend/uploads:/app/uploads
    environment:
      - UPLOAD_DIR=/app/uploads
      
  migrate:
    image: migrate/migrate
    volumes:
      - ./backend/migrations:/migrations
    command: [
      "-path", "/migrations",
      "-database", "postgres://postgres:password@db:5432/hostel_db?sslmode=disable",
      "up"
    ]
    depends_on:
      - db

volumes:
  postgres_data:


--- Содержимое файла: init-ssl.sh ---

#!/bin/bash

# Определяем пути
PROJECT_DIR="/opt/hostel-booking-system"
cd $PROJECT_DIR

# Создаем необходимые директории
mkdir -p certbot/conf
mkdir -p certbot/www

# Создаем временный nginx.conf для первоначальной настройки
cat > nginx.initial.conf << 'EOF'
upstream api_backend {
    server hostel_backend:3000;
}

server {
    listen 80;
    server_name landhub.rs www.landhub.rs;
    
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
        try_files $uri =404;
    }

    location / {
        return 200 'OK';
        add_header Content-Type text/plain;
    }
}
EOF

# Останавливаем существующие контейнеры
docker-compose -f docker-compose.prod.yml down

# Временно подменяем nginx.conf
cp nginx.conf nginx.conf.backup || true
cp nginx.initial.conf nginx.conf

# Запускаем nginx для первоначальной проверки домена
docker-compose -f docker-compose.prod.yml up -d nginx

# Ждем запуска nginx
sleep 10

echo "Attempting to get SSL certificate..."

# Получаем SSL сертификат с подробным выводом
docker-compose -f docker-compose.prod.yml run --rm certbot certbot certonly \
    --webroot \
    --webroot-path=/var/www/certbot \
    --email admin@landhub.rs \
    --agree-tos \
    --no-eff-email \
    -d landhub.rs \
    -d www.landhub.rs \
    --force-renewal \
    --verbose

# Проверяем, были ли созданы сертификаты
if [ -d "certbot/conf/live/landhub.rs" ]; then
    echo "Certificates successfully obtained!"
    
    # Восстанавливаем оригинальный nginx.conf
    mv nginx.conf.backup nginx.conf
    
    # Перезапускаем все контейнеры
    docker-compose -f docker-compose.prod.yml down
    docker-compose -f docker-compose.prod.yml up -d
else
    echo "Failed to obtain certificates!"
    # Восстанавливаем конфигурацию
    if [ -f nginx.conf.backup ]; then
        mv nginx.conf.backup nginx.conf
    fi
fi

# Удаляем временный конфиг
rm -f nginx.initial.conf

echo "SSL initialization completed!"

--- Содержимое файла: nginx.conf ---

upstream api_backend {
    server hostel_backend:3000;
}

# Редирект с HTTP на HTTPS
server {
    listen 80;
    server_name landhub.rs www.landhub.rs;
    
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        return 301 https://$host$request_uri;
    }
}

# Основной HTTPS сервер
server {
    listen 443 ssl;
    server_name landhub.rs www.landhub.rs;
    
    ssl_certificate /etc/letsencrypt/live/landhub.rs/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/landhub.rs/privkey.pem;
    
    # Оптимизация SSL
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
        add_header Cache-Control "no-cache";
    }

    location /api/ {
        rewrite ^/api/(.*) /$1 break;
        proxy_pass http://api_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;
        proxy_cache_bypass $http_upgrade;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /uploads/ {
        alias /usr/share/nginx/uploads/;
        add_header Cache-Control "no-cache";
    }

    location = /favicon.ico {
        access_log off;
        log_not_found off;
    }

    location = /robots.txt {
        access_log off;
        log_not_found off;
    }
}

--- Содержимое файла: package.json ---

{
  "name": "hostel-booking-system",
  "version": "1.0.0",
  "description": "Hostel booking system with React frontend and Go backend",
  "private": true,
  "workspaces": [
    "frontend/*"
  ],
  "scripts": {
    "start": "cd frontend/hostel-frontend && npm start",
    "build": "cd frontend/hostel-frontend && npm run build"
  }
}


