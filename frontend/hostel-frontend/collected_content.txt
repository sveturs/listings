--- Содержимое файла: backend/main.go ---

package main

import (
	"context"
	"fmt"
	"log"
	"mime/multipart"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/disintegration/imaging"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/jackc/pgx/v5/pgxpool"
)

type RoomImage struct {
	ID          int       `json:"id"`
	RoomID      int       `json:"room_id"`
	FilePath    string    `json:"file_path"`
	FileName    string    `json:"file_name"`
	FileSize    int       `json:"file_size"`
	ContentType string    `json:"content_type"`
	IsMain      bool      `json:"is_main"`
	CreatedAt   time.Time `json:"created_at"` 
}

func main() {
	app := fiber.New()

	app.Use(cors.New(cors.Config{
		AllowOrigins:     "http://192.168.100.14:3001,http://192.168.100.14:3000",
		AllowMethods:     "GET,POST,DELETE,PUT",
		AllowHeaders:     "Origin, Content-Type, Accept",
		ExposeHeaders:    "Content-Length",
		AllowCredentials: true,
	}))

	os.MkdirAll("./uploads", os.ModePerm)
	// Подключение к базе данных
	dbURL := os.Getenv("DATABASE_URL")
	pool, err := pgxpool.New(context.Background(), dbURL)
	if err != nil {
		log.Fatalf("Ошибка подключения к базе данных: %v", err)
	}
	defer pool.Close()
	processImage := func(file *multipart.FileHeader) (string, error) {
		src, err := file.Open()
		if err != nil {
			return "", err
		}
		defer src.Close()

		//  уникальное имя файла
		ext := filepath.Ext(file.Filename)
		fileName := fmt.Sprintf("%d%s", time.Now().UnixNano(), ext)
		filePath := filepath.Join("uploads", fileName)

		//  файл для сохранения
		dst, err := os.Create(filePath)
		if err != nil {
			return "", err
		}
		defer dst.Close()

		//  изображение для обработки
		img, err := imaging.Decode(src)
		if err != nil {
			return "", err
		}

		// Изменяем размер изображения (например, максимальная ширина 1200px)
		resized := imaging.Resize(img, 1200, 0, imaging.Lanczos)

		//    обработанное изображение
		err = imaging.Save(resized, filePath)
		if err != nil {
			return "", err
		}

		return fileName, nil
	}
	// Удаление бронирования комнаты
	app.Delete("/rooms/:roomId/bookings/:bookingId", func(c *fiber.Ctx) error {
		bookingID := c.Params("bookingId")
		_, err := pool.Exec(context.Background(), "DELETE FROM bookings WHERE id = $1", bookingID)
		if err != nil {
			return c.Status(500).SendString("Ошибка удаления бронирования")
		}
		return c.SendString("Бронирование удалено")
	})

	// Удаление бронирования койко-места
	app.Delete("/beds/:bedId/bookings/:bookingId", func(c *fiber.Ctx) error {
		bookingID := c.Params("bookingId")
		_, err := pool.Exec(context.Background(), "DELETE FROM bed_bookings WHERE id = $1", bookingID)
		if err != nil {
			return c.Status(500).SendString("Ошибка удаления бронирования")
		}
		return c.SendString("Бронирование удалено")
	})
	//  эндпоинт для загрузки изображений
	app.Post("/rooms/:id/images", func(c *fiber.Ctx) error {
		log.Printf("Начало загрузки изображений")
		roomID, err := strconv.Atoi(c.Params("id"))
		if err != nil {
			log.Printf("Ошибка преобразования ID комнаты: %v", err)
			return c.Status(400).SendString("Неверный ID комнаты")
		}

		form, err := c.MultipartForm()
		if err != nil {
			log.Printf("Ошибка получения формы: %v", err)
			return c.Status(400).SendString("Ошибка получения файлов")
		}

		files := form.File["images"]
		log.Printf("Получено %d файлов", len(files))

		isMain := len(files) > 0 // Первое изображение будет главным

		var uploadedImages []RoomImage
		for _, file := range files {
			// Проверяем тип файла
			if !strings.HasPrefix(file.Header.Get("Content-Type"), "image/") {
				return c.Status(400).SendString("Допустимы только изображения")
			}

			// Проверяем размер файла (например, максимум 5MB)
			if file.Size > 5*1024*1024 {
				return c.Status(400).SendString("Размер файла не должен превышать 5MB")
			}

			// Обрабатываем и сохраняем изображение
			fileName, err := processImage(file)
			if err != nil {
				log.Printf("Ошибка обработки изображения: %v", err)
				return c.Status(500).SendString("Ошибка обработки изображения")
			}

			// Сохраняем информацию в базу данных
			var imageID int
			err = pool.QueryRow(context.Background(), `
                INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main)
                VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING id
            `, roomID, fileName, file.Filename, file.Size, file.Header.Get("Content-Type"), isMain).Scan(&imageID)

			if err != nil {
				log.Printf("Ошибка сохранения информации об изображении: %v", err)
				return c.Status(500).SendString("Ошибка сохранения информации об изображении")
			}

			uploadedImages = append(uploadedImages, RoomImage{
				ID:          imageID,
				RoomID:      roomID,
				FilePath:    fileName,
				FileName:    file.Filename,
				FileSize:    int(file.Size),
				ContentType: file.Header.Get("Content-Type"),
				IsMain:      isMain,
			})

			isMain = false // Только первое изображение главное
		}

		return c.JSON(uploadedImages)
	})

	// Получение изображений комнаты
	app.Get("/rooms/:id/images", func(c *fiber.Ctx) error {
		roomID := c.Params("id")
		log.Printf("Получение изображений для комнаты: %s", roomID)

		rows, err := pool.Query(context.Background(), `
			SELECT id, room_id, file_path, file_name, file_size, content_type, is_main, created_at
			FROM room_images
			WHERE room_id = $1
			ORDER BY is_main DESC, created_at DESC
		`, roomID)
		if err != nil {
			log.Printf("Ошибка запроса изображений: %v", err)
			return c.Status(500).SendString("Ошибка получения изображений")
		}
		defer rows.Close()

		var images []RoomImage
		for rows.Next() {
			var img RoomImage
			err := rows.Scan(
				&img.ID,
				&img.RoomID,
				&img.FilePath,
				&img.FileName,
				&img.FileSize,
				&img.ContentType,
				&img.IsMain,
				&img.CreatedAt,
			)
			if err != nil {
				log.Printf("Ошибка сканирования изображения: %v", err)
				continue
			}
			images = append(images, img)
		}

		if len(images) == 0 {
			log.Printf("Изображения не найдены для комнаты: %s", roomID)
		} else {
			log.Printf("Найдено %d изображений для комнаты: %s", len(images), roomID)
		}

		return c.JSON(images)
	})

	// Удаление изображения
	app.Delete("/rooms/:roomId/images/:imageId", func(c *fiber.Ctx) error {
		imageID := c.Params("imageId")
		var filePath string
		err := pool.QueryRow(context.Background(), "SELECT file_path FROM room_images WHERE id = $1", imageID).Scan(&filePath)
		if err != nil {
			return c.Status(404).SendString("Изображение не найдено")
		}

		// Удаляем файл
		os.Remove(filepath.Join("uploads", filePath))

		// Удаляем запись из базы
		_, err = pool.Exec(context.Background(), "DELETE FROM room_images WHERE id = $1", imageID)
		if err != nil {
			return c.Status(500).SendString("Ошибка удаления изображения")
		}

		return c.SendString("Изображение удалено")
	})

	// Статическая раздача изображений
	app.Static("/uploads", "./uploads")

	// Главный маршрут
	app.Get("/", func(c *fiber.Ctx) error {
		return c.SendString("Hostel Booking System API с PostgreSQL")
	})

	// Добавление пользователя
	app.Post("/users", func(c *fiber.Ctx) error {
		type User struct {
			Name  string `json:"name"`
			Email string `json:"email"`
		}

		var user User
		if err := c.BodyParser(&user); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}

		_, err := pool.Exec(context.Background(), "INSERT INTO users (name, email) VALUES ($1, $2)", user.Name, user.Email)
		if err != nil {
			if strings.Contains(err.Error(), "unique constraint") {
				return c.Status(400).SendString("Email уже используется")
			}
			log.Printf("Ошибка добавления пользователя: %v", err)
			return c.Status(500).SendString("Ошибка добавления пользователя")
		}

		return c.SendString("Пользователь добавлен успешно")
	})

	type Room struct {
		Name               string   `json:"name"`
		Capacity           int      `json:"capacity"`
		PricePerNight      *float64 `json:"price_per_night"`
		AddressStreet      string   `json:"address_street"`
		AddressCity        string   `json:"address_city"`
		AddressState       string   `json:"address_state"`
		AddressCountry     string   `json:"address_country"`
		AddressPostalCode  string   `json:"address_postal_code"`
		AccommodationType  string   `json:"accommodation_type"`
		IsShared           bool     `json:"is_shared"`
		TotalBeds          *int     `json:"total_beds"`
		AvailableBeds      *int     `json:"available_beds"`
		HasPrivateBathroom bool     `json:"has_private_bathroom"`
		Latitude           *float64 `json:"latitude"`
		Longitude          *float64 `json:"longitude"`
		FormattedAddress   string   `json:"formatted_address"`
	}

	type Bed struct {
		ID            int     `json:"id"`
		RoomID        int     `json:"room_id"`
		BedNumber     string  `json:"bed_number"` // изменено с int на string
		IsAvailable   bool    `json:"is_available"`
		PricePerNight float64 `json:"price_per_night"`
	}

	type BedBooking struct {
		ID        int    `json:"id"`
		BedID     int    `json:"bed_id"`
		UserID    int    `json:"user_id"`
		StartDate string `json:"start_date"`
		EndDate   string `json:"end_date"`
	}
	app.Post("/rooms", func(c *fiber.Ctx) error {
		var room Room
		if err := c.BodyParser(&room); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}

		// Устанавливаем значения по умолчанию для total_beds и available_beds
		totalBeds := 0
		availableBeds := 0
		if room.TotalBeds != nil {
			totalBeds = *room.TotalBeds
			// Для available_beds используем либо переданное значение, либо total_beds
			if room.AvailableBeds != nil {
				availableBeds = *room.AvailableBeds
			} else {
				availableBeds = totalBeds
			}
		}

		var roomId int
		err := pool.QueryRow(context.Background(), `
			INSERT INTO rooms (
				name, capacity, price_per_night,
				address_street, address_city, address_state,
				address_country, address_postal_code,
				accommodation_type, is_shared,
				total_beds, available_beds, has_private_bathroom,
				latitude, longitude, formatted_address
			) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
				$11, $12, $13, $14, $15, $16)
			RETURNING id
		`, room.Name, room.Capacity, room.PricePerNight,
			room.AddressStreet, room.AddressCity, room.AddressState,
			room.AddressCountry, room.AddressPostalCode,
			room.AccommodationType, room.IsShared,
			totalBeds, availableBeds, room.HasPrivateBathroom,
			room.Latitude, room.Longitude, room.FormattedAddress,
		).Scan(&roomId)

		if err != nil {
			if strings.Contains(err.Error(), "unique constraint") {
				return c.Status(400).SendString("Комната с таким названием уже существует")
			}
			log.Printf("Ошибка добавления комнаты: %v", err)
			return c.Status(500).SendString("Ошибка добавления комнаты")
		}

		return c.JSON(fiber.Map{"id": roomId})
	})

	// Добавление кровати
	// Обработчик создания кровати
	app.Post("/rooms/:id/beds", func(c *fiber.Ctx) error {
		type BedRequest struct {
			BedNumber     string  `json:"bed_number"`
			PricePerNight float64 `json:"price_per_night"`
		}

		roomID, err := strconv.Atoi(c.Params("id"))
		if err != nil {
			return c.Status(400).SendString("Неверный ID комнаты")
		}

		var bedReq BedRequest
		if err := c.BodyParser(&bedReq); err != nil {
			log.Printf("Ошибка парсинга данных: %v", err)
			return c.Status(400).SendString("Неверный формат данных")
		}

		// Проверяем, существует ли комната
		var roomExists bool
		err = pool.QueryRow(context.Background(),
			"SELECT EXISTS(SELECT 1 FROM rooms WHERE id = $1)",
			roomID).Scan(&roomExists)
		if err != nil || !roomExists {
			return c.Status(404).SendString("Комната не найдена")
		}

		// Добавляем кровать
		var bedID int
		err = pool.QueryRow(context.Background(), `
        INSERT INTO beds (room_id, bed_number, price_per_night, is_available) 
        VALUES ($1, $2, $3, true)
        RETURNING id`,
			roomID, bedReq.BedNumber, bedReq.PricePerNight).Scan(&bedID)

		if err != nil {
			log.Printf("Ошибка добавления кровати: %v", err)
			return c.Status(500).SendString("Ошибка добавления кровати")
		}

		return c.JSON(fiber.Map{
			"id":              bedID,
			"room_id":         roomID,
			"bed_number":      bedReq.BedNumber,
			"price_per_night": bedReq.PricePerNight,
			"is_available":    true})
	})

	// Получение доступных кроватей
	app.Get("/rooms/:id/available-beds", func(c *fiber.Ctx) error {
		roomID := c.Params("id")
		startDate := c.Query("start_date")
		endDate := c.Query("end_date")

		// Проверяем корректность дат
		if startDate == "" || endDate == "" {
			return c.Status(400).SendString("Необходимо указать даты")
		}

		// проверяет пересечение периодов бронирования
		query := `
    SELECT b.id, b.bed_number, b.price_per_night
    FROM beds b
    WHERE b.room_id = $1
    AND b.is_available = true
    AND NOT EXISTS (
        SELECT 1
        FROM bed_bookings bb
        WHERE bb.bed_id = b.id
        AND bb.status = 'confirmed'
        AND (
            (bb.start_date <= $3 AND bb.end_date >= $2) -- Проверяем пересечение периодов
        )
    )
    ORDER BY b.bed_number
`

		rows, err := pool.Query(context.Background(), query, roomID, startDate, endDate)
		if err != nil {
			log.Printf("Ошибка запроса доступных кроватей: %v", err)
			return c.Status(500).SendString("Ошибка получения списка кроватей")
		}
		defer rows.Close()

		var beds []Bed
		for rows.Next() {
			var bed Bed
			if err := rows.Scan(&bed.ID, &bed.BedNumber, &bed.PricePerNight); err != nil {
				log.Printf("Ошибка сканирования кровати: %v", err)
				continue
			}
			bed.RoomID, _ = strconv.Atoi(roomID)
			bed.IsAvailable = true
			beds = append(beds, bed)
		}

		if err := rows.Err(); err != nil {
			log.Printf("Ошибка при итерации по кроватям: %v", err)
			return c.Status(500).SendString("Ошибка обработки данных")
		}

		// Обновляем количество доступных кроватей в комнате
		_, err = pool.Exec(context.Background(), `
			UPDATE rooms 
			SET available_beds = $1
			WHERE id = $2
		`, len(beds), roomID)

		if err != nil {
			log.Printf("Ошибка обновления количества доступных кроватей: %v", err)
			}

		return c.JSON(beds)
	})

	app.Get("/rooms", func(c *fiber.Ctx) error {
		capacity := c.Query("capacity")
		startDate := c.Query("start_date")
		endDate := c.Query("end_date")
		minPrice := c.Query("min_price")
		maxPrice := c.Query("max_price")
		city := c.Query("city")
		country := c.Query("country")

		baseQuery := `
WITH room_availability AS (
    SELECT 
        r.id,
        COALESCE(r.total_beds, 0) as total_beds,
        CASE 
            WHEN r.accommodation_type = 'bed' THEN 
                COALESCE(
                    r.total_beds - COALESCE((
                        SELECT COUNT(DISTINCT bb.bed_id)
                        FROM beds b2
                        LEFT JOIN bed_bookings bb ON b2.id = bb.bed_id
                        WHERE b2.room_id = r.id
                        AND bb.status = 'confirmed'
                        AND bb.start_date <= $2
                        AND bb.end_date >= $1
                    ), 0),
                    r.total_beds
                )
            ELSE 
                CASE WHEN EXISTS (
                    SELECT 1 FROM bookings b
                    WHERE b.room_id = r.id
                    AND b.status = 'confirmed'
                    AND b.start_date <= $2
                    AND b.end_date >= $1
                ) THEN 0 ELSE 1 END
        END as available_count,
        CASE 
            WHEN r.accommodation_type = 'bed' THEN
                COALESCE(
                    (SELECT MIN(b3.price_per_night) 
                     FROM beds b3 
                     WHERE b3.room_id = r.id 
                     AND b3.is_available = true
                     AND b3.id NOT IN (
                        SELECT bb.bed_id
                        FROM bed_bookings bb
                        WHERE bb.status = 'confirmed'
                        AND bb.start_date <= $2
                        AND bb.end_date >= $1
                     )),
                    r.price_per_night
                )
            ELSE r.price_per_night
        END as actual_price
    FROM rooms r
)
SELECT 
    r.id, 
    r.name, 
    r.capacity,
    r.latitude,
    r.longitude,
    ra.actual_price as price_per_night,
    r.address_street, 
    r.address_city, 
    r.address_state,
    r.address_country, 
    r.address_postal_code,
    r.accommodation_type, 
    r.is_shared,
    COALESCE(r.total_beds, 0) as total_beds,
    COALESCE(ra.available_count, 0) as available_beds,
    r.has_private_bathroom,
    r.created_at
FROM rooms r
JOIN room_availability ra ON r.id = ra.id
WHERE 1=1
    AND (
        CASE 
            WHEN r.accommodation_type = 'bed' 
            THEN COALESCE(ra.available_count, 0) > 0 
            ELSE COALESCE(ra.available_count, 1) = 1
        END
    )`

		var conditions []string
		args := []interface{}{startDate, endDate}
		// Добавляем фильтр по типу размещения
		if accommodationType := c.Query("accommodation_type"); accommodationType != "" {
			conditions = append(conditions, fmt.Sprintf("r.accommodation_type = $%d", len(args)+1))
			args = append(args, accommodationType)

			// Дополнительная проверка для приватных комнат
			if accommodationType == "room" && c.Query("has_private_rooms") == "true" {
				conditions = append(conditions, "r.is_shared = false")
			}
		}
		// Фильтр по вместимости
		if capacity != "" {
			conditions = append(conditions, fmt.Sprintf("r.capacity >= $%d", len(args)+1))
			args = append(args, capacity)
		}

		// Фильтр по минимальной цене
		if minPrice != "" {
			minPriceFloat, err := strconv.ParseFloat(minPrice, 64)
			if err == nil {
				conditions = append(conditions, fmt.Sprintf("ra.actual_price >= $%d", len(args)+1))
				args = append(args, minPriceFloat)
			}
		}

		// Фильтр по максимальной цене
		if maxPrice != "" {
			maxPriceFloat, err := strconv.ParseFloat(maxPrice, 64)
			if err == nil {
				conditions = append(conditions, fmt.Sprintf("ra.actual_price <= $%d", len(args)+1))
				args = append(args, maxPriceFloat)
			}
		}

		// Фильтры по городу и стране
		if city != "" {
			conditions = append(conditions, fmt.Sprintf("r.address_city ILIKE $%d", len(args)+1))
			args = append(args, "%"+city+"%")
		}
		if country != "" {
			conditions = append(conditions, fmt.Sprintf("r.address_country ILIKE $%d", len(args)+1))
			args = append(args, "%"+country+"%")
		}

		// Добавляем условия WHERE, если они есть
		if len(conditions) > 0 {
			baseQuery += " AND " + strings.Join(conditions, " AND ")
		}

		// Добавляем сортировку
		baseQuery += " ORDER BY ra.available_count DESC, ra.actual_price ASC, r.created_at DESC"
		// Логирование запроса
		log.Printf("SQL Query: %s, Args: %v", baseQuery, args)

		// Выполнение запроса
		rows, err := pool.Query(context.Background(), baseQuery, args...)

		if err != nil {
			log.Printf("Ошибка выполнения запроса: %v", err)
			return c.Status(500).SendString("Ошибка получения списка комнат")
		}
		defer rows.Close()

		// Обработка результатов
		var rooms []map[string]interface{}
		for rows.Next() {
			var id, capacity int
			var totalBeds, availableBeds int
			var name, addressStreet, addressCity, addressState,
				addressCountry, addressPostalCode, accommodationType string
			var latitude, longitude float64
			var pricePerNight float64
			var isShared, hasPrivateBathroom bool
			var createdAt time.Time

			if err := rows.Scan(
				&id, &name, &capacity, &latitude, &longitude, &pricePerNight,
				&addressStreet, &addressCity, &addressState,
				&addressCountry, &addressPostalCode,
				&accommodationType, &isShared,
				&totalBeds, &availableBeds, // теперь это не может быть NULL
				&hasPrivateBathroom,
				&createdAt,
			); err != nil {
				log.Printf("Ошибка сканирования строки: %v", err)
				continue
			}

			rooms = append(rooms, map[string]interface{}{
				"id":                   id,
				"name":                 name,
				"capacity":             capacity,
				"latitude":             latitude,  
				"longitude":            longitude, 
				"price_per_night":      pricePerNight,
				"address_street":       addressStreet,
				"address_city":         addressCity,
				"address_state":        addressState,
				"address_country":      addressCountry,
				"address_postal_code":  addressPostalCode,
				"accommodation_type":   accommodationType,
				"is_shared":            isShared,
				"total_beds":           totalBeds,
				"available_beds":       availableBeds,
				"has_private_bathroom": hasPrivateBathroom,
				"created_at":           createdAt.Format("2006-01-02 15:04:05"),
			})
		}
		return c.JSON(rooms)
	})

	// Добавление изображений койко-места
	app.Post("/beds/:id/images", func(c *fiber.Ctx) error {
		bedID, err := strconv.Atoi(c.Params("id"))
		if err != nil {
			return c.Status(400).SendString("Неверный ID койко-места")
		}

		form, err := c.MultipartForm()
		if err != nil {
			return c.Status(400).SendString("Ошибка получения файлов")
		}

		files := form.File["images"]
		var uploadedImages []map[string]interface{}

		for _, file := range files {
			if !strings.HasPrefix(file.Header.Get("Content-Type"), "image/") {
				return c.Status(400).SendString("Допустимы только изображения")
			}

			if file.Size > 5*1024*1024 {
				return c.Status(400).SendString("Размер файла не должен превышать 5MB")
			}

			fileName, err := processImage(file)
			if err != nil {
				return c.Status(500).SendString("Ошибка обработки изображения")
			}

			// Сохраняем информацию в базу данных
			var imageID int
			err = pool.QueryRow(context.Background(), `
            INSERT INTO bed_images (bed_id, file_path, file_name, file_size, content_type)
            VALUES ($1, $2, $3, $4, $5)
            RETURNING id
        `, bedID, fileName, file.Filename, file.Size, file.Header.Get("Content-Type")).Scan(&imageID)

			if err != nil {
				return c.Status(500).SendString("Ошибка сохранения информации об изображении")
			}

			uploadedImages = append(uploadedImages, map[string]interface{}{
				"id":           imageID,
				"bed_id":       bedID,
				"file_path":    fileName,
				"file_name":    file.Filename,
				"file_size":    file.Size,
				"content_type": file.Header.Get("Content-Type"),
			})
		}

		return c.JSON(uploadedImages)
	})

	// Получение изображений койко-места
	app.Get("/beds/:id/images", func(c *fiber.Ctx) error {
		bedID := c.Params("id")

		rows, err := pool.Query(context.Background(), `
        SELECT id, bed_id, file_path, file_name, file_size, content_type, created_at
        FROM bed_images
        WHERE bed_id = $1
        ORDER BY created_at DESC
    `, bedID)
		if err != nil {
			return c.Status(500).SendString("Ошибка получения изображений")
		}
		defer rows.Close()

		var images []map[string]interface{}
		for rows.Next() {
			var (
				id          int
				bedID       int
				filePath    string
				fileName    string
				fileSize    int
				contentType string
				createdAt   time.Time
			)

			err := rows.Scan(&id, &bedID, &filePath, &fileName, &fileSize, &contentType, &createdAt)
			if err != nil {
				continue
			}

			images = append(images, map[string]interface{}{
				"id":           id,
				"bed_id":       bedID,
				"file_path":    filePath,
				"file_name":    fileName,
				"file_size":    fileSize,
				"content_type": contentType,
				"created_at":   createdAt,
			})
		}

		return c.JSON(images)
	})
	// Добавление бронирования
	app.Post("/bookings", func(c *fiber.Ctx) error {
		type BookingRequest struct {
			UserID    int    `json:"user_id"`
			RoomID    int    `json:"room_id"`
			BedID     *int   `json:"bed_id,omitempty"`
			StartDate string `json:"start_date"`
			EndDate   string `json:"end_date"`
		}

		var booking BookingRequest
		if err := c.BodyParser(&booking); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}
		if booking.StartDate == booking.EndDate {
			return c.Status(400).SendString("Дата выезда должна быть позже даты заезда")
		}
		tx, err := pool.Begin(context.Background())
		if err != nil {
			return c.Status(500).SendString("Ошибка начала транзакции")
		}
		defer tx.Rollback(context.Background())

		// Проверяем существование пользователя
		var userExists bool
		err = tx.QueryRow(context.Background(),
			"SELECT EXISTS(SELECT 1 FROM users WHERE id = $1)",
			booking.UserID).Scan(&userExists)
		if err != nil || !userExists {
			return c.Status(400).SendString("Пользователь не найден")
		}

		// Получаем информацию о комнате
		var roomType string
		var isShared bool
		err = tx.QueryRow(context.Background(), `
            SELECT accommodation_type, is_shared 
            FROM rooms 
            WHERE id = $1`,
			booking.RoomID).Scan(&roomType, &isShared)
		if err != nil {
			return c.Status(500).SendString("Ошибка получения информации о комнате")
		}

		if roomType == "bed" {
			if booking.BedID == nil {
				return c.Status(400).SendString("Для койко-места необходимо указать ID кровати")
			}

			// Проверяем доступность койко-места
			var isAvailable bool
			err = tx.QueryRow(context.Background(), `
                SELECT is_available 
                FROM beds 
                WHERE id = $1 AND room_id = $2`,
				*booking.BedID, booking.RoomID).Scan(&isAvailable)
			if err != nil || !isAvailable {
				return c.Status(400).SendString("Койко-место недоступно")
			}

			// Проверяем, не забронировано ли койко-место на эти даты
			var conflictCount int
			err = tx.QueryRow(context.Background(), `
				SELECT COUNT(*) 
				FROM bed_bookings 
				WHERE bed_id = $1 
				AND status = 'confirmed'
				AND (
					(start_date <= $2 AND end_date >= $2) OR
					(start_date <= $3 AND end_date >= $3) OR
					(start_date >= $2 AND end_date <= $3)
				)`,
				*booking.BedID, booking.StartDate, booking.EndDate).Scan(&conflictCount)

			if err != nil || conflictCount > 0 {
				return c.Status(400).SendString("Койко-место уже забронировано на эти даты")
			}

			// Создаем бронирование койко-места
			_, err = tx.Exec(context.Background(), `
                INSERT INTO bed_bookings (bed_id, user_id, start_date, end_date, status)
                VALUES ($1, $2, $3, $4, 'confirmed')`,
				*booking.BedID, booking.UserID, booking.StartDate, booking.EndDate)

			// Обновляем количество доступных мест в комнате
			_, err = tx.Exec(context.Background(), `
                UPDATE rooms 
                SET available_beds = available_beds - 1
                WHERE id = $1`,
				booking.RoomID)
		} else {
			// Для комнат и квартир проверяем общую доступность
			var count int
			err = tx.QueryRow(context.Background(), `
                SELECT COUNT(*) 
                FROM bookings 
                WHERE room_id = $1 
                    AND start_date <= $3 
                    AND end_date >= $2
                    AND status = 'confirmed'`,
				booking.RoomID, booking.StartDate, booking.EndDate).Scan(&count)
			if err != nil || count > 0 {
				return c.Status(400).SendString("Помещение занято на указанные даты")
			}

			// Создаем обычное бронирование
			_, err = tx.Exec(context.Background(), `
                INSERT INTO bookings (user_id, room_id, start_date, end_date, status)
                VALUES ($1, $2, $3, $4, 'confirmed')`,
				booking.UserID, booking.RoomID, booking.StartDate, booking.EndDate)
		}

		if err != nil {
			log.Printf("Ошибка создания бронирования: %v", err)
			return c.Status(500).SendString("Ошибка создания бронирования")
		}

		if err = tx.Commit(context.Background()); err != nil {
			return c.Status(500).SendString("Ошибка фиксации транзакции")
		}

		return c.SendString("Бронирование создано успешно")
	})

	// Получение списка всех бронирований
	app.Get("/bookings", func(c *fiber.Ctx) error {
		// Получаем бронирования комнат
		roomBookingsQuery := `
            SELECT b.id, b.user_id, b.room_id, NULL as bed_id, 
                   b.start_date, b.end_date, b.status,
                   r.name as room_name, r.accommodation_type,
                   u.name as user_name, u.email as user_email
            FROM bookings b
            JOIN rooms r ON b.room_id = r.id
            JOIN users u ON b.user_id = u.id
        `
		roomRows, err := pool.Query(context.Background(), roomBookingsQuery)
		if err != nil {
			log.Printf("Ошибка получения бронирований комнат: %v", err)
			return c.Status(500).SendString("Ошибка получения списка бронирований")
		}
		defer roomRows.Close()

		// Получаем бронирования койко-мест
		bedBookingsQuery := `
            SELECT bb.id, bb.user_id, b.room_id, bb.bed_id,
                   bb.start_date, bb.end_date, bb.status,
                   r.name as room_name, r.accommodation_type,
                   u.name as user_name, u.email as user_email
            FROM bed_bookings bb
            JOIN beds b ON bb.bed_id = b.id
            JOIN rooms r ON b.room_id = r.id
            JOIN users u ON bb.user_id = u.id
        `
		bedRows, err := pool.Query(context.Background(), bedBookingsQuery)
		if err != nil {
			log.Printf("Ошибка получения бронирований койко-мест: %v", err)
			return c.Status(500).SendString("Ошибка получения списка бронирований")
		}
		defer bedRows.Close()

		var bookings []map[string]interface{}

		// Обработка бронирований комнат
		for roomRows.Next() {
			var (
				id, userID, roomID  int
				bedID               *int
				startDate, endDate  time.Time
				status, roomName    string
				accommodationType   string
				userName, userEmail string
			)

			if err := roomRows.Scan(
				&id, &userID, &roomID, &bedID, &startDate, &endDate, &status,
				&roomName, &accommodationType, &userName, &userEmail,
			); err != nil {
				log.Printf("Ошибка сканирования бронирования комнаты: %v", err)
				continue
			}

			bookings = append(bookings, map[string]interface{}{
				"id":           id,
				"user_id":      userID,
				"room_id":      roomID,
				"bed_id":       bedID,
				"start_date":   startDate.Format("2006-01-02"),
				"end_date":     endDate.Format("2006-01-02"),
				"status":       status,
				"room_name":    roomName,
				"type":         accommodationType,
				"user_name":    userName,
				"user_email":   userEmail,
				"booking_type": "room",
			})
		}

		// Обработка бронирований койко-мест
		for bedRows.Next() {
			var (
				id, userID, roomID  int
				bedID               int
				startDate, endDate  time.Time
				status, roomName    string
				accommodationType   string
				userName, userEmail string
			)

			if err := bedRows.Scan(
				&id, &userID, &roomID, &bedID, &startDate, &endDate, &status,
				&roomName, &accommodationType, &userName, &userEmail,
			); err != nil {
				log.Printf("Ошибка сканирования бронирования койко-места: %v", err)
				continue
			}

			bookings = append(bookings, map[string]interface{}{
				"id":           id,
				"user_id":      userID,
				"room_id":      roomID,
				"bed_id":       bedID,
				"start_date":   startDate.Format("2006-01-02"),
				"end_date":     endDate.Format("2006-01-02"),
				"status":       status,
				"room_name":    roomName,
				"type":         accommodationType,
				"user_name":    userName,
				"user_email":   userEmail,
				"booking_type": "bed",
			})
		}

		return c.JSON(bookings)
	})

	// Удаление комнаты
	app.Delete("/rooms/:id", func(c *fiber.Ctx) error {
		id := c.Params("id")
		result, err := pool.Exec(context.Background(), "DELETE FROM rooms WHERE id=$1", id)
		if err != nil {
			log.Printf("Ошибка удаления комнаты: %v", err)
			return c.Status(500).SendString("Ошибка удаления комнаты")
		}
		if result.RowsAffected() == 0 {
			return c.Status(404).SendString("Комната не найдена")
		}
		return c.SendString("Комната успешно удалена")
	})



	// Запуск приложения
	log.Fatal(app.Listen("0.0.0.0:3000"))
}


--- Содержимое файла: frontend/hostel-frontend/src/api/axios.js ---

import axios from 'axios';

// базовый URL для API-сервера
const instance = axios.create({
    baseURL: "http://192.168.100.14:3000",
    headers: {
      "Content-Type": "application/json",
    },
  });
  

export default instance;


--- Содержимое файла: backend/migrations/0004_update_constraints.down.sql ---


-- Remove the NOT NULL constraint.
ALTER TABLE bookings
ALTER COLUMN user_id DROP NOT NULL,
ALTER COLUMN room_id DROP NOT NULL;

-- Drop the added indexes.
DROP INDEX IF EXISTS idx_bookings_user_id;
DROP INDEX IF EXISTS idx_bookings_room_id;


--- Содержимое файла: backend/migrations/0001_create_tables.up.sql ---

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE rooms (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    capacity INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE bookings (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- Добавить ограничение на длину email
ALTER TABLE users
    ADD CONSTRAINT valid_email 
    CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

-- Добавить ограничение на минимальную длину имени
ALTER TABLE users
    ADD CONSTRAINT valid_name 
    CHECK (length(name) >= 2);

--- Содержимое файла: backend/migrations/0018_add_bed_images.up.sql ---

CREATE TABLE bed_images (
    id SERIAL PRIMARY KEY,
    bed_id INT NOT NULL REFERENCES beds(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_bed_images_bed_id ON bed_images(bed_id);

--- Содержимое файла: backend/migrations/0016_fix_bed_availability.down.sql ---

DROP FUNCTION IF EXISTS get_beds_availability;
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds;

--- Содержимое файла: backend/migrations/0002_add_price_per_night.up.sql ---

ALTER TABLE rooms 
    ADD COLUMN price_per_night NUMERIC(10, 2) NOT NULL DEFAULT 0 
    CHECK (price_per_night >= 0);
CREATE INDEX idx_users_email ON users(email);

-- Добавить составной индекс для фильтрации комнат
CREATE INDEX idx_rooms_capacity_price ON rooms(capacity, price_per_night);

--- Содержимое файла: backend/migrations/0015_fix_available_beds.up.sql ---

-- Удаляем старый триггер и функцию
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds();

-- Создаем улучшенную функцию обновления доступных мест
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    -- Обновляем количество доступных мест для комнаты, связанной с бронированием
    WITH bed_count AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        LEFT JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE 
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = r.total_beds - COALESCE(bc.booked_beds, 0)
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем новый триггер
CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();

-- Создаем функцию для получения количества доступных мест на конкретные даты
CREATE OR REPLACE FUNCTION get_available_beds(
    room_id_param INTEGER,
    start_date_param DATE,
    end_date_param DATE
)
RETURNS INTEGER AS $$
DECLARE
    total_beds INTEGER;
    booked_beds INTEGER;
BEGIN
    -- Получаем общее количество кроватей
    SELECT total_beds INTO total_beds
    FROM rooms
    WHERE id = room_id_param;

    -- Считаем количество забронированных кроватей на указанные даты
    SELECT COUNT(DISTINCT bb.bed_id) INTO booked_beds
    FROM bed_bookings bb
    JOIN beds b ON bb.bed_id = b.id
    WHERE b.room_id = room_id_param
    AND bb.status = 'confirmed'
    AND bb.start_date <= end_date_param
    AND bb.end_date >= start_date_param;

    -- Возвращаем разницу
    RETURN total_beds - COALESCE(booked_beds, 0);
END;
$$ LANGUAGE plpgsql;

-- Функция инициализации доступных мест
CREATE OR REPLACE FUNCTION initialize_available_beds()
RETURNS void AS $$
BEGIN
    WITH bed_count AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        LEFT JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE 
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = r.total_beds - COALESCE(bc.booked_beds, 0)
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';
END;
$$ LANGUAGE plpgsql;

-- Выполняем начальную инициализацию
SELECT initialize_available_beds();

--- Содержимое файла: backend/migrations/0006_add_room_address.down.sql ---

-- 0006_add_room_address.down.sql
DROP INDEX IF EXISTS idx_rooms_city;
DROP INDEX IF EXISTS idx_rooms_country;

ALTER TABLE rooms
    DROP COLUMN address_street,
    DROP COLUMN address_city,
    DROP COLUMN address_state,
    DROP COLUMN address_country,
    DROP COLUMN address_postal_code;

--- Содержимое файла: backend/migrations/0014_add_beds_trigger.down.sql ---

-- Удаляем триггер
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;

-- Удаляем функцию
DROP FUNCTION IF EXISTS update_available_beds();

--- Содержимое файла: backend/migrations/0014_add_beds_trigger.up.sql ---

-- Создаем функцию для подсчета доступных кроватей
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
            AND (
                (start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE)
            )
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем триггер для таблицы bed_bookings
CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();

--- Содержимое файла: backend/migrations/0005_add_status_and_indexes.down.sql ---

-- 0005_add_status_and_indexes.down.sql
DROP INDEX IF EXISTS idx_bookings_status;
DROP INDEX IF EXISTS idx_bookings_dates;
ALTER TABLE bookings DROP COLUMN status;

--- Содержимое файла: backend/migrations/0017_add_location_fields.up.sql ---

-- Добавляем поля для координат и форматированного адреса
ALTER TABLE rooms
    ADD COLUMN latitude DECIMAL(10, 8),
    ADD COLUMN longitude DECIMAL(11, 8),
    ADD COLUMN formatted_address TEXT;

-- Индекс для географического поиска
CREATE INDEX idx_rooms_location ON rooms(latitude, longitude);

-- Функция для валидации координат
CREATE OR REPLACE FUNCTION validate_coordinates()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.latitude IS NOT NULL AND (NEW.latitude < -90 OR NEW.latitude > 90) THEN
        RAISE EXCEPTION 'Широта должна быть между -90 и 90';
    END IF;
    IF NEW.longitude IS NOT NULL AND (NEW.longitude < -180 OR NEW.longitude > 180) THEN
        RAISE EXCEPTION 'Долгота должна быть между -180 и 180';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Триггер для валидации координат
CREATE TRIGGER validate_coordinates_trigger
    BEFORE INSERT OR UPDATE ON rooms
    FOR EACH ROW
    EXECUTE FUNCTION validate_coordinates();

--- Содержимое файла: backend/migrations/0007_add_room_images.down.sql ---

-- 0007_add_room_images.down.sql
DROP TABLE IF EXISTS room_images;

--- Содержимое файла: backend/migrations/0011_extend_room_types.up.sql ---

ALTER TABLE rooms
    ADD COLUMN accommodation_type VARCHAR(50) NOT NULL DEFAULT 'room'
    CHECK (accommodation_type IN ('bed', 'room', 'apartment')),
    ADD COLUMN is_shared BOOLEAN NOT NULL DEFAULT false,
    ADD COLUMN total_beds INT,
    ADD COLUMN available_beds INT,
    ADD COLUMN has_private_bathroom BOOLEAN NOT NULL DEFAULT true;

CREATE TABLE beds (
    id SERIAL PRIMARY KEY,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    bed_number INT NOT NULL,
    is_available BOOLEAN NOT NULL DEFAULT true,
    price_per_night DECIMAL(10, 2) NOT NULL CHECK (price_per_night >= 0),
    UNIQUE(room_id, bed_number)
);

CREATE TABLE bed_bookings (
    id SERIAL PRIMARY KEY,
    bed_id INT REFERENCES beds(id) ON DELETE CASCADE,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL CHECK (end_date > start_date),
    status VARCHAR(20) NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

--- Содержимое файла: backend/migrations/0005_add_status_and_indexes.up.sql ---

-- 0005_add_status_and_indexes.up.sql
ALTER TABLE bookings 
    ADD COLUMN status VARCHAR(20) NOT NULL 
    DEFAULT 'pending' 
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

CREATE INDEX idx_bookings_status ON bookings(status);
CREATE INDEX idx_bookings_dates ON bookings(start_date, end_date);

--- Содержимое файла: backend/migrations/0018_add_bed_images.down.sql ---

DROP TABLE IF EXISTS bed_images;


--- Содержимое файла: backend/migrations/0013_update_bed_bookings.down.sql ---

-- 0013_update_bed_bookings.down.sql
DROP INDEX IF EXISTS idx_bed_bookings_dates_status;
ALTER TABLE bed_bookings DROP COLUMN IF EXISTS status;

--- Содержимое файла: backend/migrations/0012_add_accommodation_types.down.sql ---

-- 0012_add_accommodation_types.down.sql
ALTER TABLE bookings DROP COLUMN IF EXISTS status;

--- Содержимое файла: backend/migrations/0004_update_constraints.up.sql ---


-- Add NOT NULL constraint to ensure data integrity.
ALTER TABLE bookings
ALTER COLUMN user_id SET NOT NULL,
ALTER COLUMN room_id SET NOT NULL;

-- Add an index to optimize queries on bookings table.
CREATE INDEX idx_bookings_user_id ON bookings(user_id);
CREATE INDEX idx_bookings_room_id ON bookings(room_id);


--- Содержимое файла: backend/migrations/0019_update_bed_availability_trigger.down.sql ---

CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms r
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--- Содержимое файла: backend/migrations/0012_add_accommodation_types.up.sql ---

-- 0012_add_accommodation_types.up.sql
ALTER TABLE bookings
    ADD COLUMN IF NOT EXISTS status VARCHAR(20) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

--- Содержимое файла: backend/migrations/0013_update_bed_bookings.up.sql ---

-- 0013_update_bed_bookings.up.sql
ALTER TABLE bed_bookings
ADD COLUMN IF NOT EXISTS status VARCHAR(20) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

-- Создаем индекс для оптимизации поиска
CREATE INDEX IF NOT EXISTS idx_bed_bookings_dates_status 
ON bed_bookings(start_date, end_date, status);

--- Содержимое файла: backend/migrations/0003_add_constraints_and_indexes.down.sql ---


-- Remove constraints and indexes added in the up migration
ALTER TABLE bookings DROP CONSTRAINT valid_date_range;

DROP INDEX IF EXISTS idx_rooms_price;
DROP INDEX IF EXISTS idx_bookings_room_date;


--- Содержимое файла: backend/migrations/0017_add_location_fields.down.sql ---

-- Удаляем триггер и функцию
DROP TRIGGER IF EXISTS validate_coordinates_trigger ON rooms;
DROP FUNCTION IF EXISTS validate_coordinates;

-- Удаляем индекс
DROP INDEX IF EXISTS idx_rooms_location;

-- Удаляем колонки
ALTER TABLE rooms
    DROP COLUMN IF EXISTS latitude,
    DROP COLUMN IF EXISTS longitude,
    DROP COLUMN IF EXISTS formatted_address;

--- Содержимое файла: backend/migrations/0001_create_tables.down.sql ---

DROP TABLE IF EXISTS bookings CASCADE;
DROP TABLE IF EXISTS rooms CASCADE;
DROP TABLE IF EXISTS users CASCADE;


--- Содержимое файла: backend/migrations/0007_add_room_images.up.sql ---

-- 0007_add_room_images.up.sql
CREATE TABLE room_images (
    id SERIAL PRIMARY KEY,
    room_id INT NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    is_main BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_main_image_per_room UNIQUE (room_id, is_main) 
        DEFERRABLE INITIALLY DEFERRED
);

CREATE INDEX idx_room_images_room_id ON room_images(room_id);

--- Содержимое файла: backend/migrations/0015_fix_available_beds.down.sql ---

-- Удаляем созданные функции и триггеры
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds();
DROP FUNCTION IF EXISTS get_available_beds(INTEGER, DATE, DATE);
DROP FUNCTION IF EXISTS initialize_available_beds();

-- Возвращаем простой триггер для обновления available_beds
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
            AND (
                (start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE)
            )
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();

--- Содержимое файла: backend/migrations/0011_extend_room_types.down.sql ---

-- 0011_extend_room_types.down.sql
DROP TABLE IF EXISTS bed_bookings;
DROP TABLE IF EXISTS beds;
ALTER TABLE rooms
    DROP COLUMN accommodation_type,
    DROP COLUMN is_shared,
    DROP COLUMN total_beds,
    DROP COLUMN available_beds,
    DROP COLUMN has_private_bathroom;

--- Содержимое файла: backend/migrations/0002_add_price_per_night.down.sql ---

ALTER TABLE rooms DROP COLUMN price_per_night;

--- Содержимое файла: backend/migrations/0016_fix_bed_availability.up.sql ---

-- Название файла: backend/migrations/0016_fix_bed_availability.up.sql

-- Удаляем старую версию функции если она существует
DROP FUNCTION IF EXISTS update_available_beds CASCADE;

-- Создаем новую функцию
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    WITH bed_count AS (
        SELECT 
            b.room_id,
            COUNT(DISTINCT b.id) as total_beds,
            COUNT(DISTINCT CASE 
                WHEN NOT EXISTS (
                    SELECT 1 
                    FROM bed_bookings bb 
                    WHERE bb.bed_id = b.id 
                    AND bb.status = 'confirmed'
                    AND (
                        (bb.start_date <= CURRENT_DATE AND bb.end_date >= CURRENT_DATE) OR
                        (bb.start_date >= CURRENT_DATE AND bb.start_date <= CURRENT_DATE)
                    )
                ) THEN b.id 
            END) as available_beds
        FROM beds b
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET 
        total_beds = bc.total_beds,
        available_beds = bc.available_beds
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Пересоздаем триггер
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
CREATE TRIGGER bed_bookings_update_trigger
    AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
    FOR EACH ROW
    EXECUTE FUNCTION update_available_beds();

-- Создаем функцию для получения количества доступных мест на определенные даты
CREATE OR REPLACE FUNCTION get_beds_availability(
    p_room_id INTEGER,
    p_start_date DATE,
    p_end_date DATE
) RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT COUNT(DISTINCT b.id)
        FROM beds b
        WHERE b.room_id = p_room_id
        AND b.is_available = true
        AND NOT EXISTS (
            SELECT 1
            FROM bed_bookings bb
            WHERE bb.bed_id = b.id
            AND bb.status = 'confirmed'
            AND (
                (bb.start_date <= p_end_date AND bb.end_date >= p_start_date) OR
                (bb.start_date >= p_start_date AND bb.start_date <= p_end_date)
            )
        )
    );
END;
$$ LANGUAGE plpgsql;

--- Содержимое файла: backend/migrations/0006_add_room_address.up.sql ---

-- 0006_add_room_address.up.sql
ALTER TABLE rooms
    ADD COLUMN address_street VARCHAR(255) NOT NULL DEFAULT '',
    ADD COLUMN address_city VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_state VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_country VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_postal_code VARCHAR(20) NOT NULL DEFAULT '';

CREATE INDEX idx_rooms_city ON rooms(address_city);
CREATE INDEX idx_rooms_country ON rooms(address_country);

--- Содержимое файла: backend/migrations/0003_add_constraints_and_indexes.up.sql ---


-- Add additional constraints and indexes to fix issues
ALTER TABLE bookings
    ADD CONSTRAINT valid_date_range 
    CHECK (start_date < end_date AND start_date >= CURRENT_DATE);

-- Indexes to optimize queries
CREATE INDEX idx_rooms_price ON rooms (price_per_night);
CREATE INDEX idx_bookings_room_date ON bookings (room_id, start_date, end_date);


--- Содержимое файла: backend/migrations/0019_update_bed_availability_trigger.up.sql ---

-- Обновляем функцию подсчета доступных мест
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    -- Обновляем количество доступных мест для комнаты с учетом текущих броней
    WITH current_bookings AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = COALESCE(r.total_beds, 0) - COALESCE(cb.booked_beds, 0)
    FROM current_bookings cb
    WHERE r.id = cb.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--- Содержимое файла: frontend/hostel-frontend/src/components/MapView.js ---

import React, { useState, useCallback } from 'react';
import { GoogleMap, Marker, InfoWindow } from '@react-google-maps/api';
import {
    Card,
    CardContent,
    Typography,
    Box,
    Button,
    Chip,
    CardMedia,
} from '@mui/material';
import {
    SingleBed as SingleBedIcon,
    Hotel as HotelIcon,
    Apartment as ApartmentIcon,
    PhotoLibrary as PhotoLibraryIcon,
    MyLocation as MyLocationIcon,
} from '@mui/icons-material';

const BACKEND_URL = 'http://192.168.100.14:3000';

const mapContainerStyle = {
    width: '100%',
    height: '700px'
};

const defaultCenter = {
    lat: 45.2671, // Нови-Сад
    lng: 19.8335
};

const MapView = ({ rooms, onRoomSelect, onOpenGallery }) => {
    const [map, setMap] = useState(null);
    const [selectedRoom, setSelectedRoom] = useState(null);

    // Выносим опции карты в отдельную функцию для предотвращения проблем с window.google
    const getMapOptions = useCallback(() => ({
        scrollwheel: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
            style: 'DEFAULT', // Убираем прямую ссылку на google.maps
            mapTypeIds: ["roadmap", "satellite", "hybrid"]
        },
        styles: [
            {
                featureType: "poi",
                elementType: "labels",
                stylers: [{ visibility: "off" }]
            }
        ],
        fullscreenControl: true,
        streetViewControl: false,
        zoomControl: true,
    }), []);

    const onMapLoad = useCallback((map) => {
        setMap(map);
        console.log('Map loaded, rooms:', rooms); // Отладка
        if (rooms?.length > 0) {
            const bounds = new window.google.maps.LatLngBounds();
            let hasValidCoords = false;

            rooms.forEach(room => {
                if (room.latitude && room.longitude) {
                    const lat = parseFloat(room.latitude);
                    const lng = parseFloat(room.longitude);

                    if (!isNaN(lat) && !isNaN(lng)) {
                        bounds.extend({ lat, lng });
                        hasValidCoords = true;
                        console.log(`Added to bounds: ${room.name}, lat: ${lat}, lng: ${lng}`); // Отладка
                    }
                }
            });

            if (hasValidCoords) {
                map.fitBounds(bounds);
            }
        }
    }, [rooms]);

    const handleMyLocation = () => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const pos = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };
                    map?.panTo(pos);
                    map?.setZoom(15);
                },
                (error) => {
                    console.error("Error getting location:", error);
                    alert("Не удалось получить местоположение");
                }
            );
        } else {
            alert("Геолокация не поддерживается вашим браузером");
        }
    };

    const InfoWindowContent = ({ room }) => {
        const hasImages = room.images && room.images.length > 0;
        const mainImage = hasImages ? room.images.find(img => img.is_main) || room.images[0] : null;

        return (
            <Card sx={{ width: 300, border: 'none', boxShadow: 'none' }}>
                {mainImage && (
                    <Box
                        sx={{
                            position: 'relative',
                            cursor: 'pointer',
                            '&:hover': {
                                '& .overlay': {
                                    opacity: 1
                                }
                            }
                        }}
                        onClick={(e) => {
                            e.stopPropagation();
                            onOpenGallery(room);
                        }}
                    >
                        <CardMedia
                            component="img"
                            height="160"
                            image={`${BACKEND_URL}/uploads/${mainImage.file_path}`}
                            alt={room.name}
                            sx={{
                                borderRadius: '4px 4px 0 0',
                                objectFit: 'cover'
                            }}
                        />
                        {room.images.length > 1 && (
                            <Box
                                className="overlay"
                                sx={{
                                    position: 'absolute',
                                    bottom: 0,
                                    right: 0,
                                    bgcolor: 'rgba(0, 0, 0, 0.6)',
                                    color: 'white',
                                    px: 1,
                                    py: 0.5,
                                    borderRadius: '4px 0 0 0',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: 0.5,
                                    opacity: 0,
                                    transition: 'opacity 0.2s',
                                }}
                            >
                                <PhotoLibraryIcon fontSize="small" />
                                <Typography variant="caption">
                                    +{room.images.length - 1}
                                </Typography>
                            </Box>
                        )}
                    </Box>
                )}
                <CardContent sx={{ p: 1.5 }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                        {room.accommodation_type === 'bed' ? (
                            <SingleBedIcon sx={{ mr: 1 }} />
                        ) : room.accommodation_type === 'apartment' ? (
                            <ApartmentIcon sx={{ mr: 1 }} />
                        ) : (
                            <HotelIcon sx={{ mr: 1 }} />
                        )}
                        <Typography variant="subtitle1" component="div">
                            {room.name}
                        </Typography>
                    </Box>
                    <Typography variant="body2" color="text.secondary" gutterBottom>
                        {room.address_street}, {room.address_city}
                    </Typography>
                    <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5, mb: 1.5 }}>
                        <Chip
                            size="small"
                            label={`${room.price_per_night} ₽/ночь`}
                            color="primary"
                        />
                        {room.accommodation_type === 'bed' && (
                            <Chip
                                size="small"
                                label={`${room.available_beds}/${room.total_beds} мест`}
                                color="secondary"
                            />
                        )}
                    </Box>
                    <Button
                        variant="contained"
                        size="small"
                        fullWidth
                        onClick={(e) => {
                            e.stopPropagation();
                            onRoomSelect(room);
                        }}
                    >
                        Забронировать
                    </Button>
                </CardContent>
            </Card>
        );
    };

    return (
        <Box sx={{ position: 'relative' }}>
            <GoogleMap
                mapContainerStyle={mapContainerStyle}
                center={defaultCenter}
                zoom={13}
                onLoad={onMapLoad}
                options={getMapOptions()}
            >
                {rooms?.map((room) => {
                    if (room.latitude && room.longitude) {
                        const lat = parseFloat(room.latitude);
                        const lng = parseFloat(room.longitude);

                        if (!isNaN(lat) && !isNaN(lng)) {
                            const icon = {
                                path: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7z",  // SVG path для капли
                                fillColor: room.accommodation_type === 'bed'
                                    ? '#1976d2'
                                    : room.accommodation_type === 'apartment'
                                        ? '#dc004e'
                                        : '#4caf50',
                                fillOpacity: 1,
                                strokeWeight: 1,
                                strokeColor: '#ffffff',
                                scale: 2,
                                anchor: new window.google.maps.Point(12, 22),
                                labelOrigin: new window.google.maps.Point(12, 9)
                            };

                            const label = {
                                text: room.accommodation_type === 'bed'
                                    ? '🛏️'
                                    : room.accommodation_type === 'apartment'
                                        ? '🏢'
                                        : '🏠',
                                color: '#FFFFFF',
                                fontSize: '14px'
                            };

                            return (
                                <Marker
                                    key={room.id}
                                    position={{ lat, lng }}
                                    onClick={() => setSelectedRoom(room)}
                                    icon={icon}
                                    label={label}
                                />
                            );
                        }
                    }
                    return null;
                })}

                {selectedRoom && (
                    <InfoWindow
                        position={{
                            lat: parseFloat(selectedRoom.latitude),
                            lng: parseFloat(selectedRoom.longitude)
                        }}
                        onCloseClick={() => setSelectedRoom(null)}
                    >
                        <InfoWindowContent room={selectedRoom} />
                    </InfoWindow>
                )}
            </GoogleMap>
            <Button
                variant="contained"
                startIcon={<MyLocationIcon />}
                onClick={handleMyLocation}
                sx={{
                    position: 'absolute',
                    top: '10px',
                    right: '60px',
                    backgroundColor: 'white',
                    color: 'black',
                    '&:hover': {
                        backgroundColor: '#f5f5f5',
                    },
                    boxShadow: '0 2px 6px rgba(0,0,0,.3)',
                }}
            >
                Моё местоположение
            </Button>
        </Box>
    );
};

export default MapView;

--- Содержимое файла: frontend/hostel-frontend/src/components/AddBooking.js ---

import React, { useState, useEffect } from "react";
import {
  Container,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  MenuItem,
  Grid
} from "@mui/material";
import axios from "../api/axios";

const AddBooking = () => {
  const [booking, setBooking] = useState({
    user_id: "",
    room_id: "",
    start_date: "",
    end_date: ""
  });
  
  const [rooms, setRooms] = useState([]); // Список всех комнат
  const [users, setUsers] = useState([]); // Список всех пользователей
  const [error, setError] = useState("");
  const [success, setSuccess] = useState(false);

  // Загрузка списка комнат и пользователей
  useEffect(() => {
    const fetchData = async () => {
      try {
        const [roomsResponse, usersResponse] = await Promise.all([
          axios.get("/rooms"),
          axios.get("/users")
        ]);
        setRooms(roomsResponse.data);
        setUsers(usersResponse.data);
      } catch (error) {
        console.error("Ошибка загрузки данных:", error);
      }
    };
    fetchData();
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setSuccess(false);

    try {
      await axios.post("/bookings", {
        ...booking,
        user_id: parseInt(booking.user_id),
        room_id: parseInt(booking.room_id)
      });
      setSuccess(true);
      setBooking({
        user_id: "",
        room_id: "",
        start_date: "",
        end_date: ""
      });
    } catch (error) {
      setError(error.response?.data || "Ошибка добавления бронирования");
      console.error("Ошибка добавления бронирования:", error);
    }
  };

  // Получаем текущую дату для ограничения выбора дат
  const today = new Date().toISOString().split('T')[0];

  return (
    <Container maxWidth="sm">
      <Box sx={{ mt: 4, mb: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Добавить бронирование (Админ)
        </Typography>

        {success && (
          <Alert severity="success" sx={{ mb: 2 }}>
            Бронирование добавлено успешно!
          </Alert>
        )}

        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}

        <form onSubmit={handleSubmit}>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <TextField
                select
                label="Пользователь"
                fullWidth
                value={booking.user_id}
                onChange={(e) => setBooking({ ...booking, user_id: e.target.value })}
              >
                {users.map((user) => (
                  <MenuItem key={user.id} value={user.id}>
                    {user.name} ({user.email})
                  </MenuItem>
                ))}
              </TextField>
            </Grid>

            <Grid item xs={12}>
              <TextField
                select
                label="Комната"
                fullWidth
                value={booking.room_id}
                onChange={(e) => setBooking({ ...booking, room_id: e.target.value })}
              >
                {rooms.map((room) => (
                  <MenuItem key={room.id} value={room.id}>
                    {room.name} ({room.address_city}, {room.price_per_night} евро/сутки)
                  </MenuItem>
                ))}
              </TextField>
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                label="Дата заезда"
                type="date"
                fullWidth
                InputLabelProps={{ shrink: true }}
                value={booking.start_date}
                onChange={(e) => setBooking({ ...booking, start_date: e.target.value })}
                inputProps={{ min: today }}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                label="Дата выезда"
                type="date"
                fullWidth
                InputLabelProps={{ shrink: true }}
                value={booking.end_date}
                onChange={(e) => setBooking({ ...booking, end_date: e.target.value })}
                inputProps={{ min: booking.start_date || today }}
              />
            </Grid>

            <Grid item xs={12}>
              <Button
                type="submit"
                variant="contained"
                color="primary"
                fullWidth
                size="large"
              >
                Добавить бронирование
              </Button>
            </Grid>
          </Grid>
        </form>
      </Box>
    </Container>
  );
};

export default AddBooking;

--- Содержимое файла: frontend/hostel-frontend/src/components/BookRoom.js ---



--- Содержимое файла: frontend/hostel-frontend/src/components/BookingDialog.js ---

import React, { useState, useEffect } from 'react';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Button,
    TextField,
    Box,
    Typography,
    Alert,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Grid,
//    Tooltip,
    Popover,
} from '@mui/material';
import axios from "../api/axios";

const BACKEND_URL = 'http://192.168.100.14:3000';

const BookingDialog = ({ open, onClose, room, startDate, endDate }) => {
    const [userId, setUserId] = useState('');
    const [error, setError] = useState('');
    const [success, setSuccess] = useState(false);
    const [selectedBed, setSelectedBed] = useState('');
    const [availableBeds, setAvailableBeds] = useState([]);
    const [bedImages, setBedImages] = useState({});
    const [anchorEl, setAnchorEl] = useState(null);
    const [activeBed, setActiveBed] = useState(null);
    // Добавляем состояния для дат
    const [bookingStartDate, setBookingStartDate] = useState(startDate);
    const [bookingEndDate, setBookingEndDate] = useState(endDate);

    useEffect(() => {
        if (open && room && room.accommodation_type === 'bed' && bookingStartDate && bookingEndDate) {
            // Сбрасываем предыдущий выбор койки при изменении дат
            setSelectedBed('');
            setError('');

            axios.get(`/rooms/${room.id}/available-beds`, {
                params: {
                    start_date: bookingStartDate,
                    end_date: bookingEndDate
                }
            })
                .then(response => {
                    setAvailableBeds(response.data);
                    response.data.forEach(bed => {
                        axios.get(`/beds/${bed.id}/images`)
                            .then(imgResponse => {
                                setBedImages(prev => ({
                                    ...prev,
                                    [bed.id]: imgResponse.data
                                }));
                            })
                            .catch(console.error);
                    });
                })
                .catch(err => {
                    console.error('Ошибка загрузки доступных койко-мест:', err);
                    setError('Не удалось загрузить список доступных койко-мест');
                });
        }
    }, [open, room, bookingStartDate, bookingEndDate]);
    const handleMouseEnter = (event, bed) => {
        if (bedImages[bed.id]?.length > 0) {
            setActiveBed(bed);
            setAnchorEl(event.currentTarget);
        }
    };

    const handleMouseLeave = () => {
        setActiveBed(null);
        setAnchorEl(null);
    };

    const renderBedImage = () => {
        if (!activeBed || !bedImages[activeBed.id]?.length) return null;

        const image = bedImages[activeBed.id][0];
        return (
            <Box sx={{ p: 1 }}>
                <img
                    src={`${BACKEND_URL}/uploads/${image.file_path}`}
                    alt={`Койко-место ${activeBed.bed_number}`}
                    style={{
                        width: '200px',
                        height: '150px',
                        objectFit: 'cover',
                        borderRadius: '4px'
                    }}
                />
            </Box>
        );
    };

    const calculateTotalPrice = () => {
        if (!startDate || !endDate) return 0;

        const start = new Date(startDate);
        const end = new Date(endDate);
        const daysCount = Math.ceil((end - start) / (1000 * 60 * 60 * 24));

        let pricePerNight;
        if (room.accommodation_type === 'bed' && selectedBed) {
            const selectedBedData = availableBeds.find(bed => bed.id === selectedBed);
            pricePerNight = selectedBedData ? selectedBedData.price_per_night : 0;
        } else {
            pricePerNight = room.price_per_night;
        }

        return pricePerNight * daysCount;
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setSuccess(false);

        if (!startDate || !endDate) {
            setError('Выберите даты проживания');
            return;
        }

        if (!userId) {
            setError('Введите ID пользователя');
            return;
        }

        if (room.accommodation_type === 'bed' && !selectedBed) {
            setError('Выберите койко-место');
            return;
        }

        if (startDate === endDate) {
            setError('Дата выезда должна быть позже даты заезда');
            return;
        }

        try {
            const bookingData = {
                user_id: parseInt(userId),
                room_id: room.id,
                start_date: startDate,
                end_date: endDate
            };

            if (room.accommodation_type === 'bed') {
                bookingData.bed_id = selectedBed;
            }

            await axios.post('/bookings', bookingData);
            setSuccess(true);

            setTimeout(() => {
                onClose();
                setUserId('');
                setSelectedBed('');
                setError('');
                setSuccess(false);
            }, 2000);
        } catch (error) {
            setError(error.response?.data || 'Произошла ошибка при бронировании');
        }
    };

    const getDialogTitle = () => {
        switch (room?.accommodation_type) {
            case 'bed':
                return 'Бронирование койко-места';
            case 'apartment':
                return 'Бронирование квартиры';
            default:
                return 'Бронирование комнаты';
        }
    };

    const today = new Date().toISOString().split('T')[0];

    return (
        <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
            <DialogTitle>{getDialogTitle()}</DialogTitle>
            <DialogContent>
                {success && (
                    <Alert severity="success" sx={{ mt: 2 }}>
                        Бронирование успешно создано!
                    </Alert>
                )}
                {error && (
                    <Alert severity="error" sx={{ mt: 2 }}>
                        {error}
                    </Alert>
                )}
                {room && (
                    <Box sx={{ mt: 2 }}>
                        <Typography variant="h6">{room.name}</Typography>
                        <Typography variant="body2" color="text.secondary">
                            {room.address_street}, {room.address_city}
                        </Typography>

                        {/* Добавляем поля выбора дат */}
                        <Grid container spacing={2} sx={{ mt: 1, mb: 2 }}>
                            <Grid item xs={12} sm={6}>
                                <TextField
                                    label="Дата заезда"
                                    type="date"
                                    fullWidth
                                    value={bookingStartDate}
                                    onChange={(e) => setBookingStartDate(e.target.value)}
                                    inputProps={{ min: today }}
                                    InputLabelProps={{ shrink: true }}
                                />
                            </Grid>
                            <Grid item xs={12} sm={6}>
                                <TextField
                                    label="Дата выезда"
                                    type="date"
                                    fullWidth
                                    value={bookingEndDate}
                                    onChange={(e) => setBookingEndDate(e.target.value)}
                                    inputProps={{ min: bookingStartDate || today }}
                                    InputLabelProps={{ shrink: true }}
                                />
                            </Grid>
                        </Grid>

                        {/* Остальные элементы диалога... */}
                        {room.accommodation_type === 'bed' && (
                            <FormControl fullWidth sx={{ mt: 2 }}>
                                <InputLabel>Выберите койко-место</InputLabel>
                                <Select
                                    value={selectedBed}
                                    onChange={(e) => setSelectedBed(e.target.value)}
                                    label="Выберите койко-место"
                                >
                                    {availableBeds.map(bed => (
                                        <MenuItem
                                            key={bed.id}
                                            value={bed.id}
                                            onMouseEnter={(e) => handleMouseEnter(e, bed)}
                                            onMouseLeave={handleMouseLeave}
                                        >
                                            Место {bed.bed_number} - {bed.price_per_night} руб./ночь
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        )}

                        <TextField
                            margin="dense"
                            label="ID пользователя"
                            type="number"
                            fullWidth
                            value={userId}
                            onChange={(e) => setUserId(e.target.value)}
                            sx={{ mt: 2 }}
                        />

                        <Typography variant="h6" sx={{ mt: 2 }}>
                            Итого к оплате: {calculateTotalPrice()} руб.
                        </Typography>
                    </Box>
                )}

                {/* Popover для предпросмотра изображений */}
                <Popover
                    open={Boolean(anchorEl)}
                    anchorEl={anchorEl}
                    onClose={handleMouseLeave}
                    anchorOrigin={{
                        vertical: 'center',
                        horizontal: 'right',
                    }}
                    transformOrigin={{
                        vertical: 'center',
                        horizontal: 'left',
                    }}
                    sx={{
                        pointerEvents: 'none',
                    }}
                >
                    {renderBedImage()}
                </Popover>
            </DialogContent>
            <DialogActions>
                <Button onClick={onClose} color="inherit">
                    Отмена
                </Button>
                <Button
                    onClick={handleSubmit}
                    color="primary"
                    variant="contained"
                    disabled={!userId ||
                        !bookingStartDate ||
                        !bookingEndDate ||
                        bookingStartDate === bookingEndDate ||
                        (room?.accommodation_type === 'bed' && !selectedBed)}
                >
                    Забронировать
                </Button>
            </DialogActions>
        </Dialog>
    );
};

export default BookingDialog;

--- Содержимое файла: frontend/hostel-frontend/src/components/AdminPanel.js ---



--- Содержимое файла: frontend/hostel-frontend/src/components/LocationPicker.js ---

import React, { useState, useCallback } from 'react';
import { GoogleMap, LoadScript, Marker } from '@react-google-maps/api';
import {
    Box,
    TextField,
    Paper,
    Typography,
    InputAdornment,
    IconButton,
} from '@mui/material';
import { Search as SearchIcon, MyLocation as MyLocationIcon } from '@mui/icons-material';

const libraries = ["places", "geometry"];

const LocationPicker = ({ onLocationSelect }) => {
    const [map, setMap] = useState(null);
    const [marker, setMarker] = useState(null);
    const [address, setAddress] = useState('');
    const [searchBox, setSearchBox] = useState(null);

    const mapContainerStyle = {
        width: '100%',
        height: '400px'
    };

    const defaultCenter = {
        lat: 45.2671, // Нови-Сад
        lng: 19.8335
    };

    const mapOptions = {
        scrollwheel: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
            style: 'DEFAULT',
            mapTypeIds: ["roadmap", "satellite", "hybrid"]
        },
        streetViewControl: false,
        fullscreenControl: false,
    };

    // Добавьте новую функцию handleLocationSelect перед onMapLoad
    const handleLocationSelect = (location) => {
        const getAddressComponent = (type) => {
            return location.address_components?.find(
                component => component.types.includes(type)
            )?.long_name || '';
        };

        // Получаем номер дома и улицу отдельно
        const streetNumber = getAddressComponent('street_number');
        const route = getAddressComponent('route');

        // Формируем полный адрес улицы с номером дома
        const fullStreetAddress = route
            ? (streetNumber ? `${route}, ${streetNumber}` : route)
            : '';

        // Передаем данные в родительский компонент
        onLocationSelect({
            latitude: location.latitude,
            longitude: location.longitude,
            formatted_address: location.formatted_address,
            // Передаем сформированный адрес с номером дома
            address_components: {
                street: fullStreetAddress || getAddressComponent('sublocality') || '',
                city: getAddressComponent('locality'),
                state: getAddressComponent('administrative_area_level_1'),
                country: getAddressComponent('country'),
                postal_code: getAddressComponent('postal_code')
            }
        });
    };

    const onMapLoad = useCallback((map) => {
        setMap(map);
        // Инициализируем поисковую строку после загрузки карты
        const searchInput = document.getElementById('location-search');
        if (searchInput && window.google) {
            const searchBoxInstance = new window.google.maps.places.SearchBox(searchInput);
            setSearchBox(searchBoxInstance);

            searchBoxInstance.addListener('places_changed', () => {
                const places = searchBoxInstance.getPlaces();
                if (places.length === 0) return;

                const place = places[0];
                if (!place.geometry) return;

                // Центрируем карту на найденном месте
                map.setCenter(place.geometry.location);
                map.setZoom(17);

                // Устанавливаем маркер
                setMarker({
                    lat: place.geometry.location.lat(),
                    lng: place.geometry.location.lng()
                });

                // Обновляем адрес
                setAddress(place.formatted_address);

                // Вызываем обработчик с данными места
                handleLocationSelect({
                    latitude: place.geometry.location.lat(),
                    longitude: place.geometry.location.lng(),
                    formatted_address: place.formatted_address,
                    address_components: place.address_components
                });
            });
        }
    }, [onLocationSelect]);

    const handleMapClick = useCallback((e) => {
        const lat = e.latLng.lat();
        const lng = e.latLng.lng();

        setMarker({ lat, lng });

        if (window.google) {
            const geocoder = new window.google.maps.Geocoder();
            geocoder.geocode(
                { location: { lat, lng } },
                (results, status) => {
                    if (status === 'OK' && results[0]) {
                        const place = results[0];
                        setAddress(place.formatted_address);
                        const location = {
                            latitude: lat,
                            longitude: lng,
                            formatted_address: place.formatted_address,
                            address_components: place.address_components
                        };
                        handleLocationSelect(location);
                    }
                }
            );
        }
    }, []);

    const handleCurrentLocation = () => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;

                    // Центрируем карту и устанавливаем маркер
                    if (map) {
                        map.setCenter({ lat, lng });
                        map.setZoom(17);
                        setMarker({ lat, lng });
                    }

                    // Получаем адрес по координатам
                    if (window.google) {
                        const geocoder = new window.google.maps.Geocoder();
                        geocoder.geocode(
                            { location: { lat, lng } },
                            (results, status) => {
                                if (status === 'OK' && results[0]) {
                                    const place = results[0];
                                    setAddress(place.formatted_address);
                                    handleLocationSelect({
                                        latitude: lat,
                                        longitude: lng,
                                        formatted_address: place.formatted_address,
                                        address_components: place.address_components
                                    });
                                }
                            }
                        );
                    }
                },
                (error) => {
                    console.error("Error getting current location:", error);
                    alert("Не удалось получить текущее местоположение");
                }
            );
        } else {
            alert("Геолокация не поддерживается вашим браузером");
        }
    };

    return (
        <Paper sx={{ p: 2 }}>
            <Typography variant="h6" gutterBottom>
                Выберите местоположение объекта
            </Typography>
            <Box sx={{ mb: 2 }}>
                <TextField
                    id="location-search"
                    fullWidth
                    placeholder="Поиск по адресу..."
                    value={address}
                    onChange={(e) => setAddress(e.target.value)}
                    InputProps={{
                        startAdornment: (
                            <InputAdornment position="start">
                                <SearchIcon />
                            </InputAdornment>
                        ),
                        endAdornment: (
                            <InputAdornment position="end">
                                <IconButton
                                    onClick={handleCurrentLocation}
                                    title="Мое местоположение"
                                >
                                    <MyLocationIcon />
                                </IconButton>
                            </InputAdornment>
                        )
                    }}
                />
            </Box>
            <LoadScript
                googleMapsApiKey={process.env.REACT_APP_GOOGLE_MAPS_API_KEY}
                libraries={libraries}
            >
                <GoogleMap
                    mapContainerStyle={mapContainerStyle}
                    center={defaultCenter}
                    zoom={13}
                    onLoad={onMapLoad}
                    onClick={handleMapClick}
                    options={mapOptions}
                >
                    {marker && (
                        <Marker
                            position={marker}
                            draggable={true}
                            onDragEnd={(e) => handleMapClick(e)}
                        />
                    )}
                </GoogleMap>
            </LoadScript>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Кликните по карте или введите адрес для выбора местоположения
            </Typography>
        </Paper>
    );
};

export default LocationPicker;

--- Содержимое файла: frontend/hostel-frontend/src/components/AddUser.js ---

import React, { useState } from "react";
import { TextField, Button, Container, Typography } from "@mui/material";
import axios from "../api/axios";

const AddUser = () => {
  const [user, setUser] = useState({ name: "", email: "" });

  const handleSubmit = async (e) => {
    e.preventDefault();
    await axios.post("http://192.168.100.14:3000/users", user);
    alert("Пользователь добавлен!");
  };

  return (
    <Container>
      <Typography variant="h4" gutterBottom>
        Добавить пользователя
      </Typography>
      <form onSubmit={handleSubmit}>
        <TextField
          label="Имя"
          fullWidth
          margin="normal"
          value={user.name}
          onChange={(e) => setUser({ ...user, name: e.target.value })}
        />
        <TextField
          label="Email"
          type="email"
          fullWidth
          margin="normal"
          value={user.email}
          onChange={(e) => setUser({ ...user, email: e.target.value })}
        />
        <Button type="submit" variant="contained" color="primary">
          Добавить
        </Button>
      </form>
    </Container>
  );
};

export default AddUser;


--- Содержимое файла: frontend/hostel-frontend/src/components/RoomList.js ---

import React, { useState, useEffect, useCallback } from 'react';
import axios from "../api/axios";
import { Chip } from '@mui/material';
import { LoadScript } from '@react-google-maps/api';
import {
    Grid, Card, CardContent, Typography, TextField,
    Button, Divider, Box, Dialog, DialogContent, IconButton,
    MobileStepper, CardMedia,
    ToggleButton,
    ToggleButtonGroup,
    Paper,
    ButtonGroup
} from "@mui/material";
import {
    KeyboardArrowLeft, KeyboardArrowRight,
    Close as CloseIcon,
    SingleBed as HotelIcon,
    Hotel as SingleBedIcon,
    Apartment as ApartmentIcon,
    Home as HomeIcon,
    ViewList as ViewListIcon,
    Map as MapIcon,
    Search as SearchIcon
} from '@mui/icons-material';
import BookingDialog from "./BookingDialog";
import MapView from './MapView';


const BACKEND_URL = 'http://192.168.100.14:3000';

const ImageGallery = ({ images, open, onClose }) => {
    const [activeStep, setActiveStep] = useState(0);
    const maxSteps = images.length;

    const handleNext = () => {
        setActiveStep((prevStep) => (prevStep + 1) % maxSteps);
    };

    const handleBack = () => {
        setActiveStep((prevStep) => (prevStep - 1 + maxSteps) % maxSteps);
    };

    if (!images.length) return null;

    return (
        <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
            <DialogContent sx={{ position: 'relative', p: 0 }}>
                <IconButton
                    onClick={onClose}
                    sx={{
                        position: 'absolute',
                        right: 8,
                        top: 8,
                        color: 'white',
                        bgcolor: 'rgba(0, 0, 0, 0.5)',
                        '&:hover': {
                            bgcolor: 'rgba(0, 0, 0, 0.7)',
                        },
                    }}
                >
                    <CloseIcon />
                </IconButton>
                <Box sx={{ height: '80vh', display: 'flex', flexDirection: 'column', justifyContent: 'center' }}>
                    <img
                        src={`${BACKEND_URL}/uploads/${images[activeStep].file_path}`} // Исправлено здесь
                        alt={images[activeStep].file_name}
                        style={{
                            width: '100%',
                            height: '100%',
                            objectFit: 'contain',
                        }}
                    />
                    <MobileStepper
                        steps={maxSteps}
                        position="static"
                        activeStep={activeStep}
                        sx={{
                            bgcolor: 'background.default',
                            position: 'absolute',
                            bottom: 0,
                            width: '100%',
                        }}
                        nextButton={
                            <Button size="small" onClick={handleNext}>
                                Следующее
                                <KeyboardArrowRight />
                            </Button>
                        }
                        backButton={
                            <Button size="small" onClick={handleBack}>
                                <KeyboardArrowLeft />
                                Предыдущее
                            </Button>
                        }
                    />
                </Box>
            </DialogContent>
        </Dialog>
    );
};

const RoomList = () => {
    const [rooms, setRooms] = useState([]);
    const [filters, setFilters] = useState({
        capacity: "",
        min_price: "",
        max_price: "",
        city: "",
        country: "",
        start_date: "",
        end_date: "",
        type: ''
    });

    const handleTypeFilter = (type) => {
        setFilters(prev => ({
            ...prev,
            type: prev.type === type ? '' : type // сброс фильтра при повторном нажатии
        }));
    };


    const [viewMode, setViewMode] = useState('list'); // 'list' или 'map'
    const [roomsWithCoordinates, setRoomsWithCoordinates] = useState([]);
    const geocodeRooms = async (rooms) => {
        if (!window.google) return rooms;

        const geocoder = new window.google.maps.Geocoder();
        const geocodeAddress = async (room) => {
            const address = `${room.address_street}, ${room.address_city}, ${room.address_country}`;
            try {
                const result = await new Promise((resolve, reject) => {
                    geocoder.geocode({ address }, (results, status) => {
                        if (status === 'OK') {
                            resolve(results[0].geometry.location);
                        } else {
                            reject(status);
                        }
                    });
                });

                return {
                    ...room,
                    latitude: result.lat(),
                    longitude: result.lng()
                };
            } catch (error) {
                console.error(`Error geocoding address: ${address}`, error);
                return room;
            }
        };

        const roomsWithCoords = await Promise.all(rooms.map(geocodeAddress));
        return roomsWithCoords;
    };
    const [selectedRoom, setSelectedRoom] = useState(null);
    const [galleryOpen, setGalleryOpen] = useState(false);
    const [bookingDialogOpen, setBookingDialogOpen] = useState(false);

    const fetchRooms = useCallback(async () => {
        try {
            const params = new URLSearchParams();

            // Добавляем базовые параметры
            if (filters.capacity && parseInt(filters.capacity) > 0) {
                params.append('capacity', filters.capacity);
            }
            if (filters.min_price && parseFloat(filters.min_price) > 0) {
                params.append('min_price', filters.min_price);
            }
            if (filters.max_price && parseFloat(filters.max_price) > 0) {
                params.append('max_price', filters.max_price);
            }
            if (filters.city?.trim()) {
                params.append('city', filters.city.trim());
            }
            if (filters.country?.trim()) {
                params.append('country', filters.country.trim());
            }

            // Добавляем фильтр по типу размещения
            if (filters.type) {
                params.append('accommodation_type', filters.type);
                if (filters.type === 'room') {
                    params.append('has_private_rooms', 'true');
                }
            }

            // Всегда отправляем даты для проверки доступности
            const today = new Date().toISOString().split('T')[0];
            params.append('start_date', filters.start_date || today);
            params.append('end_date', filters.end_date || today);

            const response = await axios.get(`/rooms?${params.toString()}`);
            const roomsData = response.data || [];

            // Фильтрация на фронтенде
            const filteredRooms = roomsData.filter(room => {
                // Базовая проверка доступности
                if (room.accommodation_type === 'bed' && room.available_beds <= 0) {
                    return false;
                }

                // Проверка типа размещения
                if (filters.type && room.accommodation_type !== filters.type) {
                    return false;
                }

                // Проверка для приватных комнат
                if (filters.type === 'room' && room.is_shared) {
                    return false;
                }

                return true;
            });

            // Получаем изображения для отфильтрованных комнат
            const roomsWithImages = await Promise.all(
                filteredRooms.map(async (room) => {
                    const imagesResponse = await axios.get(`/rooms/${room.id}/images`);
                    return {
                        ...room,
                        images: imagesResponse.data || []
                    };
                })
            );

            setRooms(roomsWithImages);
            setRoomsWithCoordinates(roomsWithImages.filter(room =>
                room.latitude && room.longitude));

        } catch (error) {
            console.error("Ошибка при получении списка комнат:", error);
        }
    }, [filters]);

    const handleDateChange = (field, value) => {
        setFilters(prev => {
            const newFilters = { ...prev, [field]: value };

            if (field === 'end_date' && newFilters.start_date && value < newFilters.start_date) {
                return prev;
            }

            if (field === 'start_date' && newFilters.end_date && value > newFilters.end_date) {
                return prev;
            }

            return newFilters;
        });
    };

    const handleBooking = (room) => {
        if (!filters.start_date || !filters.end_date) {
            alert('Пожалуйста, выберите даты заезда и выезда');
            return;
        }
        setSelectedRoom(room);
        setBookingDialogOpen(true);
    };


    useEffect(() => {
        fetchRooms();
    }, [fetchRooms]);

    const AccommodationInfo = ({ room }) => {
        const getAccommodationInfo = () => {
            switch (room.accommodation_type) {
                case 'bed':
                    return {
                        title: 'Койко-место',
                        details: `Доступно ${room.available_beds} из ${room.total_beds} мест`,
                        icon: <HotelIcon />,
                        shared: true
                    };
                case 'room':
                    return {
                        title: room.is_shared ? 'Общая комната' : 'Отдельная комната',
                        details: `Вместимость: ${room.capacity} чел.`,
                        icon: <SingleBedIcon />,
                        shared: room.is_shared
                    };
                case 'apartment':
                    return {
                        title: 'Квартира',
                        details: `${room.capacity} комнат`,
                        icon: <ApartmentIcon />,
                        shared: false
                    };
                default:
                    return {
                        title: 'Помещение',
                        details: `Вместимость: ${room.capacity} чел.`,
                        icon: <HomeIcon />,
                        shared: false
                    };
            }
        };

        const info = getAccommodationInfo();

        return (
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                {info.icon}
                <Box>
                    <Typography variant="subtitle2" sx={{ fontWeight: 'medium' }}>
                        {info.title}
                        {info.shared && (
                            <Chip
                                size="small"
                                label="Общее помещение"
                                color="secondary"
                                sx={{ ml: 1 }}
                            />
                        )}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                        {info.details}
                    </Typography>
                </Box>
            </Box>
        );
    };


    const today = new Date().toISOString().split('T')[0];

    return (
        <div>

            <Grid container spacing={2} sx={{ mb: 3, mt: 1 }}>
                {/* Первая строка с датами, городом, страной и ценами */}
                <Grid item container spacing={2} xs={12}>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Дата заезда"
                            type="date"
                            size="small"
                            fullWidth
                            InputLabelProps={{ shrink: true }}
                            value={filters.start_date}
                            onChange={(e) => handleDateChange('start_date', e.target.value)}
                            inputProps={{ min: today }}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Дата выезда"
                            type="date"
                            size="small"
                            fullWidth
                            InputLabelProps={{ shrink: true }}
                            value={filters.end_date}
                            onChange={(e) => handleDateChange('end_date', e.target.value)}
                            inputProps={{ min: filters.start_date || today }}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Город"
                            size="small"
                            fullWidth
                            value={filters.city}
                            onChange={(e) => setFilters({ ...filters, city: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Страна"
                            size="small"
                            fullWidth
                            value={filters.country}
                            onChange={(e) => setFilters({ ...filters, country: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Мин. цена"
                            type="number"
                            size="small"
                            fullWidth
                            value={filters.min_price}
                            onChange={(e) => setFilters({ ...filters, min_price: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} sm={6} md={2}>
                        <TextField
                            label="Макс. цена"
                            type="number"
                            size="small"
                            fullWidth
                            value={filters.max_price}
                            onChange={(e) => setFilters({ ...filters, max_price: e.target.value })}
                        />
                    </Grid>
                </Grid>

                {/* Вторая строка с кнопками */}
                <Grid item container xs={12} spacing={2} alignItems="center">
                    <Grid item>
                        <Button
                            variant="contained"
                            color="primary"
                            onClick={fetchRooms}
                            startIcon={<SearchIcon />}
                        >
                            Найти
                        </Button>
                    </Grid>
                    <Grid item>
                        <ButtonGroup
                            variant="outlined"
                            sx={{
                                '& .MuiButton-root': {
                                    borderColor: '#1976d2',
                                    '&:hover': {
                                        borderColor: '#1976d2',
                                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                    }
                                }
                            }}
                        >
                            <Button
                                onClick={() => handleTypeFilter('apartment')}
                                startIcon={<ApartmentIcon />}
                                color={filters.type === 'apartment' ? 'primary' : 'inherit'}
                            >
                                Аппарты
                            </Button>
                            <Button
                                onClick={() => handleTypeFilter('room')}
                                startIcon={<HotelIcon />}
                                color={filters.type === 'room' ? 'primary' : 'inherit'}
                            >
                                Приватка
                            </Button>
                            <Button
                                onClick={() => handleTypeFilter('bed')}
                                startIcon={<SingleBedIcon />}
                                color={filters.type === 'bed' ? 'primary' : 'inherit'}
                            >
                                Кровать
                            </Button>
                        </ButtonGroup>
                    </Grid>
                    <Grid item sx={{ marginLeft: 'auto' }}>
                        <ToggleButtonGroup
                            value={viewMode}
                            exclusive
                            onChange={(e, newMode) => newMode && setViewMode(newMode)}
                            aria-label="view mode"
                            size="small"
                            sx={{
                                border: '1px solid rgba(25, 118, 210, 0.5)',
                                '& .MuiToggleButton-root': {
                                    '&.Mui-selected': {
                                        backgroundColor: '#1976d2',
                                        color: 'white',
                                        '&:hover': {
                                            backgroundColor: '#1565c0',
                                        }
                                    },
                                    '&:hover': {
                                        backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                    }
                                }
                            }}
                        >
                            <ToggleButton value="list" aria-label="list view">
                                <ViewListIcon /> Список
                            </ToggleButton>
                            <ToggleButton value="map" aria-label="map view">
                                <MapIcon /> Карта
                            </ToggleButton>
                        </ToggleButtonGroup>
                    </Grid>
                </Grid>
            </Grid>
            <Box>
                {viewMode === 'map' ? (
                    <LoadScript
                        googleMapsApiKey={process.env.REACT_APP_GOOGLE_MAPS_API_KEY}
                        libraries={["places", "geometry"]}
                    >
                        <MapView
                            rooms={roomsWithCoordinates}
                            onRoomSelect={(room) => {
                                setSelectedRoom(room);
                                setBookingDialogOpen(true);
                            }}
                            onOpenGallery={(room) => {
                                setSelectedRoom(room);
                                setGalleryOpen(true);
                            }}
                        />
                    </LoadScript>
                ) : (
                    <Grid container spacing={2}>
                        {rooms.map((room) => (
                            <Grid item xs={12} md={6} lg={4} key={room.id}>
                                <Card sx={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    height: '100%',
                                    border: '1px solid rgba(25, 118, 210, 0.2)',
                                    boxShadow: '0 2px 4px rgba(25, 118, 210, 0.1)',
                                    '&:hover': {
                                        boxShadow: '0 4px 8px rgba(25, 118, 210, 0.2)',
                                    },
                                    '& .MuiCardContent-root': {
                                        padding: '12px',
                                    },
                                    '& .MuiTypography-root': {
                                        lineHeight: '1.3',
                                    }
                                }}>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', p: 1.5 }}>
                                        <Box sx={{ flex: 1, pr: 1.5 }}>
                                            <AccommodationInfo room={room} />
                                            <Typography variant="h6" sx={{
                                                mb: 0.5,
                                                fontSize: '1.1rem'
                                            }}>
                                                {room.name}
                                            </Typography>
                                            {room.accommodation_type === 'bed' ? (
                                                <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
                                                    Цена за койко-место: {room.price_per_night} евро/сутки
                                                </Typography>
                                            ) : (
                                                <Typography variant="body2" color="text.secondary" sx={{ mb: 0.5 }}>
                                                    Цена за {room.accommodation_type === 'apartment' ? 'квартиру' : 'комнату'}: {room.price_per_night} евро/сутки
                                                </Typography>
                                            )}
                                        </Box>

                                        {/* Правый верхний угол: эскиз */}
                                        <Box sx={{
                                            width: '100px',
                                            height: '100px',
                                            flexShrink: 0,
                                            p: room.images?.length ? 0 : 1
                                        }}>
                                            {room.images && room.images.length > 0 ? (
                                                <CardMedia
                                                    component="img"
                                                    sx={{
                                                        width: '100%',
                                                        height: '100%',
                                                        objectFit: 'cover',
                                                        borderRadius: '4px',
                                                        '&:hover': {
                                                            opacity: 0.8,
                                                            transition: 'opacity 0.2s ease-in-out',
                                                        },
                                                    }}
                                                    image={`${BACKEND_URL}/uploads/${room.images[0].file_path}`}
                                                    alt={room.name}
                                                    onClick={() => {
                                                        setSelectedRoom(room);
                                                        setGalleryOpen(true);
                                                    }}
                                                />
                                            ) : (
                                                <Box
                                                    sx={{
                                                        width: '100%',
                                                        height: '100%',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        bgcolor: 'grey.100',
                                                        borderRadius: '4px',
                                                        fontSize: '0.8rem'
                                                    }}
                                                >
                                                    <Typography variant="body2" color="text.secondary">
                                                        Нет фото
                                                    </Typography>
                                                </Box>
                                            )}
                                        </Box>
                                    </Box>

                                    <Divider />

                                    {/* Нижняя часть карточки с адресом и кнопками */}
                                    <CardContent sx={{
                                        pt: 1,
                                        pb: '8px !important',
                                        display: 'flex',
                                        justifyContent: 'space-between',
                                        alignItems: 'center'
                                    }}>
                                        <Typography variant="body2" color="text.secondary" sx={{
                                            fontSize: '0.85rem',
                                            flex: 1,
                                            mr: 1
                                        }}>
                                            {room.address_street}
                                            {room.address_city && `, ${room.address_city}`}
                                            {room.address_state && `, ${room.address_state}`}
                                            {room.address_country && `, ${room.address_country}`}
                                            {room.address_postal_code && ` (${room.address_postal_code})`}
                                        </Typography>
                                        <Box sx={{ display: 'flex', gap: 0.5 }}>
                                            {room.images && room.images.length > 1 && (
                                                <Button
                                                    size="small"
                                                    sx={{
                                                        minWidth: 'auto',
                                                        padding: '4px 8px',
                                                        fontSize: '0.8rem',
                                                        borderColor: '#1976d2',
                                                        color: '#1976d2',
                                                        '&:hover': {
                                                            borderColor: '#1565c0',
                                                            backgroundColor: 'rgba(25, 118, 210, 0.04)',
                                                        }
                                                    }}
                                                    onClick={() => {
                                                        setSelectedRoom(room);
                                                        setGalleryOpen(true);
                                                    }}
                                                >
                                                    Все ({room.images.length})
                                                </Button> 
                                            )}
                                            <Button
                                                variant="contained"
                                                color="primary"
                                                size="small"
                                                sx={{
                                                    minWidth: 'auto',
                                                    padding: '4px 8px',
                                                    fontSize: '0.8rem',
                                                    boxShadow: '0 2px 4px rgba(25, 118, 210, 0.2)',
                                                    '&:hover': {
                                                        boxShadow: '0 4px 8px rgba(25, 118, 210, 0.3)',
                                                    }
                                                }}
                                                onClick={() => handleBooking(room)}
                                                disabled={!filters.start_date || !filters.end_date}
                                            >
                                                Забронировать
                                            </Button>
                                        </Box>
                                    </CardContent>
                                </Card>
                            </Grid>

                        ))}
                    </Grid>
                )}
            </Box>
            {selectedRoom && (
                <>
                    <ImageGallery
                        images={selectedRoom.images || []}
                        open={galleryOpen}
                        onClose={() => {
                            setGalleryOpen(false);
                            setSelectedRoom(null);
                        }}
                    />
                    <BookingDialog
                        open={bookingDialogOpen}
                        onClose={() => {
                            setBookingDialogOpen(false);
                            setSelectedRoom(null);
                        }}
                        room={selectedRoom}
                        startDate={filters.start_date}
                        endDate={filters.end_date}
                    />
                </>
            )}
        </div>
    );
};

export default RoomList;

--- Содержимое файла: frontend/hostel-frontend/src/components/AddRoom.js ---

import React, { useState } from "react";
import LocationPicker from './LocationPicker';
import {
    TextField,
    Button,
    Container,
    Typography,
    Box,
    Alert,
    Grid,
    IconButton,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    FormControlLabel,
    Switch
} from "@mui/material";
import { Delete as DeleteIcon, CloudUpload as CloudUploadIcon } from '@mui/icons-material';
import axios from "../api/axios";

const AddRoom = () => {
    const [room, setRoom] = useState({
        name: "",
        accommodation_type: "room",
        capacity: 0,
        price_per_night: 0,
        address_street: "",
        address_city: "",
        address_state: "",
        address_country: "",
        address_postal_code: "",
        is_shared: false,
        total_beds: null,
        available_beds: null,
        has_private_bathroom: true,
        latitude: null,
        longitude: null,
        formatted_address: ''
    });

    const [beds, setBeds] = useState([
        { bed_number: "1", price_per_night: 0, images: [], imagePreviewUrls: [] }
    ]);
    const [images, setImages] = useState([]);
    const [previewUrls, setPreviewUrls] = useState([]);
    const [errorMessage, setErrorMessage] = useState("");
    const [isSuccess, setIsSuccess] = useState(false);

    const handleBedImageChange = (index, e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;

        const validFiles = files.filter(file => {
            if (!file.type.startsWith('image/')) {
                setErrorMessage("Можно загружать только изображения");
                return false;
            }
            if (file.size > 5 * 1024 * 1024) {
                setErrorMessage("Размер файла не должен превышать 5MB");
                return false;
            }
            return true;
        });

        if (validFiles.length === 0) return;

        const newBeds = [...beds];
        newBeds[index] = {
            ...newBeds[index],
            images: [...(newBeds[index].images || []), ...validFiles]
        };

        // Создаем превью для изображений
        validFiles.forEach(file => {
            const reader = new FileReader();
            reader.onloadend = () => {
                newBeds[index].imagePreviewUrls = [
                    ...(newBeds[index].imagePreviewUrls || []),
                    reader.result
                ];
                setBeds([...newBeds]);
            };
            reader.readAsDataURL(file);
        });
    };

    const handleLocationSelect = (location) => {
        setRoom(prev => ({
            ...prev,
            latitude: location.latitude,
            longitude: location.longitude,
            formatted_address: location.formatted_address,
            address_street: location.address_components?.street || '',
            address_city: location.address_components?.city || '',
            address_state: location.address_components?.state || '',
            address_country: location.address_components?.country || '',
            address_postal_code: location.address_components?.postal_code || ''
        }));
    };

    const handleImageChange = (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;

        const validFiles = files.filter(file => {
            if (!file.type.startsWith('image/')) {
                setErrorMessage("Можно загружать только изображения");
                return false;
            }
            if (file.size > 5 * 1024 * 1024) {
                setErrorMessage("Размер файла не должен превышать 5MB");
                return false;
            }
            return true;
        });

        if (validFiles.length === 0) return;

        setImages(prev => [...prev, ...validFiles]);

        validFiles.forEach(file => {
            const reader = new FileReader();
            reader.onloadend = () => {
                setPreviewUrls(prev => [...prev, reader.result]);
            };
            reader.onerror = () => {
                setErrorMessage("Ошибка при чтении файла: " + file.name);
            };
            reader.readAsDataURL(file);
        });
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setErrorMessage("");
        setIsSuccess(false);

        try {
            if (room.accommodation_type === 'bed' && (!room.total_beds || beds.length === 0)) {
                setErrorMessage("Добавьте информацию о кроватях");
                return;
            }

            const roomData = {
                ...room,
                latitude: parseFloat(room.latitude),
                longitude: parseFloat(room.longitude)
            };

            // Создаем комнату
            const roomResponse = await axios.post("/rooms", roomData);
            const roomId = roomResponse.data.id;

            // Если тип размещения - койко-места, создаем кровати и загружаем их изображения
            if (room.accommodation_type === 'bed' && beds.length > 0) {
                await Promise.all(
                    beds.map(async (bed) => {
                        try {
                            // Создаем койко-место
                            const bedResponse = await axios.post(`/rooms/${roomId}/beds`, {
                                bed_number: bed.bed_number,
                                price_per_night: parseFloat(bed.price_per_night)
                            });

                            // Если есть изображения для койко-места, загружаем их
                            if (bed.images && bed.images.length > 0) {
                                const formData = new FormData();
                                bed.images.forEach(image => {
                                    formData.append('images', image);
                                });

                                await axios.post(`/beds/${bedResponse.data.id}/images`, formData, {
                                    headers: {
                                        'Content-Type': 'multipart/form-data'
                                    }
                                });
                            }
                        } catch (error) {
                            console.error('Ошибка добавления кровати или её изображений:', error);
                            throw error;
                        }
                    })
                );
            }

            // Загружаем общие изображения комнаты
            if (images.length > 0) {
                const formData = new FormData();
                images.forEach(image => {
                    formData.append('images', image);
                });

                await axios.post(`/rooms/${roomId}/images`, formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                });
            }

            setIsSuccess(true);
            // Сброс формы
            setRoom({
                name: "",
                accommodation_type: "room",
                capacity: 0,
                price_per_night: 0,
                address_street: "",
                address_city: "",
                address_state: "",
                address_country: "",
                address_postal_code: "",
                is_shared: false,
                total_beds: null,
                available_beds: null,
                has_private_bathroom: true,
                latitude: null,
                longitude: null,
                formatted_address: ''
            });
            setBeds([{ bed_number: "1", price_per_night: 0, images: [], imagePreviewUrls: [] }]);
            setImages([]);
            setPreviewUrls([]);
        } catch (error) {
            console.error('Ошибка при добавлении:', error);
            setErrorMessage(error.response?.data || "Ошибка при добавлении объекта размещения");
        }
    };

    return (
        <Container>
            <Typography variant="h4" gutterBottom>
                Добавить объект размещения
            </Typography>
            {errorMessage && (
                <Alert severity="error" sx={{ mb: 2 }}>
                    {errorMessage}
                </Alert>
            )}
            {isSuccess && (
                <Alert severity="success" sx={{ mb: 2 }}>
                    Объект размещения успешно добавлен
                </Alert>
            )}
            <form onSubmit={handleSubmit}>
                <Grid container spacing={2}>
                    {/* Базовая информация */}
                    <Grid item xs={12}>
                        <TextField
                            label="Название"
                            fullWidth
                            required
                            value={room.name}
                            onChange={(e) => setRoom({ ...room, name: e.target.value })}
                        />
                    </Grid>

                    {/* Тип размещения */}
                    <Grid item xs={12}>
                        <FormControl fullWidth>
                            <InputLabel>Тип размещения</InputLabel>
                            <Select
                                value={room.accommodation_type}
                                onChange={(e) => {
                                    const newType = e.target.value;
                                    setRoom(prev => ({
                                        ...prev,
                                        accommodation_type: newType,
                                        total_beds: newType === 'bed' ? prev.total_beds : null,
                                        available_beds: newType === 'bed' ? prev.available_beds : null,
                                        is_shared: newType === 'bed' ? true : false,
                                    }));
                                }}
                            >
                                <MenuItem value="bed">Койко-место</MenuItem>
                                <MenuItem value="room">Комната</MenuItem>
                                <MenuItem value="apartment">Квартира</MenuItem>
                            </Select>
                        </FormControl>
                    </Grid>

                    {room.accommodation_type === 'bed' ? (
                        <>
                            <Grid item xs={12} md={6}>
                                <TextField
                                    label="Всего кроватей"
                                    type="number"
                                    fullWidth
                                    required
                                    value={room.total_beds || ''}
                                    onChange={(e) => setRoom({
                                        ...room,
                                        total_beds: parseInt(e.target.value) || 0,
                                        available_beds: parseInt(e.target.value) || 0
                                    })}
                                />
                            </Grid>
                            <Grid item xs={12}>
                                {beds.map((bed, index) => (
                                    <Box key={index} sx={{ display: 'flex', gap: 2, mb: 2 }}>
                                        <TextField
                                            label={`Номер кровати ${index + 1}`}
                                            value={bed.bed_number}
                                            onChange={(e) => {
                                                const newBeds = [...beds];
                                                newBeds[index].bed_number = e.target.value;
                                                setBeds(newBeds);
                                            }}
                                        />
                                        <TextField
                                            label="Цена за ночь"
                                            type="number"
                                            value={bed.price_per_night}
                                            onChange={(e) => {
                                                const newBeds = [...beds];
                                                newBeds[index].price_per_night = parseFloat(e.target.value);
                                                setBeds(newBeds);
                                            }}
                                        />
                                        <Box>
                                            <Button
                                                variant="contained"
                                                component="label"
                                                size="small"
                                            >
                                                Фото кровати
                                                <input
                                                    type="file"
                                                    hidden
                                                    multiple
                                                    accept="image/*"
                                                    onChange={(e) => handleBedImageChange(index, e)}
                                                />
                                            </Button>
                                            {bed.imagePreviewUrls && bed.imagePreviewUrls.length > 0 && (
                                                <Box sx={{ mt: 1, display: 'flex', gap: 1 }}>
                                                    {bed.imagePreviewUrls.map((url, imgIndex) => (
                                                        <Box
                                                            key={imgIndex}
                                                            sx={{
                                                                position: 'relative',
                                                                width: 60,
                                                                height: 60
                                                            }}
                                                        >
                                                            <img
                                                                src={url}
                                                                alt={`Preview ${imgIndex}`}
                                                                style={{
                                                                    width: '100%',
                                                                    height: '100%',
                                                                    objectFit: 'cover',
                                                                    borderRadius: '4px'
                                                                }}
                                                            />
                                                            <IconButton
                                                                size="small"
                                                                sx={{
                                                                    position: 'absolute',
                                                                    top: -8,
                                                                    right: -8,
                                                                    bgcolor: 'background.paper'
                                                                }}
                                                                onClick={() => {
                                                                    const newBeds = [...beds];
                                                                    newBeds[index].images.splice(imgIndex, 1);
                                                                    newBeds[index].imagePreviewUrls.splice(imgIndex, 1);
                                                                    setBeds(newBeds);
                                                                }}
                                                            >
                                                                <DeleteIcon fontSize="small" />
                                                            </IconButton>
                                                        </Box>
                                                    ))}
                                                </Box>
                                            )}
                                        </Box>
                                        <IconButton onClick={() => {
                                            const newBeds = [...beds];
                                            newBeds.splice(index, 1);
                                            setBeds(newBeds);
                                        }}>
                                            <DeleteIcon />
                                        </IconButton>
                                    </Box>
                                ))}

                                <Button
                                    variant="outlined"
                                    onClick={() => setBeds([...beds, { bed_number: `${beds.length + 1}`, price_per_night: 0 }])}
                                >
                                    Добавить кровать
                                </Button>
                            </Grid>
                        </>
                    ) : (
                        <>
                            <Grid item xs={12} md={6}>
                                <TextField
                                    label="Вместимость"
                                    type="number"
                                    fullWidth
                                    required
                                    value={room.capacity}
                                    onChange={(e) => setRoom({ ...room, capacity: parseInt(e.target.value) || 0 })}
                                />
                            </Grid>
                            <Grid item xs={12} md={6}>
                                <TextField
                                    label="Цена за ночь"
                                    type="number"
                                    fullWidth
                                    required
                                    value={room.price_per_night}
                                    onChange={(e) => setRoom({ ...room, price_per_night: parseFloat(e.target.value) || 0 })}
                                />
                            </Grid>
                        </>
                    )}

                    <Grid item xs={12}>
                        <FormControlLabel
                            control={
                                <Switch
                                    checked={room.is_shared}
                                    onChange={(e) => setRoom({ ...room, is_shared: e.target.checked })}
                                />
                            }
                            label="Общее помещение"
                        />
                    </Grid>

                    <Grid item xs={12}>
                        <FormControlLabel
                            control={
                                <Switch
                                    checked={room.has_private_bathroom}
                                    onChange={(e) => setRoom({ ...room, has_private_bathroom: e.target.checked })}
                                />
                            }
                            label="Отдельная ванная комната"
                        />
                    </Grid>

                    {/* Выбор местоположения */}
                    <Grid item xs={12}>
                        <LocationPicker onLocationSelect={handleLocationSelect} />
                    </Grid>

                    {/* Адрес */}
                    <Grid item xs={12}>
                        <Typography variant="h6">Адрес</Typography>
                    </Grid>
                    <Grid item xs={12}>
                        <TextField
                            label="Улица"
                            fullWidth
                            required
                            value={room.address_street}
                            onChange={(e) => setRoom({ ...room, address_street: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Город"
                            fullWidth
                            required
                            value={room.address_city}
                            onChange={(e) => setRoom({ ...room, address_city: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Область/Регион"
                            fullWidth
                            value={room.address_state}
                            onChange={(e) => setRoom({ ...room, address_state: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Страна"
                            fullWidth
                            required
                            value={room.address_country}
                            onChange={(e) => setRoom({ ...room, address_country: e.target.value })}
                        />
                    </Grid>
                    <Grid item xs={12} md={6}>
                        <TextField
                            label="Почтовый индекс"
                            fullWidth
                            value={room.address_postal_code}
                            onChange={(e) => setRoom({ ...room, address_postal_code: e.target.value })}
                        />
                    </Grid>

                    {/* Изображения */}
                    <Grid item xs={12}>
                        <Typography variant="h6">Фотографии</Typography>
                        <Box sx={{ mt: 1, mb: 2 }}>
                            <Button
                                variant="contained"
                                component="label"
                                startIcon={<CloudUploadIcon />}
                            >
                                Загрузить изображения
                                <input
                                    type="file"
                                    hidden
                                    multiple
                                    accept="image/*"
                                    onChange={handleImageChange}
                                />
                            </Button>
                        </Box>
                        <Grid container spacing={2}>
                            {previewUrls.map((url, index) => (
                                <Grid item xs={12} sm={4} key={index}>
                                    <Box sx={{ position: 'relative' }}>
                                        <img
                                            src={url}
                                            alt={`Preview ${index}`}
                                            style={{
                                                width: '100%',
                                                height: '200px',
                                                objectFit: 'cover',
                                                borderRadius: '4px'
                                            }}
                                        />
                                        <IconButton
                                            sx={{
                                                position: 'absolute',
                                                top: 8,
                                                right: 8,
                                                bgcolor: 'rgba(255, 255, 255, 0.8)'
                                            }}
                                            onClick={() => {
                                                setImages(prev => prev.filter((_, i) => i !== index));
                                                setPreviewUrls(prev => prev.filter((_, i) => i !== index));
                                            }}
                                        >
                                            <DeleteIcon />
                                        </IconButton>
                                    </Box>
                                </Grid>
                            ))}
                        </Grid>
                    </Grid>

                    <Grid item xs={12}>
                        <Button
                            type="submit"
                            variant="contained"
                            color="primary"
                            fullWidth
                            size="large"
                            disabled={!room.name ||
                                !room.latitude ||
                                !room.longitude ||
                                !room.address_city ||
                                !room.address_country ||
                                (room.accommodation_type === 'bed' && (!room.total_beds || beds.length === 0))}
                        >
                            Добавить
                        </Button>
                    </Grid>
                </Grid>
            </form>
        </Container>
    );
};

export default AddRoom;

--- Содержимое файла: frontend/hostel-frontend/src/components/BookingsList.js ---

import React, { useState, useEffect } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  Box,
  IconButton,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle
} from '@mui/material';
import { Delete as DeleteIcon } from '@mui/icons-material';
import axios from "../api/axios";

const BookingsList = () => {
  const [bookings, setBookings] = useState([]);
  const [rooms, setRooms] = useState({});
  const [users, setUsers] = useState({});
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [bookingToDelete, setBookingToDelete] = useState(null);

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      const bookingsResponse = await axios.get('/bookings');
      setBookings(bookingsResponse.data);

      const roomsResponse = await axios.get('/rooms');
      const roomsMap = {};
      roomsResponse.data.forEach(room => {
        roomsMap[room.id] = room;
      });
      setRooms(roomsMap);

      const usersResponse = await axios.get('/users');
      const usersMap = {};
      usersResponse.data.forEach(user => {
        usersMap[user.id] = user;
      });
      setUsers(usersMap);
    } catch (error) {
      console.error('Ошибка загрузки данных:', error);
    }
  };

  const handleDeleteClick = (booking) => {
    setBookingToDelete(booking);
    setDeleteDialogOpen(true);
  };

  const handleDeleteConfirm = async () => {
    try {
      if (bookingToDelete.bed_id) {
        await axios.delete(`/beds/${bookingToDelete.bed_id}/bookings/${bookingToDelete.id}`);
      } else {
        await axios.delete(`/rooms/${bookingToDelete.room_id}/bookings/${bookingToDelete.id}`);
      }
      setDeleteDialogOpen(false);
      setBookingToDelete(null);
      fetchData(); // Обновляем список после удаления
    } catch (error) {
      console.error('Ошибка удаления бронирования:', error);
      alert('Ошибка удаления бронирования');
    }
  };

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h5" gutterBottom>
        Список бронирований
      </Typography>
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>ID</TableCell>
              <TableCell>Пользователь</TableCell>
              <TableCell>Комната</TableCell>
              <TableCell>Тип размещения</TableCell>
              <TableCell>Дата заезда</TableCell>
              <TableCell>Дата выезда</TableCell>
              <TableCell>Статус</TableCell>
              <TableCell>Действия</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {bookings.map((booking) => (
              <TableRow key={booking.id}>
                <TableCell>{booking.id}</TableCell>
                <TableCell>
                  {users[booking.user_id]?.name || `Пользователь ${booking.user_id}`}
                </TableCell>
                <TableCell>
                  {rooms[booking.room_id]?.name || `Комната ${booking.room_id}`}
                </TableCell>
                <TableCell>
                  {booking.bed_id ? 'Койко-место' : 'Комната целиком'}
                </TableCell>
                <TableCell>{booking.start_date}</TableCell>
                <TableCell>{booking.end_date}</TableCell>
                <TableCell>{booking.status || 'Подтверждено'}</TableCell>
                <TableCell>
                  <IconButton 
                    color="error" 
                    onClick={() => handleDeleteClick(booking)}
                    title="Удалить бронирование"
                  >
                    <DeleteIcon />
                  </IconButton>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>

      {/* Диалог подтверждения удаления */}
      <Dialog
        open={deleteDialogOpen}
        onClose={() => setDeleteDialogOpen(false)}
      >
        <DialogTitle>Подтверждение удаления</DialogTitle>
        <DialogContent>
          <DialogContentText>
            Вы действительно хотите удалить это бронирование?
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteDialogOpen(false)}>Отмена</Button>
          <Button onClick={handleDeleteConfirm} color="error" autoFocus>
            Удалить
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default BookingsList;

--- Содержимое файла: frontend/hostel-frontend/src/pages/AddBookingPage.js ---

import React from "react";
import AddBooking from "../components/AddBooking";

const AddBookingPage = () => <AddBooking />;

export default AddBookingPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/AddRoomPage.js ---

import React from "react";
import AddRoom from "../components/AddRoom";

const AddRoomPage = () => <AddRoom />;

export default AddRoomPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/AddUserPage.js ---

import React from "react";
import AddUser from "../components/AddUser";

const AddUserPage = () => <AddUser />;

export default AddUserPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/HomePage.js ---

// frontend/hostel-frontend/src/pages/HomePage.js
import React from "react";
import { Link } from "react-router-dom";
import { AppBar, Toolbar, Typography, Button, Container } from "@mui/material";
import RoomList from "../components/RoomList";

const HomePage = () => (
  <div>
    <AppBar position="static">
      <Toolbar>
        <Typography variant="h6" sx={{ flexGrow: 1 }}>
          Hostel Booking System
        </Typography>
        <Button color="inherit" component={Link} to="/bookings">
          Бронирования
        </Button>
        <Button color="inherit" component={Link} to="/add-room">
          Добавить комнату
        </Button>
        <Button color="inherit" component={Link} to="/add-user">
          Добавить пользователя
        </Button>
      </Toolbar>
    </AppBar>
    <Container sx={{ marginTop: 4 }}>

      <RoomList />
    </Container>
  </div>
);

export default HomePage;

--- Содержимое файла: frontend/hostel-frontend/src/pages/BookingsListPage.js ---

// frontend/hostel-frontend/src/pages/BookingsListPage.js
import React from 'react';
import { Link } from 'react-router-dom';
import { AppBar, Toolbar, Typography, Button, Container } from '@mui/material';
import BookingsList from '../components/BookingsList';

const BookingsListPage = () => {
  return (
    <div>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            Hostel Booking System
          </Typography>
          <Button color="inherit" component={Link} to="/">
            На главную
          </Button>
        </Toolbar>
      </AppBar>
      <Container sx={{ mt: 4 }}>
        <BookingsList />
      </Container>
    </div>
  );
};

export default BookingsListPage;

--- Содержимое файла: frontend/hostel-frontend/src/pages/BookRoomPage.js ---



--- Содержимое файла: frontend/hostel-frontend/src/pages/AdminPanelPage.js ---

import React from "react";
import AddRoom from "../components/AddRoom";
import AddUser from "../components/AddUser";
import AddBooking from "../components/AddBooking";

const AdminPanelPage = () => (
  <div>
    <h1>Админ-панель</h1>
    <AddRoom />
    <AddUser />
    <AddBooking />
  </div>
);

export default AdminPanelPage;


--- Содержимое файла: frontend/hostel-frontend/src/App.css ---

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


--- Содержимое файла: frontend/hostel-frontend/src/App.js ---

// frontend/hostel-frontend/src/App.js
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { Container } from '@mui/material';
import HomePage from "./pages/HomePage";
import AddRoomPage from "./pages/AddRoomPage";
import AddUserPage from "./pages/AddUserPage";
import BookingsListPage from "./pages/BookingsListPage";
import AdminPanelPage from "./pages/AdminPanelPage";

function App() {
  return (
    <Router>
      <Container>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/bookings" element={<BookingsListPage />} />
          <Route path="/add-room" element={<AddRoomPage />} />
          <Route path="/add-user" element={<AddUserPage />} />
          <Route path="/admin" element={<AdminPanelPage />} />
        </Routes>
      </Container>
    </Router>
  );
}

export default App;

--- Содержимое файла: frontend/hostel-frontend/src/index.css ---

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}


--- Содержимое файла: frontend/hostel-frontend/src/index.js ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { ThemeProvider } from "@mui/material/styles";
import { CssBaseline } from '@mui/material';
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  // Можно добавить кастомные настройки темы
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <App />
    </ThemeProvider>
  </React.StrictMode>
);

reportWebVitals();

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


--- Содержимое файла: deploy/docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

  backend:
    build:
      context: ../backend
    ports:
      - "3000:3000"
    env_file:
      - ../backend/.env
    depends_on:
      - db
    command: ["go", "run", "main.go"]
    networks:
      - hostel_network

  frontend:
    build:
      context: ../frontend/hostel-frontend
    ports:
      - "3001:3000"
    environment:
      - REACT_APP_API_URL=http://192.168.100.14:3000
    networks:
      - hostel_network

volumes:
  db_data:

networks:
  hostel_network:
    driver: bridge


--- Содержимое файла: backend/.env ---

DATABASE_URL=postgres://postgres:password@db:5432/hostel_db?sslmode=disable

--- Содержимое файла: frontend/hostel-frontend/package.json ---

{
  "name": "hostel-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@mui/icons-material": "^5.15.0",
    "@mui/material": "^5.16.7",
    "@react-google-maps/api": "^2.19.3",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.7.7",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.28.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

--- Содержимое файла: frontend/package.json ---

{
  "dependencies": {
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@mui/icons-material": "^5.15.0",
    "@mui/material": "^5.16.7",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "@react-google-maps/api": "^2.19.3",
    "axios": "^1.7.7",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.28.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

--- Содержимое файла: frontend/hostel-frontend/.env ---

REACT_APP_GOOGLE_MAPS_API_KEY=AIzaSyBISWAfMMEdWSIKL9WASQIWeKbSQo4Dv48

--- Содержимое файла: docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    container_name: hostel_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build:
      context: ./backend
    ports:
      - "3000:3000"
    env_file:
      - ./backend/.env
    depends_on:
      - db
    volumes:
      - ./backend/uploads:/app/uploads
    environment:
      - UPLOAD_DIR=/app/uploads
      
  migrate:
    image: migrate/migrate
    volumes:
      - ./backend/migrations:/migrations
    command: [
      "-path", "/migrations",
      "-database", "postgres://postgres:password@db:5432/hostel_db?sslmode=disable",
      "up"
    ]
    depends_on:
      - db

volumes:
  postgres_data:


