--- Содержимое файла: backend/main.go ---

package main

import (
	"context"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/jackc/pgx/v5/pgxpool"
	"log"
	"os"
	"strconv"
	"strings"
	"time"
)

func main() {
	app := fiber.New()

	// Настройка CORS
	app.Use(cors.New(cors.Config{
		AllowOrigins: "http://localhost:3001", // Укажите фронтенд URL
		AllowMethods: "GET,POST,DELETE,PUT",
	}))

	// Подключение к базе данных
	dbURL := os.Getenv("DATABASE_URL")
	pool, err := pgxpool.New(context.Background(), dbURL)
	if err != nil {
		log.Fatalf("Ошибка подключения к базе данных: %v", err)
	}
	defer pool.Close()

	// Главный маршрут
	app.Get("/", func(c *fiber.Ctx) error {
		return c.SendString("Hostel Booking System API с PostgreSQL")
	})

	// Добавление пользователя
	app.Post("/users", func(c *fiber.Ctx) error {
		type User struct {
			Name  string `json:"name"`
			Email string `json:"email"`
		}
	
		var user User
		if err := c.BodyParser(&user); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}
	
		_, err := pool.Exec(context.Background(), "INSERT INTO users (name, email) VALUES ($1, $2)", user.Name, user.Email)
		if err != nil {
			if strings.Contains(err.Error(), "unique constraint") {
				return c.Status(400).SendString("Email уже используется")
			}
			log.Printf("Ошибка добавления пользователя: %v", err)
			return c.Status(500).SendString("Ошибка добавления пользователя")
		}
	
		return c.SendString("Пользователь добавлен успешно")
	})
	

	// Добавление комнаты
	app.Post("/rooms", func(c *fiber.Ctx) error {
		type Room struct {
			Name          string  `json:"name"`
			Capacity      int     `json:"capacity"`
			PricePerNight float64 `json:"price_per_night"`
		}
	
		var room Room
		if err := c.BodyParser(&room); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}
	
		_, err := pool.Exec(context.Background(), "INSERT INTO rooms (name, capacity, price_per_night) VALUES ($1, $2, $3)", room.Name, room.Capacity, room.PricePerNight)
		if err != nil {
			if strings.Contains(err.Error(), "unique constraint") {
				return c.Status(400).SendString("Комната с таким названием уже существует")
			}
			log.Printf("Ошибка добавления комнаты: %v", err)
			return c.Status(500).SendString("Ошибка добавления комнаты")
		}
	
		return c.SendString("Комната добавлена успешно")
	})
	

	// Получение списка комнат с фильтрами
	app.Get("/rooms", func(c *fiber.Ctx) error {
		capacity := c.Query("capacity")
		startDate := c.Query("start_date")
		endDate := c.Query("end_date")
		minPrice := c.Query("min_price")
		maxPrice := c.Query("max_price")
	
		query := "SELECT id, name, capacity, price_per_night, created_at FROM rooms"
		args := []interface{}{}
		conditions := []string{}
	
		if capacity != "" {
			conditions = append(conditions, "capacity >= $"+strconv.Itoa(len(args)+1))
			args = append(args, capacity)
		}
	
		if minPrice != "" {
			minPriceFloat, err := strconv.ParseFloat(minPrice, 64)
			if err != nil {
				return c.Status(400).SendString("Некорректное значение минимальной цены")
			}
			conditions = append(conditions, "price_per_night >= $"+strconv.Itoa(len(args)+1))
			args = append(args, minPriceFloat)
		}
		
		if maxPrice != "" {
			maxPriceFloat, err := strconv.ParseFloat(maxPrice, 64)
			if err != nil {
				return c.Status(400).SendString("Некорректное значение максимальной цены")
			}
			conditions = append(conditions, "price_per_night <= $"+strconv.Itoa(len(args)+1))
			args = append(args, maxPriceFloat)
		
			// Проверяем, что minPrice <= maxPrice
			if minPrice != "" {
				minPriceFloat, _ := strconv.ParseFloat(minPrice, 64)
				if minPriceFloat > maxPriceFloat {
					return c.Status(400).SendString("Минимальная цена не может быть больше максимальной")
				}
			}
		}
	
		if startDate != "" && endDate != "" {
			conditions = append(conditions, `
				id NOT IN (
					SELECT room_id FROM bookings 
					WHERE $`+strconv.Itoa(len(args)+1)+` < end_date 
					  AND $`+strconv.Itoa(len(args)+2)+` > start_date
				)
			`)
			args = append(args, startDate, endDate)
		}
	
		if len(conditions) > 0 {
			query += " WHERE " + strings.Join(conditions, " AND ")
		}
	
		rows, err := pool.Query(context.Background(), query, args...)
		if err != nil {
			log.Printf("Ошибка выполнения запроса: %v", err)
			return c.Status(500).SendString("Ошибка получения списка комнат")
		}
		defer rows.Close()
	
		var rooms []map[string]interface{}
		for rows.Next() {
			var id, capacity int
			var name string
			var pricePerNight float64
			var createdAt time.Time
			if err := rows.Scan(&id, &name, &capacity, &pricePerNight, &createdAt); err != nil {
				log.Printf("Ошибка сканирования строки: %v", err)
				return c.Status(500).SendString("Ошибка обработки данных")
			}
			rooms = append(rooms, map[string]interface{}{
				"id":              id,
				"name":            name,
				"capacity":        capacity,
				"price_per_night": pricePerNight,
				"created_at":      createdAt.Format("2006-01-02 15:04:05"),
			})
		}
	
		return c.JSON(rooms)
	})
	// Добавление бронирования
	app.Post("/bookings", func(c *fiber.Ctx) error {
		type Booking struct {
			UserID    int    `json:"user_id"`
			RoomID    int    `json:"room_id"`
			StartDate string `json:"start_date"`
			EndDate   string `json:"end_date"`
		}
	
		var booking Booking
		if err := c.BodyParser(&booking); err != nil {
			return c.Status(400).SendString("Неверный формат данных")
		}
	
		// Проверяем, существует ли пользователь
		var userCount int
		if err := pool.QueryRow(context.Background(), "SELECT COUNT(*) FROM users WHERE id = $1", booking.UserID).Scan(&userCount); err != nil || userCount == 0 {
			return c.Status(400).SendString("Пользователь не найден")
		}
	
		// Проверяем, существует ли комната
		var roomCount int
		if err := pool.QueryRow(context.Background(), "SELECT COUNT(*) FROM rooms WHERE id = $1", booking.RoomID).Scan(&roomCount); err != nil || roomCount == 0 {
			return c.Status(400).SendString("Комната не найдена")
		}
	
		// Проверяем доступность комнаты
		var count int
		err := pool.QueryRow(context.Background(), `
			SELECT COUNT(*) FROM bookings 
			WHERE room_id = $1 AND $2 < end_date AND $3 > start_date
		`, booking.RoomID, booking.StartDate, booking.EndDate).Scan(&count)
		if err != nil {
			log.Printf("Ошибка проверки доступности комнаты: %v", err)
			return c.Status(500).SendString("Ошибка проверки доступности комнаты")
		}
		if count > 0 {
			return c.Status(400).SendString("Комната занята на указанные даты")
		}
	
		_, err = pool.Exec(context.Background(), `
			INSERT INTO bookings (user_id, room_id, start_date, end_date) 
			VALUES ($1, $2, $3, $4)
		`, booking.UserID, booking.RoomID, booking.StartDate, booking.EndDate)
		if err != nil {
			log.Printf("Ошибка добавления бронирования: %v", err)
			return c.Status(500).SendString("Ошибка добавления бронирования")
		}
	
		return c.SendString("Бронирование добавлено успешно")
	})
	

	// Получение списка всех бронирований
	app.Get("/bookings", func(c *fiber.Ctx) error {
		query := "SELECT id, user_id, room_id, start_date, end_date FROM bookings"
		rows, err := pool.Query(context.Background(), query)
		if err != nil {
			log.Printf("Ошибка выполнения запроса: %v", err)
			return c.Status(500).SendString("Ошибка получения списка бронирований")
		}
		defer rows.Close()
	
		var bookings []map[string]interface{}
		for rows.Next() {
			var id, userID, roomID int
			var startDate, endDate time.Time
			if err := rows.Scan(&id, &userID, &roomID, &startDate, &endDate); err != nil {
				log.Printf("Ошибка сканирования строки: %v", err)
				return c.Status(500).SendString("Ошибка обработки данных бронирования")
			}
			bookings = append(bookings, map[string]interface{}{
				"id":         id,
				"user_id":    userID,
				"room_id":    roomID,
				"start_date": startDate.Format("2006-01-02"),
				"end_date":   endDate.Format("2006-01-02"),
			})
		}
	
		return c.JSON(bookings)
	})
	

	// Удаление комнаты
	app.Delete("/rooms/:id", func(c *fiber.Ctx) error {
		id := c.Params("id")
		result, err := pool.Exec(context.Background(), "DELETE FROM rooms WHERE id=$1", id)
		if err != nil {
			log.Printf("Ошибка удаления комнаты: %v", err)
			return c.Status(500).SendString("Ошибка удаления комнаты")
		}
		if result.RowsAffected() == 0 {
			return c.Status(404).SendString("Комната не найдена")
		}
		return c.SendString("Комната успешно удалена")
	})

	// Добавление бронирования
	// (оставлено без изменений для краткости)

	// Запуск приложения
	log.Fatal(app.Listen(":3000"))
}


--- Содержимое файла: frontend/hostel-frontend/src/components/RoomList.js ---

import React, { useState, useEffect, useCallback } from "react";
import axios from "../api/axios";

const RoomList = () => {
  const [rooms, setRooms] = useState([]);
  const [filters, setFilters] = useState({ capacity: "", minPrice: "", maxPrice: "" });
  const [bookings, setBookings] = useState([]);

  const fetchRooms = useCallback(async () => {
    try {
      const params = new URLSearchParams(filters).toString();
      const response = await axios.get(`/rooms?${params}`);
      setRooms(response.data || []);
    } catch (error) {
      console.error("Ошибка при получении списка комнат:", error);
      alert("Ошибка при загрузке комнат.");
    }
  }, [filters]);

  useEffect(() => {
    fetchRooms();
  }, [fetchRooms]);

  const fetchAllRooms = async () => {
    try {
      const response = await axios.get("/rooms");
      setRooms(response.data || []);
    } catch (error) {
      console.error("Ошибка при получении всех комнат:", error);
      alert("Не удалось получить список комнат.");
    }
  };

  const showBookings = async () => {
    try {
      const response = await axios.get("/bookings");
      setBookings(response.data || []);
      if (response.data.length === 0) {
        alert("Брони не найдены.");
      } else {
        alert(
          response.data
            .map(
              (booking) =>
                `Бронь ID: ${booking.id}, Комната ID: ${booking.room_id}, Пользователь ID: ${booking.user_id}, Даты: ${booking.start_date} - ${booking.end_date}`
            )
            .join("\n")
        );
      }
    } catch (error) {
      console.error("Ошибка при получении списка бронирований:", error);
      alert("Не удалось получить список бронирований.");
    }
  };

  const createRoom = async () => {
    try {
      const newRoom = {
        name: "New Room",
        capacity: 2,
        price_per_night: 200,
      };
      await axios.post("/rooms", newRoom);
      fetchAllRooms(); // Обновить список комнат
    } catch (error) {
      console.error("Ошибка при создании комнаты:", error);
      alert("Не удалось создать новую комнату.");
    }
  };

  return (
    <div>
      <h1>Список комнат</h1>
      <div>
        <label>Вместимость: </label>
        <input
          type="number"
          value={filters.capacity}
          onChange={(e) => setFilters({ ...filters, capacity: e.target.value })}
        />
        <label>Мин. цена: </label>
        <input
          type="number"
          value={filters.minPrice}
          onChange={(e) => setFilters({ ...filters, minPrice: e.target.value })}
        />
        <label>Макс. цена: </label>
        <input
          type="number"
          value={filters.maxPrice}
          onChange={(e) => setFilters({ ...filters, maxPrice: e.target.value })}
        />
        <button onClick={fetchRooms}>Фильтровать</button>
        <button onClick={fetchAllRooms}>Показать все комнаты</button>
        <button onClick={showBookings}>Показать все брони</button>
        <button onClick={createRoom}>Создать новую комнату</button>
      </div>
      <ul>
        {rooms.length > 0 ? (
          rooms.map((room) => (
            <li key={room.id}>
              {room.name} - {room.capacity} мест - {room.price_per_night} руб./ночь
            </li>
          ))
        ) : (
          <p>Комнаты не найдены.</p>
        )}
      </ul>
      <h2>Список бронирований</h2>
      <ul>
        {bookings.length > 0 ? (
          bookings.map((booking) => (
            <li key={booking.id}>
              Бронь ID: {booking.id}, Комната ID: {booking.room_id}, Пользователь ID: {booking.user_id}, Даты: {booking.start_date} - {booking.end_date}
            </li>
          ))
        ) : (
          <p>Брони отсутствуют.</p>
        )}
      </ul>
    </div>
  );
};

export default RoomList;


--- Содержимое файла: frontend/hostel-frontend/src/components/AddRoom.js ---

import React, { useState } from "react";
import axios from "axios";

const AddRoom = () => {
  const [room, setRoom] = useState({ name: "", capacity: 0, price_per_night: 0 });

  const handleSubmit = async (e) => {
    e.preventDefault();
    await axios.post("http://localhost:3000/rooms", room);
    alert("Комната добавлена!");
  };

  return (
    <form onSubmit={handleSubmit}>
      <h1>Добавить комнату</h1>
      <label>Название:</label>
      <input
        type="text"
        value={room.name}
        onChange={(e) => setRoom({ ...room, name: e.target.value })}
      />
      <label>Вместимость:</label>
      <input
        type="number"
        value={room.capacity}
        onChange={(e) => setRoom({ ...room, capacity: +e.target.value })}
      />
      <label>Цена за ночь:</label>
      <input
        type="number"
        value={room.price_per_night}
        onChange={(e) => setRoom({ ...room, price_per_night: +e.target.value })}
      />
      <button type="submit">Добавить</button>
    </form>
  );
};

export default AddRoom;


--- Содержимое файла: frontend/hostel-frontend/src/api/axios.js ---

import axios from 'axios';

// Установите базовый URL для вашего API-сервера
const instance = axios.create({
  baseURL: 'http://localhost:3000', // Замените на URL вашего API
});

export default instance;


--- Содержимое файла: frontend/hostel-frontend/src/components/AddUser.js ---

import React, { useState } from "react";
import axios from "axios";

const AddUser = () => {
  const [user, setUser] = useState({ name: "", email: "" });

  const handleSubmit = async (e) => {
    e.preventDefault();
    await axios.post("http://localhost:3000/users", user);
    alert("Пользователь добавлен!");
  };

  return (
    <form onSubmit={handleSubmit}>
      <h1>Добавить пользователя</h1>
      <label>Имя:</label>
      <input
        type="text"
        value={user.name}
        onChange={(e) => setUser({ ...user, name: e.target.value })}
      />
      <label>Email:</label>
      <input
        type="email"
        value={user.email}
        onChange={(e) => setUser({ ...user, email: e.target.value })}
      />
      <button type="submit">Добавить</button>
    </form>
  );
};

export default AddUser;


--- Содержимое файла: frontend/hostel-frontend/src/components/AdminPanel.js ---



--- Содержимое файла: frontend/hostel-frontend/src/components/RoomList.js ---

import React, { useState, useEffect, useCallback } from "react";
import axios from "../api/axios";

const RoomList = () => {
  const [rooms, setRooms] = useState([]);
  const [filters, setFilters] = useState({ capacity: "", minPrice: "", maxPrice: "" });
  const [bookings, setBookings] = useState([]);

  const fetchRooms = useCallback(async () => {
    try {
      const params = new URLSearchParams(filters).toString();
      const response = await axios.get(`/rooms?${params}`);
      setRooms(response.data || []);
    } catch (error) {
      console.error("Ошибка при получении списка комнат:", error);
      alert("Ошибка при загрузке комнат.");
    }
  }, [filters]);

  useEffect(() => {
    fetchRooms();
  }, [fetchRooms]);

  const fetchAllRooms = async () => {
    try {
      const response = await axios.get("/rooms");
      setRooms(response.data || []);
    } catch (error) {
      console.error("Ошибка при получении всех комнат:", error);
      alert("Не удалось получить список комнат.");
    }
  };

  const showBookings = async () => {
    try {
      const response = await axios.get("/bookings");
      setBookings(response.data || []);
      if (response.data.length === 0) {
        alert("Брони не найдены.");
      } else {
        alert(
          response.data
            .map(
              (booking) =>
                `Бронь ID: ${booking.id}, Комната ID: ${booking.room_id}, Пользователь ID: ${booking.user_id}, Даты: ${booking.start_date} - ${booking.end_date}`
            )
            .join("\n")
        );
      }
    } catch (error) {
      console.error("Ошибка при получении списка бронирований:", error);
      alert("Не удалось получить список бронирований.");
    }
  };

  const createRoom = async () => {
    try {
      const newRoom = {
        name: "New Room",
        capacity: 2,
        price_per_night: 200,
      };
      await axios.post("/rooms", newRoom);
      fetchAllRooms(); // Обновить список комнат
    } catch (error) {
      console.error("Ошибка при создании комнаты:", error);
      alert("Не удалось создать новую комнату.");
    }
  };

  return (
    <div>
      <h1>Список комнат</h1>
      <div>
        <label>Вместимость: </label>
        <input
          type="number"
          value={filters.capacity}
          onChange={(e) => setFilters({ ...filters, capacity: e.target.value })}
        />
        <label>Мин. цена: </label>
        <input
          type="number"
          value={filters.minPrice}
          onChange={(e) => setFilters({ ...filters, minPrice: e.target.value })}
        />
        <label>Макс. цена: </label>
        <input
          type="number"
          value={filters.maxPrice}
          onChange={(e) => setFilters({ ...filters, maxPrice: e.target.value })}
        />
        <button onClick={fetchRooms}>Фильтровать</button>
        <button onClick={fetchAllRooms}>Показать все комнаты</button>
        <button onClick={showBookings}>Показать все брони</button>
        <button onClick={createRoom}>Создать новую комнату</button>
      </div>
      <ul>
        {rooms.length > 0 ? (
          rooms.map((room) => (
            <li key={room.id}>
              {room.name} - {room.capacity} мест - {room.price_per_night} руб./ночь
            </li>
          ))
        ) : (
          <p>Комнаты не найдены.</p>
        )}
      </ul>
      <h2>Список бронирований</h2>
      <ul>
        {bookings.length > 0 ? (
          bookings.map((booking) => (
            <li key={booking.id}>
              Бронь ID: {booking.id}, Комната ID: {booking.room_id}, Пользователь ID: {booking.user_id}, Даты: {booking.start_date} - {booking.end_date}
            </li>
          ))
        ) : (
          <p>Брони отсутствуют.</p>
        )}
      </ul>
    </div>
  );
};

export default RoomList;


--- Содержимое файла: frontend/hostel-frontend/src/pages/AddRoomPage.js ---

import React from "react";
import AddRoom from "../components/AddRoom";

const AddRoomPage = () => <AddRoom />;

export default AddRoomPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/AddUserPage.js ---

import React from "react";
import AddUser from "../components/AddUser";

const AddUserPage = () => <AddUser />;

export default AddUserPage;


--- Содержимое файла: frontend/hostel-frontend/src/pages/HomePage.js ---

import React from "react";
import RoomList from "../components/RoomList";

const HomePage = () => (
  <div>
    <h1>Главная</h1>
    <RoomList />
  </div>
);

export default HomePage;


--- Содержимое файла: frontend/hostel-frontend/src/App.css ---

.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


--- Содержимое файла: frontend/hostel-frontend/src/App.js ---

import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import HomePage from "./pages/HomePage";
import AddRoomPage from "./pages/AddRoomPage";
import AddUserPage from "./pages/AddUserPage";
import BookRoomPage from "./pages/BookRoomPage";
import AdminPanelPage from "./pages/AdminPanelPage";
import RoomList from "./components/RoomList";

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/add-room" element={<AddRoomPage />} />
        <Route path="/add-user" element={<AddUserPage />} />
        <Route path="/book-room" element={<BookRoomPage />} />
        <Route path="/admin" element={<AdminPanelPage />} />
      </Routes>
    </Router>
  );
}

export default App;


--- Содержимое файла: frontend/hostel-frontend/src/index.js ---

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


--- Содержимое файла: deploy/docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"

  backend:
    build:
      context: ../backend
    ports:
      - "3000:3000"
    env_file:
      - ../backend/.env
    depends_on:
      - db

  frontend:
    build:
      context: ../frontend
    ports:
      - "3001:3000"


--- Содержимое файла: backend/.env ---

DATABASE_URL=postgres://postgres:password@db:5432/hostel_db?sslmode=disable

--- Содержимое файла: docker-compose.yml ---

version: '3.8'

services:
  db:
    image: postgres:15
    container_name: hostel_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build:
      context: ./backend
    ports:
      - "3000:3000"
    env_file:
      - ./backend/.env
    depends_on:
      - db

  migrate:
    image: migrate/migrate
    volumes:
      - ./backend/migrations:/migrations
    command: [
      "-path", "/migrations",
      "-database", "postgres://postgres:password@db:5432/hostel_db?sslmode=disable",
      "up"
    ]
    depends_on:
      - db

volumes:
  postgres_data:


