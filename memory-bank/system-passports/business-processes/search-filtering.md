# –ü–∞—Å–ø–æ—Ä—Ç –±–∏–∑–Ω–µ—Å-–ø—Ä–æ—Ü–µ—Å—Å–∞: –ü–æ–∏—Å–∫ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è

## üéØ –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞

–û–±–µ—Å–ø–µ—á–µ–Ω–∏–µ –±—ã—Å—Ç—Ä–æ–≥–æ –∏ —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤ –Ω–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ Sve Tu —á–µ—Ä–µ–∑ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é —Å OpenSearch, –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é, –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ, –≥–µ–æ–ø–æ–∏—Å–∫ –∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –∏—Å—Ç–æ—Ä–∏–∏ –ø–æ–∏—Å–∫–æ–≤.

## üîÑ –°—Ö–µ–º–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞

### 1. **–¢–∏–ø—ã –ø–æ–∏—Å–∫–∞**
```mermaid
graph LR
    A[–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å] --> B[–¢–µ–∫—Å—Ç–æ–≤—ã–π –ø–æ–∏—Å–∫]
    A --> C[–ü–æ–∏—Å–∫ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º]
    A --> D[–ì–µ–æ–ø–æ–∏—Å–∫]
    A --> E[–ü–æ–∏—Å–∫ –ø–æ —Ñ–∏–ª—å—Ç—Ä–∞–º]
    B --> F[OpenSearch]
    C --> F
    D --> F
    E --> F
    F --> G[–†–µ–∑—É–ª—å—Ç–∞—Ç—ã]
```

### 2. **–ü—Ä–æ—Ü–µ—Å—Å –ø–æ–∏—Å–∫–∞ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π**
```mermaid
graph TD
    A[–í–≤–æ–¥ –∑–∞–ø—Ä–æ—Å–∞] --> B[–ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ]
    B --> C[–í—ã–±–æ—Ä –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π]
    C --> D[–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤]
    D --> E[–û—Ç–ø—Ä–∞–≤–∫–∞ –≤ OpenSearch]
    E --> F[–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤]
    F --> G[–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∏ –ø–∞–≥–∏–Ω–∞—Ü–∏—è]
    G --> H[–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–∞—Ä—Ç–æ—á–µ–∫]
    H --> I[–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é]
```

### 3. **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø–æ–∏—Å–∫–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã**
```mermaid
graph TD
    A[SearchBar] --> B[UnifiedSearchService]
    B --> C[OpenSearch Cluster]
    C --> D[marketplace index]
    D --> E[–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤]
    E --> F[–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞]
    F --> G[–ü–∞–≥–∏–Ω–∞—Ü–∏—è]
    G --> H[SearchPage]
```

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã

### **Frontend –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã**
- **SearchBar** - —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –ø–æ–∏—Å–∫–∞ —Å –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ–º
- **SearchPage** - —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π
- **MarketplaceFilters** - –ø–∞–Ω–µ–ª—å —Ñ–∏–ª—å—Ç—Ä–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –∏ –∞—Ç—Ä–∏–±—É—Ç–∞–º
- **UnifiedSearchService** - —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å OpenSearch
- **ViewToggle** - –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å grid/list —Ä–µ–∂–∏–º–æ–≤ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞

### **Backend endpoints**
- `GET /search/unified` - —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫
- `GET /search/suggestions` - –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ
- `GET /search/filters` - –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
- `GET /marketplace/categories` - –∏–µ—Ä–∞—Ä—Ö–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
- `POST /search/analytics` - —Ç—Ä–µ–∫–∏–Ω–≥ –ø–æ–∏—Å–∫–æ–≤—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤

### **OpenSearch —Å—Ç—Ä—É–∫—Ç—É—Ä–∞**
- **marketplace index** - –æ—Å–Ω–æ–≤–Ω–æ–π –∏–Ω–¥–µ–∫—Å —Ç–æ–≤–∞—Ä–æ–≤
- **suggestions index** - –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∏ –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã
- **analytics index** - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–∏—Å–∫–æ–≤ –∏ –∫–ª–∏–∫–æ–≤

### **–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö**
- `marketplace_listings` - –∏—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏
- `search_history` - –∏—Å—Ç–æ—Ä–∏—è –ø–æ–∏—Å–∫–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- `popular_searches` - –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ –ø–æ–∏—Å–∫–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã
- `user_search_preferences` - –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–∏—Å–∫–∞

## üìã –î–µ—Ç–∞–ª—å–Ω—ã–π flow –ø—Ä–æ—Ü–µ—Å—Å–∞

### **–≠—Ç–∞–ø 1: –ò–Ω–∏—Ü–∏–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞**
1. **–í–≤–æ–¥ –≤ SearchBar**:
   ```typescript
   const SearchBar: React.FC = () => {
     const [query, setQuery] = useState('');
     const [suggestions, setSuggestions] = useState<string[]>([]);
     
     const handleInputChange = useMemo(
       () => debounce(async (value: string) => {
         if (value.length >= 2) {
           const suggestions = await searchService.getSuggestions(value);
           setSuggestions(suggestions);
         }
       }, 300),
       []
     );
   };
   ```

2. **–ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ**:
   ```json
   {
     "query": {
       "multi_match": {
         "query": "iphon",
         "fields": [
           "title.suggest^3",
           "description.suggest",
           "category_name.suggest^2"
         ],
         "type": "bool_prefix",
         "fuzziness": "AUTO"
       }
     },
     "suggest": {
       "title_suggest": {
         "prefix": "iphon",
         "completion": {
           "field": "title.suggest",
           "size": 10,
           "fuzzy": {"fuzziness": "AUTO"}
         }
       }
     }
   }
   ```

### **–≠—Ç–∞–ø 2: –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–∏—Å–∫–æ–≤–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞**
1. **–ü–∞—Ä—Å–∏–Ω–≥ –∑–∞–ø—Ä–æ—Å–∞**:
   ```go
   type SearchQuery struct {
       Text         string              `json:"text"`
       CategoryID   *int                `json:"category_id,omitempty"`
       PriceMin     *float64            `json:"price_min,omitempty"`
       PriceMax     *float64            `json:"price_max,omitempty"`
       Location     *LocationFilter     `json:"location,omitempty"`
       Attributes   map[string][]string `json:"attributes,omitempty"`
       SortBy       string              `json:"sort_by"` // relevance, price_asc, price_desc, date_desc
       Page         int                 `json:"page"`
       Limit        int                 `json:"limit"`
   }
   
   type LocationFilter struct {
       Latitude  float64 `json:"lat"`
       Longitude float64 `json:"lng"`
       Radius    int     `json:"radius"` // –≤ –∫–∏–ª–æ–º–µ—Ç—Ä–∞—Ö
   }
   ```

2. **–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ OpenSearch –∑–∞–ø—Ä–æ—Å–∞**:
   ```go
   func BuildSearchQuery(sq *SearchQuery) map[string]interface{} {
       query := map[string]interface{}{
           "bool": map[string]interface{}{
               "must": []interface{}{},
               "filter": []interface{}{},
           },
       }
       
       // –¢–µ–∫—Å—Ç–æ–≤—ã–π –ø–æ–∏—Å–∫
       if sq.Text != "" {
           textQuery := map[string]interface{}{
               "multi_match": map[string]interface{}{
                   "query": sq.Text,
                   "fields": []string{
                       "title^3",           // –±–æ–ª—å—à–∏–π –≤–µ—Å –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞
                       "description^1",      // –æ–±—ã—á–Ω—ã–π –≤–µ—Å –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è
                       "category_name^2",    // —Å—Ä–µ–¥–Ω–∏–π –≤–µ—Å –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
                       "attributes.value^1", // –ø–æ–∏—Å–∫ –ø–æ –∞—Ç—Ä–∏–±—É—Ç–∞–º
                   },
                   "type": "best_fields",
                   "fuzziness": "AUTO",
                   "minimum_should_match": "75%",
               },
           }
           query["bool"].(map[string]interface{})["must"] = append(
               query["bool"].(map[string]interface{})["must"].([]interface{}),
               textQuery,
           )
       }
       
       // –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
       if sq.CategoryID != nil {
           categoryFilter := map[string]interface{}{
               "term": map[string]interface{}{
                   "category_id": *sq.CategoryID,
               },
           }
           query["bool"].(map[string]interface{})["filter"] = append(
               query["bool"].(map[string]interface{})["filter"].([]interface{}),
               categoryFilter,
           )
       }
       
       // –§–∏–ª—å—Ç—Ä –ø–æ —Ü–µ–Ω–µ
       if sq.PriceMin != nil || sq.PriceMax != nil {
           priceFilter := map[string]interface{}{
               "range": map[string]interface{}{
                   "price": map[string]interface{}{},
               },
           }
           if sq.PriceMin != nil {
               priceFilter["range"].(map[string]interface{})["price"].(map[string]interface{})["gte"] = *sq.PriceMin
           }
           if sq.PriceMax != nil {
               priceFilter["range"].(map[string]interface{})["price"].(map[string]interface{})["lte"] = *sq.PriceMax
           }
           query["bool"].(map[string]interface{})["filter"] = append(
               query["bool"].(map[string]interface{})["filter"].([]interface{}),
               priceFilter,
           )
       }
       
       // –ì–µ–æ—Ñ–∏–ª—å—Ç—Ä
       if sq.Location != nil {
           geoFilter := map[string]interface{}{
               "geo_distance": map[string]interface{}{
                   "distance": fmt.Sprintf("%dkm", sq.Location.Radius),
                   "location": map[string]interface{}{
                       "lat": sq.Location.Latitude,
                       "lon": sq.Location.Longitude,
                   },
               },
           }
           query["bool"].(map[string]interface{})["filter"] = append(
               query["bool"].(map[string]interface{})["filter"].([]interface{}),
               geoFilter,
           )
       }
       
       return query
   }
   ```

### **–≠—Ç–∞–ø 3: –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∏ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞**
1. **–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —Ñ–∏–ª—å—Ç—Ä—ã –ø–æ –∞—Ç—Ä–∏–±—É—Ç–∞–º**:
   ```typescript
   interface FilterOption {
     name: string;
     value: string;
     count: number; // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–≤–∞—Ä–æ–≤ —Å —ç—Ç–∏–º —Ñ–∏–ª—å—Ç—Ä–æ–º
   }
   
   interface CategoryFilter {
     attribute_id: number;
     attribute_name: string;
     type: 'select' | 'range' | 'checkbox';
     options: FilterOption[];
   }
   
   // –ü—Ä–∏–º–µ—Ä —Ñ–∏–ª—å—Ç—Ä–æ–≤ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ "–°–º–∞—Ä—Ç—Ñ–æ–Ω—ã"
   const smartphoneFilters: CategoryFilter[] = [
     {
       attribute_id: 1,
       attribute_name: "–ë—Ä–µ–Ω–¥",
       type: "checkbox",
       options: [
         { name: "Apple", value: "apple", count: 245 },
         { name: "Samsung", value: "samsung", count: 189 },
         { name: "Xiaomi", value: "xiaomi", count: 156 },
       ]
     },
     {
       attribute_id: 2,
       attribute_name: "–û–±—ä–µ–º –ø–∞–º—è—Ç–∏",
       type: "checkbox", 
       options: [
         { name: "64GB", value: "64gb", count: 89 },
         { name: "128GB", value: "128gb", count: 134 },
         { name: "256GB", value: "256gb", count: 67 },
       ]
     }
   ];
   ```

2. **Aggregations –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤**:
   ```json
   {
     "aggs": {
       "brands": {
         "nested": {"path": "attributes"},
         "aggs": {
           "brand_filter": {
             "filter": {"term": {"attributes.name": "brand"}},
             "aggs": {
               "brand_values": {
                 "terms": {
                   "field": "attributes.value.keyword",
                   "size": 20
                 }
               }
             }
           }
         }
       },
       "price_stats": {
         "stats": {"field": "price"}
       },
       "categories": {
         "terms": {
           "field": "category_id",
           "size": 50
         }
       }
     }
   }
   ```

3. **–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤**:
   ```go
   func BuildSortQuery(sortBy string) []map[string]interface{} {
       switch sortBy {
       case "price_asc":
           return []map[string]interface{}{
               {"price": map[string]interface{}{"order": "asc"}},
           }
       case "price_desc":
           return []map[string]interface{}{
               {"price": map[string]interface{}{"order": "desc"}},
           }
       case "date_desc":
           return []map[string]interface{}{
               {"created_at": map[string]interface{}{"order": "desc"}},
           }
       case "relevance":
           return []map[string]interface{}{
               {"_score": map[string]interface{}{"order": "desc"}},
           }
       default:
           // –ì–∏–±—Ä–∏–¥–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å + —Å–≤–µ–∂–µ—Å—Ç—å
           return []map[string]interface{}{
               {
                   "_script": map[string]interface{}{
                       "type": "number",
                       "script": map[string]interface{}{
                           "source": "_score * Math.log(2 + (System.currentTimeMillis() - doc['created_at'].value.getMillis()) / 86400000)",
                       },
                       "order": "desc",
                   },
               },
           }
       }
   }
   ```

### **–≠—Ç–∞–ø 4: –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤**
1. **SearchPage –∫–æ–º–ø–æ–Ω–µ–Ω—Ç**:
   ```typescript
   const SearchPage: React.FC = () => {
     const [results, setResults] = useState<SearchResult[]>([]);
     const [filters, setFilters] = useState<CategoryFilter[]>([]);
     const [loading, setLoading] = useState(false);
     const [totalCount, setTotalCount] = useState(0);
     const [currentPage, setCurrentPage] = useState(1);
     
     const performSearch = async (searchParams: SearchQuery) => {
       setLoading(true);
       try {
         const response = await searchService.search(searchParams);
         setResults(response.hits);
         setFilters(response.aggregations);
         setTotalCount(response.total);
       } finally {
         setLoading(false);
       }
     };
     
     return (
       <div className="search-page">
         <div className="filters-sidebar">
           <MarketplaceFilters 
             filters={filters}
             onFilterChange={handleFilterChange}
           />
         </div>
         <div className="results-area">
           <SearchResults
             results={results}
             loading={loading}
             viewMode={viewMode}
           />
           <Pagination
             currentPage={currentPage}
             totalPages={Math.ceil(totalCount / ITEMS_PER_PAGE)}
             onPageChange={setCurrentPage}
           />
         </div>
       </div>
     );
   };
   ```

2. **Infinite scroll –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤**:
   ```typescript
   const InfiniteSearchResults: React.FC = () => {
     const [results, setResults] = useState<SearchResult[]>([]);
     const [hasMore, setHasMore] = useState(true);
     const [page, setPage] = useState(1);
     
     const loadMore = useCallback(async () => {
       if (!hasMore) return;
       
       const nextResults = await searchService.search({
         ...currentQuery,
         page: page + 1,
       });
       
       setResults(prev => [...prev, ...nextResults.hits]);
       setHasMore(nextResults.hits.length === ITEMS_PER_PAGE);
       setPage(prev => prev + 1);
     }, [currentQuery, page, hasMore]);
     
     return (
       <InfiniteScrollTrigger
         items={results}
         loadMore={loadMore}
         hasMore={hasMore}
         renderItem={(item) => <MarketplaceCard listing={item} />}
       />
     );
   };
   ```

## üîç –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø–æ–∏—Å–∫–∞

### **–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫**
```json
{
  "query": {
    "script_score": {
      "query": {"match_all": {}},
      "script": {
        "source": """
          // Boost –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã
          double popularityScore = Math.log(2 + doc['view_count'].value);
          
          // Boost —Å–≤–µ–∂–∏–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è
          long ageInDays = (System.currentTimeMillis() - doc['created_at'].value.getMillis()) / 86400000;
          double freshnessScore = Math.exp(-ageInDays / 30.0);
          
          // Boost –ø–æ —Ä–µ–π—Ç–∏–Ω–≥—É –ø—Ä–æ–¥–∞–≤—Ü–∞
          double sellerScore = doc['seller_rating'].size() > 0 ? doc['seller_rating'].value : 3.0;
          
          return _score * popularityScore * freshnessScore * (sellerScore / 5.0);
        """
      }
    }
  }
}
```

### **Faceted search –ø–æ –∞—Ç—Ä–∏–±—É—Ç–∞–º**
```go
func BuildFacetedQuery(categoryID int) map[string]interface{} {
    return map[string]interface{}{
        "size": 0, // —Ç–æ–ª—å–∫–æ aggregations
        "query": map[string]interface{}{
            "term": map[string]interface{}{
                "category_id": categoryID,
            },
        },
        "aggs": map[string]interface{}{
            "attributes": map[string]interface{}{
                "nested": map[string]interface{}{
                    "path": "attributes",
                },
                "aggs": map[string]interface{}{
                    "attribute_names": map[string]interface{}{
                        "terms": map[string]interface{}{
                            "field": "attributes.name.keyword",
                            "size": 50,
                        },
                        "aggs": map[string]interface{}{
                            "attribute_values": map[string]interface{}{
                                "terms": map[string]interface{}{
                                    "field": "attributes.value.keyword",
                                    "size": 20,
                                },
                            },
                        },
                    },
                },
            },
        },
    }
}
```

### **–ì–µ–æ–ø–æ–∏—Å–∫ —Å –∫–∞—Ä—Ç–æ–π**
```typescript
interface GeoSearchProps {
  center: {lat: number, lng: number};
  radius: number; // –≤ –∫–º
  onLocationChange: (location: {lat: number, lng: number}) => void;
}

const GeoSearchMap: React.FC<GeoSearchProps> = ({ center, radius, onLocationChange }) => {
  const [map, setMap] = useState<google.maps.Map | null>(null);
  const [circle, setCircle] = useState<google.maps.Circle | null>(null);
  
  useEffect(() => {
    if (map) {
      // –°–æ–∑–¥–∞–Ω–∏–µ circle –¥–ª—è —Ä–∞–¥–∏—É—Å–∞ –ø–æ–∏—Å–∫–∞
      const searchCircle = new google.maps.Circle({
        map,
        center,
        radius: radius * 1000, // –ø–µ—Ä–µ–≤–æ–¥–∏–º –∫–º –≤ –º–µ—Ç—Ä—ã
        fillColor: '#4285F4',
        fillOpacity: 0.1,
        strokeColor: '#4285F4',
        strokeOpacity: 0.5,
        strokeWeight: 2,
      });
      
      setCircle(searchCircle);
      
      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è —Ü–µ–Ω—Ç—Ä–∞
      const marker = new google.maps.Marker({
        position: center,
        map,
        draggable: true,
      });
      
      marker.addListener('dragend', () => {
        const position = marker.getPosition();
        if (position) {
          onLocationChange({
            lat: position.lat(),
            lng: position.lng(),
          });
        }
      });
    }
  }, [map, center, radius]);
  
  return <Map onLoad={setMap} center={center} zoom={13} />;
};
```

## üìä –ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—è –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

### **–ò—Å—Ç–æ—Ä–∏—è –ø–æ–∏—Å–∫–æ–≤**
```go
type SearchHistory struct {
    ID        int       `json:"id"`
    UserID    int       `json:"user_id"`
    Query     string    `json:"query"`
    Filters   JSON      `json:"filters"`
    Results   int       `json:"results_count"`
    CreatedAt time.Time `json:"created_at"`
}

func SaveSearchHistory(userID int, query *SearchQuery, resultsCount int) {
    history := &SearchHistory{
        UserID:  userID,
        Query:   query.Text,
        Filters: query.Filters,
        Results: resultsCount,
    }
    
    db.Create(history)
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –ø–æ—Å–ª–µ–¥–Ω–∏–º–∏ 100 –ø–æ–∏—Å–∫–∞–º–∏
    db.Where("user_id = ?", userID).
      Order("created_at DESC").
      Offset(100).
      Delete(&SearchHistory{})
}
```

### **–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –ø–æ–∏—Å–∫–∏**
```sql
-- –¢–æ–ø –ø–æ–∏—Å–∫–æ–≤—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –∑–∞ –Ω–µ–¥–µ–ª—é
SELECT 
    query,
    COUNT(*) as search_count,
    AVG(results_count) as avg_results,
    COUNT(DISTINCT user_id) as unique_users
FROM search_history 
WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'
    AND query != ''
GROUP BY query
HAVING COUNT(*) >= 5
ORDER BY search_count DESC
LIMIT 20;
```

### **–ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è**
```go
func GetPersonalizedSuggestions(userID int) ([]string, error) {
    // –ü–æ–ª—É—á–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –ø–æ–∏—Å–∫–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    var history []SearchHistory
    db.Where("user_id = ?", userID).
      Order("created_at DESC").
      Limit(20).
      Find(&history)
    
    // –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
    keywords := extractKeywords(history)
    
    // –ò—â–µ–º –ø–æ—Ö–æ–∂–∏–µ —Ç–æ–≤–∞—Ä—ã
    suggestions := findSimilarListings(keywords)
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–µ–Ω–¥–æ–≤—ã–µ –ø–æ–∏—Å–∫–∏
    trending := getTrendingSearches()
    
    return mergeSuggestions(suggestions, trending), nil
}
```

## üéØ A/B —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–∏—Å–∫–∞

### **–í–∞—Ä–∏–∞–Ω—Ç—ã –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤**
```go
type SearchAlgorithm string

const (
    AlgorithmStandard   SearchAlgorithm = "standard"   // —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π BM25
    AlgorithmSemantic   SearchAlgorithm = "semantic"   // —Å —É—á–µ—Ç–æ–º —Å–µ–º–∞–Ω—Ç–∏–∫–∏
    AlgorithmPersonalized SearchAlgorithm = "personalized" // –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
)

func GetSearchAlgorithm(userID int) SearchAlgorithm {
    // A/B —Ç–µ—Å—Ç: 50% standard, 30% semantic, 20% personalized
    hash := fnv.New32a()
    hash.Write([]byte(fmt.Sprintf("search_algo_%d", userID)))
    value := hash.Sum32() % 100
    
    switch {
    case value < 50:
        return AlgorithmStandard
    case value < 80:
        return AlgorithmSemantic
    default:
        return AlgorithmPersonalized
    }
}
```

### **–ú–µ—Ç—Ä–∏–∫–∏ A/B —Ç–µ—Å—Ç–æ–≤**
```go
type SearchMetrics struct {
    Algorithm    SearchAlgorithm `json:"algorithm"`
    UserID       int            `json:"user_id"`
    Query        string         `json:"query"`
    ResultsCount int            `json:"results_count"`
    ClickedItems []int          `json:"clicked_items"`
    TimeSpent    time.Duration  `json:"time_spent"`
    Converted    bool           `json:"converted"` // –æ—Ç–∫—Ä—ã–ª —á–∞—Ç —Å –ø—Ä–æ–¥–∞–≤—Ü–æ–º
}

func TrackSearchMetrics(metrics *SearchMetrics) {
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ –∞–Ω–∞–ª–∏—Ç–∏–∫—É
    analytics.Track("search_performed", map[string]interface{}{
        "algorithm":     string(metrics.Algorithm),
        "user_id":       metrics.UserID,
        "query_length":  len(metrics.Query),
        "results_count": metrics.ResultsCount,
        "ctr":          float64(len(metrics.ClickedItems)) / float64(metrics.ResultsCount),
        "time_spent":   metrics.TimeSpent.Seconds(),
        "converted":    metrics.Converted,
    })
}
```

## üîê –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞

### **–ó–∞—â–∏—Ç–∞ –æ—Ç injection –∞—Ç–∞–∫**
```go
func SanitizeSearchQuery(query string) string {
    // –£–¥–∞–ª—è–µ–º –æ–ø–∞—Å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è OpenSearch
    dangerous := []string{
        "script:", "javascript:", "<script", "</script>",
        "eval(", "alert(", "document.", "window.",
    }
    
    cleaned := query
    for _, danger := range dangerous {
        cleaned = strings.ReplaceAll(cleaned, danger, "")
    }
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –∑–∞–ø—Ä–æ—Å–∞
    if len(cleaned) > 200 {
        cleaned = cleaned[:200]
    }
    
    return cleaned
}
```

### **Rate limiting –¥–ª—è –ø–æ–∏—Å–∫–∞**
```go
const (
    SearchRateLimit     = 30  // –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –º–∏–Ω—É—Ç—É
    SuggestionRateLimit = 60  // –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–æ–ª–µ–µ —á–∞—Å—Ç–æ–µ
)

func CheckSearchRateLimit(userID int) error {
    key := fmt.Sprintf("search_rate_limit:%d", userID)
    
    count, err := redis.Incr(key)
    if err != nil {
        return err
    }
    
    if count == 1 {
        redis.Expire(key, time.Minute)
    }
    
    if count > SearchRateLimit {
        return errors.New("search rate limit exceeded")
    }
    
    return nil
}
```

### **–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –Ω–µ–ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞**
```go
func FilterInappropriateContent(results []SearchResult) []SearchResult {
    filtered := make([]SearchResult, 0, len(results))
    
    for _, result := range results {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∑–∞–ø—Ä–µ—â–µ–Ω–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        if result.CategoryID == 666 { // –Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–∞—Ç–µ–≥–æ—Ä–∏—è –¥–ª—è –≤–∑—Ä–æ—Å–ª—ã—Ö
            continue
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –Ω–∞ –Ω–µ–ø–æ–¥—Ö–æ–¥—è—â–∏–µ —Å–ª–æ–≤–∞
        if containsInappropriateWords(result.Title) {
            continue
        }
        
        filtered = append(filtered, result)
    }
    
    return filtered
}
```

## üìà –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –ø–æ–∏—Å–∫–∞

### **–ö–ª—é—á–µ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏**
```sql
-- CTR (Click-Through Rate) –ø–æ –ø–æ–∏—Å–∫–æ–≤—ã–º –∑–∞–ø—Ä–æ—Å–∞–º
WITH search_stats AS (
  SELECT 
    query,
    COUNT(*) as total_searches,
    COUNT(CASE WHEN clicked_items IS NOT NULL THEN 1 END) as searches_with_clicks,
    AVG(JSON_LENGTH(clicked_items)) as avg_clicks_per_search
  FROM search_history 
  WHERE created_at >= CURRENT_DATE - INTERVAL '7 days'
  GROUP BY query
)
SELECT 
  query,
  total_searches,
  ROUND(searches_with_clicks * 100.0 / total_searches, 2) as ctr_percentage,
  avg_clicks_per_search
FROM search_stats
WHERE total_searches >= 10
ORDER BY ctr_percentage DESC
LIMIT 20;
```

### **–ê–Ω–∞–ª–∏–∑ –ø—É—Å—Ç—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤**
```go
func AnalyzeZeroResults() {
    // –ù–∞—Ö–æ–¥–∏–º –∑–∞–ø—Ä–æ—Å—ã –±–µ–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    var zeroResultQueries []SearchHistory
    db.Where("results_count = 0").
      Where("created_at >= ?", time.Now().AddDate(0, 0, -7)).
      Find(&zeroResultQueries)
    
    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –ø–æ—Ö–æ–∂–∏–º –∑–∞–ø—Ä–æ—Å–∞–º
    grouped := groupSimilarQueries(zeroResultQueries)
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç—á–µ—Ç –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞
    for pattern, count := range grouped {
        if count >= 5 { // –º–∏–Ω–∏–º—É–º 5 –∑–∞–ø—Ä–æ—Å–æ–≤
            analytics.Track("zero_results_pattern", map[string]interface{}{
                "pattern": pattern,
                "count":   count,
                "suggestions": generateImprovementSuggestions(pattern),
            })
        }
    }
}
```

### **Heatmap –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç–∏**
```typescript
interface SearchHeatmapData {
  query: string;
  frequency: number;
  avgPosition: number; // —Å—Ä–µ–¥–Ω—è—è –ø–æ–∑–∏—Ü–∏—è –∫–ª–∏–∫–∞
  conversionRate: number;
}

const SearchHeatmap: React.FC = () => {
  const [heatmapData, setHeatmapData] = useState<SearchHeatmapData[]>([]);
  
  useEffect(() => {
    // –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç–∏ –ø–æ–∏—Å–∫–æ–≤
    loadSearchHeatmapData().then(setHeatmapData);
  }, []);
  
  return (
    <div className="search-heatmap">
      {heatmapData.map(item => (
        <div 
          key={item.query}
          className="heatmap-cell"
          style={{
            backgroundColor: `hsla(200, 100%, 50%, ${item.frequency / 100})`,
          }}
        >
          <span>{item.query}</span>
          <small>{item.frequency} –ø–æ–∏—Å–∫–æ–≤</small>
        </div>
      ))}
    </div>
  );
};
```

## ‚ùå –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

### **–¢–∏–ø–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏ –ø–æ–∏—Å–∫–∞**
1. **OpenSearch –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω**:
   ```json
   {
     "success": false,
     "error": "search.service.unavailable",
     "message": "–ü–æ–∏—Å–∫ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω",
     "fallback": {
       "use_database": true,
       "limited_results": true
     }
   }
   ```

2. **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å**:
   ```json
   {
     "success": false,
     "error": "search.query.invalid",
     "message": "–ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã",
     "details": {
       "invalid_chars": ["<", ">", "script:"]
     }
   }
   ```

3. **–ü—Ä–µ–≤—ã—à–µ–Ω–∏–µ –ª–∏–º–∏—Ç–æ–≤**:
   ```json
   {
     "success": false,
     "error": "search.rate.limit.exceeded", 
     "message": "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ø–æ–∏—Å–∫–æ–≤—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤",
     "retry_after": "60s"
   }
   ```

### **Fallback —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏**
```go
func SearchWithFallback(query *SearchQuery) (*SearchResponse, error) {
    // –û—Å–Ω–æ–≤–Ω–æ–π –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ OpenSearch
    result, err := searchInOpenSearch(query)
    if err == nil {
        return result, nil
    }
    
    log.Warn("OpenSearch failed, falling back to database", "error", err)
    
    // Fallback: –ø—Ä–æ—Å—Ç–æ–π –ø–æ–∏—Å–∫ –ø–æ PostgreSQL
    fallbackResult, err := searchInDatabase(query)
    if err != nil {
        return nil, fmt.Errorf("both search methods failed: %w", err)
    }
    
    // –ü–æ–º–µ—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫–∞–∫ fallback
    fallbackResult.IsFallback = true
    fallbackResult.Message = "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–ø–æ–ª–Ω—ã–º–∏"
    
    return fallbackResult, nil
}

func searchInDatabase(query *SearchQuery) (*SearchResponse, error) {
    // –ü—Ä–æ—Å—Ç–æ–π LIKE –ø–æ–∏—Å–∫ –≤ PostgreSQL
    db := database.GetDB()
    
    baseQuery := db.Table("marketplace_listings").
        Where("status = ?", "active")
    
    if query.Text != "" {
        baseQuery = baseQuery.Where(
            "title ILIKE ? OR description ILIKE ?",
            "%"+query.Text+"%", "%"+query.Text+"%",
        )
    }
    
    if query.CategoryID != nil {
        baseQuery = baseQuery.Where("category_id = ?", *query.CategoryID)
    }
    
    var listings []models.Listing
    err := baseQuery.Limit(query.Limit).Offset((query.Page-1)*query.Limit).Find(&listings).Error
    
    return &SearchResponse{
        Hits:       convertToSearchResults(listings),
        Total:      len(listings),
        IsFallback: true,
    }, err
}
```

## üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### **Unit —Ç–µ—Å—Ç—ã**
```go
func TestSearchQueryBuilder(t *testing.T) {
    query := &SearchQuery{
        Text:       "iPhone 12",
        CategoryID: intPtr(5),
        PriceMin:   floatPtr(30000),
        PriceMax:   floatPtr(60000),
    }
    
    opensearchQuery := BuildSearchQuery(query)
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∑–∞–ø—Ä–æ—Å–∞
    assert.Contains(t, opensearchQuery, "bool")
    assert.Contains(t, opensearchQuery["bool"], "must")
    assert.Contains(t, opensearchQuery["bool"], "filter")
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ multi_match –¥–ª—è —Ç–µ–∫—Å—Ç–∞
    mustClauses := opensearchQuery["bool"].(map[string]interface{})["must"].([]interface{})
    assert.Len(t, mustClauses, 1)
    
    multiMatch := mustClauses[0].(map[string]interface{})["multi_match"]
    assert.Equal(t, "iPhone 12", multiMatch.(map[string]interface{})["query"])
}
```

### **Integration —Ç–µ—Å—Ç—ã**
```go
func TestSearchEndToEnd(t *testing.T) {
    // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    testListing := &models.Listing{
        Title:       "iPhone 12 Pro 128GB",
        Description: "Excellent condition iPhone",
        Price:       45000,
        CategoryID:  5,
        Status:      "active",
    }
    
    // –ò–Ω–¥–µ–∫—Å–∏—Ä—É–µ–º –≤ OpenSearch
    err := indexListing(testListing)
    assert.NoError(t, err)
    
    // –ñ–¥–µ–º –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏
    time.Sleep(1 * time.Second)
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫
    results, err := searchService.Search(&SearchQuery{
        Text:  "iPhone",
        Limit: 10,
        Page:  1,
    })
    
    assert.NoError(t, err)
    assert.Greater(t, len(results.Hits), 0)
    assert.Contains(t, results.Hits[0].Title, "iPhone")
}
```

### **Performance —Ç–µ—Å—Ç—ã**
```go
func BenchmarkSearch(b *testing.B) {
    searchQuery := &SearchQuery{
        Text:  "test query",
        Limit: 20,
        Page:  1,
    }
    
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        _, err := searchService.Search(searchQuery)
        if err != nil {
            b.Fatal(err)
        }
    }
}

// –†–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å < 100ms –Ω–∞ –∑–∞–ø—Ä–æ—Å
```

## üöÄ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

### **–ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤**
```go
var searchCache = sync.Map{}

func SearchWithCache(query *SearchQuery) (*SearchResponse, error) {
    // –°–æ–∑–¥–∞–µ–º –∫–ª—é—á –∫–µ—à–∞
    cacheKey := generateCacheKey(query)
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–µ—à
    if cached, ok := searchCache.Load(cacheKey); ok {
        cachedResult := cached.(*SearchResponse)
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å (5 –º–∏–Ω—É—Ç)
        if time.Since(cachedResult.CachedAt) < 5*time.Minute {
            return cachedResult, nil
        }
    }
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫
    result, err := searchInOpenSearch(query)
    if err != nil {
        return nil, err
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫–µ—à
    result.CachedAt = time.Now()
    searchCache.Store(cacheKey, result)
    
    return result, nil
}
```

### **–ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤**
```go
func PreloadPopularSearches() {
    popularQueries := getPopularSearchQueries(24 * time.Hour) // –∑–∞ —Å—É—Ç–∫–∏
    
    for _, query := range popularQueries {
        go func(q string) {
            searchQuery := &SearchQuery{
                Text:  q,
                Limit: 20,
                Page:  1,
            }
            
            // –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫ –∏ –∫–µ—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            SearchWithCache(searchQuery)
        }(query)
    }
}
```

### **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è OpenSearch**
```json
{
  "settings": {
    "number_of_shards": 3,
    "number_of_replicas": 1,
    "refresh_interval": "5s",
    "index": {
      "max_result_window": 50000,
      "mapping": {
        "total_fields": {
          "limit": 2000
        }
      }
    }
  }
}
```

## üìö –°–≤—è–∑–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã

1. **–ü—É–±–ª–∏–∫–∞—Ü–∏—è –æ–±—ä—è–≤–ª–µ–Ω–∏–π** - –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—è –Ω–æ–≤—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤ –≤ OpenSearch
2. **–ö–æ–º–º—É–Ω–∏–∫–∞—Ü–∏—è –º–µ–∂–¥—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏** - –∫–æ–Ω—Ç–∞–∫—Ç –ø–æ—Å–ª–µ –ø–æ–∏—Å–∫–∞
3. **–ê–Ω–∞–ª–∏—Ç–∏–∫–∞** - —Ç—Ä–µ–∫–∏–Ω–≥ –ø–æ–∏—Å–∫–æ–≤—ã—Ö –º–µ—Ç—Ä–∏–∫
4. **–†–µ–∫–æ–º–µ–Ω–¥–∞—Ç–µ–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞** - –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
5. **–ú–æ–¥–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞** - —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –Ω–µ–ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
6. **–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è** - –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ —Ç–æ–≤–∞—Ä–æ–≤
7. **–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è** - alerts –ø–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–º –ø–æ–∏—Å–∫–∞–º

## üìñ –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

### **API Reference**
- `GET /search/unified` - —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫
- `GET /search/suggestions` - –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–æ–≤
- `GET /search/filters` - –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
- `POST /search/analytics` - —Ç—Ä–µ–∫–∏–Ω–≥ –ø–æ–∏—Å–∫–æ–≤—ã—Ö —Å–æ–±—ã—Ç–∏–π

### **Frontend –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã**
- `SearchBar.md` - —Å—Ç—Ä–æ–∫–∞ –ø–æ–∏—Å–∫–∞ —Å –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ–º
- `SearchPage.md` - —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
- `MarketplaceFilters.md` - –ø–∞–Ω–µ–ª—å —Ñ–∏–ª—å—Ç—Ä–æ–≤
- `UnifiedSearchService.md` - —Å–µ—Ä–≤–∏—Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å OpenSearch

### **Infrastructure**
- `opensearch-marketplace-index.md` - –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–Ω–¥–µ–∫—Å–∞
- `opensearch-mappings-settings.md` - —Å—Ö–µ–º—ã –ø–æ–ª–µ–π –∏ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä—ã