# –ü–∞—Å–ø–æ—Ä—Ç –±–∏–∑–Ω–µ—Å-–ø—Ä–æ—Ü–µ—Å—Å–∞: –ü—Ä–æ—Ü–µ—Å—Å –ø–æ–∫—É–ø–∫–∏ —á–µ—Ä–µ–∑ AllSecure/Stripe

## üéØ –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞

–û–±–µ—Å–ø–µ—á–µ–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∏ –Ω–∞–¥–µ–∂–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–æ–∫—É–ø–∫–∏ —Ç–æ–≤–∞—Ä–æ–≤ –Ω–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ Sve Tu —á–µ—Ä–µ–∑ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é —Å –ø–ª–∞—Ç–µ–∂–Ω—ã–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏ AllSecure –∏ Stripe —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —ç—Å–∫—Ä–æ—É-–º–µ—Ö–∞–Ω–∏–∑–º–æ–≤, –∑–∞—â–∏—Ç—ã –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è —Å–ø–æ—Ä–æ–≤.

## üîÑ –°—Ö–µ–º–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞

### 1. **–ò–Ω–∏—Ü–∏–∞—Ü–∏—è –ø–æ–∫—É–ø–∫–∏**
```mermaid
graph LR
    A[–ü–æ–∫—É–ø–∞—Ç–µ–ª—å –≤—ã–±–∏—Ä–∞–µ—Ç —Ç–æ–≤–∞—Ä] --> B[–ö–ª–∏–∫ "–ö—É–ø–∏—Ç—å"]
    B --> C[–í—ã–±–æ—Ä —Å–ø–æ—Å–æ–±–∞ –æ–ø–ª–∞—Ç—ã]
    C --> D[AllSecure/Stripe Widget]
    D --> E[–í–≤–æ–¥ –ø–ª–∞—Ç–µ–∂–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö]
    E --> F[–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–∫—É–ø–∫–∏]
    F --> G[–°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏]
```

### 2. **–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞—Ç–µ–∂–∞**
```mermaid
graph TD
    A[–°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏] --> B[–í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö]
    B --> C[–†–∞—Å—á–µ—Ç –∫–æ–º–∏—Å—Å–∏–π]
    C --> D{–í—ã–±–æ—Ä –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞}
    D -->|AllSecure| E[AllSecure API]
    D -->|Stripe| F[Stripe API]
    E --> G[–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø–ª–∞—Ç–µ–∂–∞]
    F --> G
    G --> H{–ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–µ–Ω?}
    H -->|–î–∞| I[–°—Ä–µ–¥—Å—Ç–≤–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã]
    H -->|–ù–µ—Ç| J[–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏]
    I --> K[–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–æ–¥–∞–≤—Ü–∞]
    J --> L[–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞/–û—Ç–º–µ–Ω–∞]
```

### 3. **–≠—Å–∫—Ä–æ—É –ø—Ä–æ—Ü–µ—Å—Å**
```mermaid
graph TD
    A[–°—Ä–µ–¥—Å—Ç–≤–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã] --> B[–°–æ–∑–¥–∞–Ω–∏–µ —ç—Å–∫—Ä–æ—É-—Å—á–µ—Ç–∞]
    B --> C[–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω]
    C --> D[–ü–µ—Ä–∏–æ–¥ –±–µ–∑–æ–ø–∞—Å–Ω–æ–π —Å–¥–µ–ª–∫–∏]
    D --> E{–°—Ç–∞—Ç—É—Å –¥–æ—Å—Ç–∞–≤–∫–∏}
    E -->|–ü–æ–ª—É—á–µ–Ω–æ| F[–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–º]
    E -->|–°–ø–æ—Ä| G[–ê—Ä–±–∏—Ç—Ä–∞–∂]
    E -->|–¢–∞–π–º–∞—É—Ç| H[–ê–≤—Ç–æ–æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ]
    F --> I[–û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ —Å—Ä–µ–¥—Å—Ç–≤]
    G --> J[–†–µ—à–µ–Ω–∏–µ –∞—Ä–±–∏—Ç—Ä–∞]
    H --> I
    J --> I
    I --> K[–ü–µ—Ä–µ–≤–æ–¥ –ø—Ä–æ–¥–∞–≤—Ü—É]
```

### 4. **–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–¥–µ–ª–∫–∏**
```mermaid
graph LR
    A[–ü–µ—Ä–µ–≤–æ–¥ –ø—Ä–æ–¥–∞–≤—Ü—É] --> B[–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–æ–≤]
    B --> C[–°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –≤ –∏—Å—Ç–æ—Ä–∏–∏]
    C --> D[–û—Ç–ø—Ä–∞–≤–∫–∞ —á–µ–∫–æ–≤]
    D --> E[–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–æ–≤]
    E --> F[–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –ø—Ä–æ–¥–∞–∂]
    F --> G[–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞]
```

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã

### **Frontend –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã**
- **PaymentMethodSelector** - –≤—ã–±–æ—Ä —Å–ø–æ—Å–æ–±–∞ –æ–ø–ª–∞—Ç—ã (AllSecure/Stripe/Balance)
- **PaymentProcessing** - –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–∞ —Å real-time —Å—Ç–∞—Ç—É—Å–æ–º
- **EscrowStatus** - –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —ç—Å–∫—Ä–æ—É-—Å—á–µ—Ç–∞
- **PurchaseConfirmation** - –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–∫—É–ø–∫–∏ —Å –¥–µ—Ç–∞–ª—è–º–∏
- **PaymentErrorHandler** - –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ—à–∏–±–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π

### **Backend —Å–µ—Ä–≤–∏—Å—ã**
- **PaymentService** - –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è –ø–ª–∞—Ç–µ–∂–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
- **AllSecureService** - –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å AllSecure API
- **StripeService** - –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Stripe API
- **EscrowService** - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —ç—Å–∫—Ä–æ—É-—Å—á–µ—Ç–∞–º–∏
- **CommissionCalculator** - —Ä–∞—Å—á–µ—Ç –∫–æ–º–∏—Å—Å–∏–π –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
- **WebhookHandler** - –æ–±—Ä–∞–±–æ—Ç–∫–∞ webhook'–æ–≤ –æ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤

### **–ë–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö**
- **payments** - –æ—Å–Ω–æ–≤–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –ø–ª–∞—Ç–µ–∂–µ–π
- **escrow_transactions** - —ç—Å–∫—Ä–æ—É-—Å—á–µ—Ç–∞ –∏ –∏—Ö —Å—Ç–∞—Ç—É—Å—ã
- **payment_attempts** - –ø–æ–ø—ã—Ç–∫–∏ –ø–ª–∞—Ç–µ–∂–µ–π –∏ –æ—à–∏–±–∫–∏
- **commission_calculations** - –¥–µ—Ç–∞–ª–∏ —Ä–∞—Å—á–µ—Ç–∞ –∫–æ–º–∏—Å—Å–∏–π
- **webhook_logs** - –ª–æ–≥–∏ webhook'–æ–≤

## üîó –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏

### **AllSecure Integration**
```go
// –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ —á–µ—Ä–µ–∑ AllSecure
type CreatePaymentRequest struct {
    UserID      int             `json:"user_id"`
    ListingID   int             `json:"listing_id"`
    Amount      decimal.Decimal `json:"amount"`
    Currency    string          `json:"currency"`
    Description string          `json:"description"`
    ReturnURL   string          `json:"return_url"`
}

func (s *AllSecureService) CreatePayment(ctx context.Context, req CreatePaymentRequest) (*PaymentResult, error) {
    // 1. –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞
    if err := s.validatePaymentRequest(ctx, req); err != nil {
        return nil, fmt.Errorf("validation failed: %w", err)
    }

    // 2. –†–∞—Å—á–µ—Ç –∫–æ–º–∏—Å—Å–∏–π
    commission := s.calculateCommission(req.Amount)
    totalAmount := req.Amount.Add(commission)

    // 3. –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –≤ –±–∞–∑–µ
    transaction, err := s.repository.CreateTransaction(ctx, models.PaymentTransaction{
        UserID:          req.UserID,
        ListingID:       req.ListingID,
        Amount:          req.Amount,
        Commission:      commission,
        TotalAmount:     totalAmount,
        Currency:        req.Currency,
        Status:          "pending",
        Provider:        "allsecure",
    })
    if err != nil {
        return nil, fmt.Errorf("failed to create transaction: %w", err)
    }

    // 4. –í—ã–∑–æ–≤ AllSecure API
    result, err := s.client.CreatePayment(allsecure.CreatePaymentRequest{
        Amount:      totalAmount,
        Currency:    req.Currency,
        Reference:   fmt.Sprintf("marketplace-%d", transaction.ID),
        Description: req.Description,
        ReturnURL:   req.ReturnURL,
        WebhookURL:  s.config.WebhookURL,
        Customer: allsecure.Customer{
            ID:    strconv.Itoa(req.UserID),
            Email: transaction.User.Email,
        },
    })
    if err != nil {
        s.repository.UpdateTransactionStatus(ctx, transaction.ID, "failed")
        return nil, fmt.Errorf("allsecure API error: %w", err)
    }

    // 5. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    err = s.repository.UpdateTransaction(ctx, transaction.ID, models.PaymentTransaction{
        GatewayUUID:  result.UUID,
        Status:       result.Status,
        RedirectURL:  result.RedirectURL,
    })
    if err != nil {
        s.logger.Error("Failed to update transaction", "error", err)
    }

    return &PaymentResult{
        TransactionID:  transaction.ID,
        GatewayUUID:    result.UUID,
        Status:         result.Status,
        RedirectURL:    result.RedirectURL,
        RequiresAction: result.RequiresAction,
    }, nil
}
```

### **Stripe Integration**
```go
// –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ —á–µ—Ä–µ–∑ Stripe
func (s *StripeService) CreatePaymentIntent(ctx context.Context, req CreatePaymentRequest) (*PaymentResult, error) {
    // –°–æ–∑–¥–∞–Ω–∏–µ Stripe PaymentIntent
    params := &stripe.PaymentIntentParams{
        Amount:   stripe.Int64(req.Amount.Mul(decimal.NewFromInt(100)).IntPart()),
        Currency: stripe.String(strings.ToLower(req.Currency)),
        Metadata: map[string]string{
            "user_id":    strconv.Itoa(req.UserID),
            "listing_id": strconv.Itoa(req.ListingID),
            "platform":   "sve-tu-marketplace",
        },
        PaymentMethodTypes: stripe.StringSlice([]string{
            "card",
            "sepa_debit",
            "sofort",
        }),
        ConfirmationMethod: stripe.String("automatic"),
        ReturnURL:         stripe.String(req.ReturnURL),
    }

    intent, err := paymentintent.New(params)
    if err != nil {
        return nil, fmt.Errorf("stripe payment intent creation failed: %w", err)
    }

    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –±–∞–∑—É
    transaction, err := s.repository.CreateTransaction(ctx, models.PaymentTransaction{
        UserID:       req.UserID,
        ListingID:    req.ListingID,
        Amount:       req.Amount,
        Currency:     req.Currency,
        Status:       "pending",
        Provider:     "stripe",
        GatewayUUID:  intent.ID,
        ClientSecret: intent.ClientSecret,
    })

    return &PaymentResult{
        TransactionID:  transaction.ID,
        GatewayUUID:    intent.ID,
        ClientSecret:   intent.ClientSecret,
        Status:         string(intent.Status),
        RequiresAction: intent.Status == stripe.PaymentIntentStatusRequiresAction,
    }, nil
}
```

### **Frontend Payment Flow**
```typescript
// Hook –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–æ–∫—É–ø–∫–∏
export const usePurchaseFlow = () => {
  const [paymentState, setPaymentState] = useState<PaymentState>({
    step: 'selection',
    loading: false,
    error: null,
    transaction: null,
  });

  const initiatePurchase = async (listingId: number, paymentMethod: 'allsecure' | 'stripe' | 'balance') => {
    setPaymentState(prev => ({ ...prev, loading: true, error: null }));

    try {
      // 1. –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞
      const response = await fetch('/api/v1/payments/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          listing_id: listingId,
          payment_method: paymentMethod,
          return_url: `${window.location.origin}/payment/success`,
        }),
      });

      const result = await response.json();
      
      if (!result.success) {
        throw new Error(result.error || 'Payment creation failed');
      }

      setPaymentState(prev => ({ 
        ...prev, 
        transaction: result.data,
        step: 'processing',
        loading: false,
      }));

      // 2. –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ payment gateway
      if (result.data.redirect_url) {
        window.location.href = result.data.redirect_url;
      } else if (result.data.client_secret) {
        // Stripe Elements integration
        await handleStripePayment(result.data.client_secret);
      }

    } catch (error) {
      setPaymentState(prev => ({ 
        ...prev, 
        loading: false, 
        error: error.message,
        step: 'error',
      }));
    }
  };

  const handleStripePayment = async (clientSecret: string) => {
    const stripe = await getStripe();
    
    const { error, paymentIntent } = await stripe.confirmPayment({
      clientSecret,
      confirmParams: {
        return_url: `${window.location.origin}/payment/success`,
      },
    });

    if (error) {
      setPaymentState(prev => ({ 
        ...prev, 
        error: error.message,
        step: 'error',
      }));
    } else {
      setPaymentState(prev => ({ 
        ...prev, 
        step: 'success',
        transaction: { ...prev.transaction, status: paymentIntent.status },
      }));
    }
  };

  return {
    paymentState,
    initiatePurchase,
    resetPayment: () => setPaymentState({ step: 'selection', loading: false, error: null, transaction: null }),
  };
};
```

## üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è

### **–í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞ —É—Ä–æ–≤–Ω–µ API**
```go
// –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–ª–∞—Ç–µ–∂–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
func (s *PaymentService) validatePaymentRequest(ctx context.Context, req CreatePaymentRequest) error {
    // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user, err := s.userRepo.GetByID(ctx, req.UserID)
    if err != nil {
        return errors.New("user.notFound")
    }
    
    if !user.IsActive || user.IsBanned {
        return errors.New("user.notEligible")
    }

    // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—ä—è–≤–ª–µ–Ω–∏—è
    listing, err := s.listingRepo.GetByID(ctx, req.ListingID)
    if err != nil {
        return errors.New("listing.notFound")
    }
    
    if listing.Status != "active" {
        return errors.New("listing.notAvailable")
    }
    
    if listing.UserID == req.UserID {
        return errors.New("payment.selfPurchase")
    }

    // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É–º–º—ã
    if req.Amount.LessThanOrEqual(decimal.Zero) {
        return errors.New("payment.invalidAmount")
    }
    
    if !req.Amount.Equal(listing.Price) {
        return errors.New("payment.amountMismatch")
    }

    // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª—é—Ç—ã
    allowedCurrencies := []string{"EUR", "USD", "RSD"}
    if !contains(allowedCurrencies, req.Currency) {
        return errors.New("payment.unsupportedCurrency")
    }

    // 5. Rate limiting
    attempts, err := s.repository.GetRecentPaymentAttempts(ctx, req.UserID, time.Hour)
    if err != nil {
        s.logger.Warn("Failed to check payment attempts", "error", err)
    }
    
    if attempts >= 10 {
        return errors.New("payment.tooManyAttempts")
    }

    return nil
}
```

### **PCI DSS Compliance**
```go
// –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (–±–µ–∑ —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö)
func (s *PaymentService) logPaymentAttempt(ctx context.Context, req CreatePaymentRequest, result *PaymentResult, err error) {
    logData := map[string]interface{}{
        "user_id":        req.UserID,
        "listing_id":     req.ListingID,
        "amount":         req.Amount.String(),
        "currency":       req.Currency,
        "transaction_id": nil,
        "success":        err == nil,
        "timestamp":      time.Now().UTC(),
    }
    
    if result != nil {
        logData["transaction_id"] = result.TransactionID
        logData["gateway_uuid"] = result.GatewayUUID[:8] + "..." // –ß–∞—Å—Ç–∏—á–Ω–æ–µ –º–∞—Å–∫–∏—Ä–æ–≤–∞–Ω–∏–µ
    }
    
    if err != nil {
        logData["error_type"] = getErrorType(err)
        // –ù–ï –ª–æ–≥–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π —Ç–µ–∫—Å—Ç –æ—à–∏–±–∫–∏ –æ—Ç gateway
    }
    
    s.logger.Info("Payment attempt", logData)
}
```

## üìä –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –∏ –º–µ—Ç—Ä–∏–∫–∏

### **KPI –º–µ—Ç—Ä–∏–∫–∏**
```go
// –°–±–æ—Ä –º–µ—Ç—Ä–∏–∫ –ø–ª–∞—Ç–µ–∂–µ–π
type PaymentMetrics struct {
    ConversionRate     float64 `json:"conversion_rate"`
    AverageAmount      decimal.Decimal `json:"average_amount"`
    SuccessRate        float64 `json:"success_rate"`
    EscrowReleaseTime  time.Duration `json:"average_escrow_release_time"`
    ChargebackRate     float64 `json:"chargeback_rate"`
    PopularProviders   map[string]int `json:"popular_providers"`
}

func (s *AnalyticsService) CalculatePaymentMetrics(ctx context.Context, period time.Duration) (*PaymentMetrics, error) {
    since := time.Now().Add(-period)
    
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∑–∞ –ø–µ—Ä–∏–æ–¥
    totalAttempts, err := s.repository.CountPaymentAttempts(ctx, since)
    if err != nil {
        return nil, err
    }
    
    successfulPayments, err := s.repository.CountSuccessfulPayments(ctx, since)
    if err != nil {
        return nil, err
    }
    
    avgAmount, err := s.repository.GetAveragePaymentAmount(ctx, since)
    if err != nil {
        return nil, err
    }
    
    avgEscrowTime, err := s.repository.GetAverageEscrowReleaseTime(ctx, since)
    if err != nil {
        return nil, err
    }
    
    providerStats, err := s.repository.GetProviderStats(ctx, since)
    if err != nil {
        return nil, err
    }
    
    return &PaymentMetrics{
        ConversionRate:    float64(successfulPayments) / float64(totalAttempts) * 100,
        AverageAmount:     avgAmount,
        SuccessRate:       float64(successfulPayments) / float64(totalAttempts) * 100,
        EscrowReleaseTime: avgEscrowTime,
        PopularProviders:  providerStats,
    }, nil
}
```

### **Real-time –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥**
```typescript
// WebSocket –¥–ª—è real-time –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π —Å—Ç–∞—Ç—É—Å–∞ –ø–ª–∞—Ç–µ–∂–∞
export const usePaymentStatusUpdates = (transactionId: number) => {
  const [status, setStatus] = useState<PaymentStatus>('pending');
  const { socket } = useWebSocket();

  useEffect(() => {
    if (!socket || !transactionId) return;

    // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞
    socket.emit('subscribe_payment', { transaction_id: transactionId });

    const handleStatusUpdate = (data: { transaction_id: number; status: PaymentStatus; details?: any }) => {
      if (data.transaction_id === transactionId) {
        setStatus(data.status);
        
        // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        if (data.status === 'completed') {
          toast.success('–ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω!');
        } else if (data.status === 'failed') {
          toast.error('–ü–ª–∞—Ç–µ–∂ –Ω–µ –ø—Ä–æ—à–µ–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
        } else if (data.status === 'requires_action') {
          toast.info('–¢—Ä–µ–±—É–µ—Ç—Å—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è');
        }
      }
    };

    socket.on('payment_status_update', handleStatusUpdate);

    return () => {
      socket.off('payment_status_update', handleStatusUpdate);
      socket.emit('unsubscribe_payment', { transaction_id: transactionId });
    };
  }, [socket, transactionId]);

  return status;
};
```

## ‚ö†Ô∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

### **–¢–∏–ø—ã –æ—à–∏–±–æ–∫ –∏ –∏—Ö –æ–±—Ä–∞–±–æ—Ç–∫–∞**
```go
// –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –æ—à–∏–±–æ–∫ –ø–ª–∞—Ç–µ–∂–µ–π
type PaymentError struct {
    Code        string `json:"code"`
    Message     string `json:"message"`
    UserMessage string `json:"user_message"`
    Retryable   bool   `json:"retryable"`
    Action      string `json:"suggested_action"`
}

func (s *PaymentService) handlePaymentError(err error, provider string) *PaymentError {
    switch {
    case isNetworkError(err):
        return &PaymentError{
            Code:        "NETWORK_ERROR",
            Message:     err.Error(),
            UserMessage: "payment.networkError",
            Retryable:   true,
            Action:      "retry_after_delay",
        }
    
    case isInsufficientFundsError(err):
        return &PaymentError{
            Code:        "INSUFFICIENT_FUNDS",
            Message:     err.Error(),
            UserMessage: "payment.insufficientFunds",
            Retryable:   false,
            Action:      "change_payment_method",
        }
    
    case isCardDeclinedError(err):
        return &PaymentError{
            Code:        "CARD_DECLINED",
            Message:     err.Error(),
            UserMessage: "payment.cardDeclined",
            Retryable:   false,
            Action:      "contact_bank",
        }
    
    case is3DSRequiredError(err):
        return &PaymentError{
            Code:        "REQUIRES_3DS",
            Message:     err.Error(),
            UserMessage: "payment.requires3DS",
            Retryable:   true,
            Action:      "complete_3ds",
        }
    
    default:
        return &PaymentError{
            Code:        "UNKNOWN_ERROR",
            Message:     "Internal payment processing error",
            UserMessage: "payment.genericError",
            Retryable:   true,
            Action:      "retry_or_contact_support",
        }
    }
}
```

### **Webhook –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å**
```go
// –í–∞–ª–∏–¥–∞—Ü–∏—è webhook'–æ–≤
func (h *WebhookHandler) validateWebhook(r *http.Request, provider string) error {
    switch provider {
    case "allsecure":
        return h.validateAllSecureWebhook(r)
    case "stripe":
        return h.validateStripeWebhook(r)
    default:
        return errors.New("unknown provider")
    }
}

func (h *WebhookHandler) validateAllSecureWebhook(r *http.Request) error {
    signature := r.Header.Get("X-AllSecure-Signature")
    if signature == "" {
        return errors.New("missing signature")
    }
    
    body, err := io.ReadAll(r.Body)
    if err != nil {
        return err
    }
    
    expectedSignature := h.calculateSignature(body, h.config.AllSecureWebhookSecret)
    if !hmac.Equal([]byte(signature), []byte(expectedSignature)) {
        return errors.New("invalid signature")
    }
    
    return nil
}
```

## üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### **Unit —Ç–µ—Å—Ç—ã**
```go
func TestPaymentService_CreatePayment(t *testing.T) {
    tests := []struct {
        name           string
        request        CreatePaymentRequest
        mockSetup      func(*MockRepository, *MockAllSecureClient)
        expectedResult *PaymentResult
        expectedError  string
    }{
        {
            name: "successful_allsecure_payment",
            request: CreatePaymentRequest{
                UserID:    1,
                ListingID: 1,
                Amount:    decimal.NewFromFloat(100.00),
                Currency:  "EUR",
            },
            mockSetup: func(repo *MockRepository, client *MockAllSecureClient) {
                repo.EXPECT().GetUserByID(gomock.Any(), 1).Return(&models.User{
                    ID: 1, Email: "test@example.com", IsActive: true,
                }, nil)
                repo.EXPECT().GetListingByID(gomock.Any(), 1).Return(&models.MarketplaceListing{
                    ID: 1, Price: decimal.NewFromFloat(100.00), Status: "active", UserID: 2,
                }, nil)
                client.EXPECT().CreatePayment(gomock.Any()).Return(&allsecure.PaymentResult{
                    UUID: "test-uuid", Status: "pending", RedirectURL: "https://test.com/pay",
                }, nil)
            },
            expectedResult: &PaymentResult{
                Status:         "pending",
                RedirectURL:    "https://test.com/pay",
                RequiresAction: true,
            },
        },
        {
            name: "self_purchase_error",
            request: CreatePaymentRequest{
                UserID:    1,
                ListingID: 1,
                Amount:    decimal.NewFromFloat(100.00),
                Currency:  "EUR",
            },
            mockSetup: func(repo *MockRepository, client *MockAllSecureClient) {
                repo.EXPECT().GetListingByID(gomock.Any(), 1).Return(&models.MarketplaceListing{
                    ID: 1, UserID: 1, // Same user as purchaser
                }, nil)
            },
            expectedError: "payment.selfPurchase",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

### **Integration —Ç–µ—Å—Ç—ã**
```typescript
// E2E —Ç–µ—Å—Ç –ø–æ–∫—É–ø–∫–∏
describe('Purchase Flow Integration', () => {
  it('should complete AllSecure payment successfully', async () => {
    // 1. –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await loginUser('buyer@example.com');

    // 2. –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Ç–æ–≤–∞—Ä—É
    await page.goto('/listing/123');
    
    // 3. –ò–Ω–∏—Ü–∏–∞—Ü–∏—è –ø–æ–∫—É–ø–∫–∏
    await page.click('[data-testid="buy-now-button"]');
    
    // 4. –í—ã–±–æ—Ä —Å–ø–æ—Å–æ–±–∞ –æ–ø–ª–∞—Ç—ã
    await page.selectOption('[data-testid="payment-method"]', 'allsecure');
    
    // 5. –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–æ–∫—É–ø–∫–∏
    await page.click('[data-testid="confirm-purchase"]');
    
    // 6. –û–∂–∏–¥–∞–Ω–∏–µ —Ä–µ–¥–∏—Ä–µ–∫—Ç–∞
    await page.waitForURL(/payment-gateway/);
    
    // 7. –°–∏–º—É–ª—è—Ü–∏—è —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞
    await mockSuccessfulPayment();
    
    // 8. –í–æ–∑–≤—Ä–∞—Ç –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    await page.waitForURL(/payment\/success/);
    await expect(page.locator('[data-testid="payment-success"]')).toBeVisible();
    
    // 9. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —ç—Å–∫—Ä–æ—É-—Å—á–µ—Ç–∞
    const escrowStatus = await page.locator('[data-testid="escrow-status"]').textContent();
    expect(escrowStatus).toContain('–°—Ä–µ–¥—Å—Ç–≤–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã');
  });

  it('should handle payment failure gracefully', async () => {
    // –¢–µ—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –ø–ª–∞—Ç–µ–∂–∞
    await mockFailedPayment('CARD_DECLINED');
    
    await expect(page.locator('[data-testid="payment-error"]')).toBeVisible();
    await expect(page.locator('[data-testid="retry-button"]')).toBeVisible();
  });
});
```

## üöÄ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

### **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö**
```sql
-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø–ª–∞—Ç–µ–∂–µ–π
CREATE INDEX CONCURRENTLY idx_payments_user_status ON payments(user_id, status) WHERE status IN ('pending', 'processing');
CREATE INDEX CONCURRENTLY idx_payments_listing_date ON payments(listing_id, created_at DESC);
CREATE INDEX CONCURRENTLY idx_escrow_transactions_status ON escrow_transactions(status, created_at) WHERE status = 'active';

-- –ü–∞—Ä—Ç–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –¥–∞—Ç–∞–º –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤
CREATE TABLE payments_2024 PARTITION OF payments FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
CREATE TABLE payment_attempts_2024 PARTITION OF payment_attempts FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

### **–ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ**
```go
// –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–ª–∞—Ç–µ–∂–µ–π
func (s *PaymentService) getPaymentConfig(ctx context.Context) (*PaymentConfig, error) {
    cacheKey := "payment_config:v1"
    
    // –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –∫–µ—à–∞
    if cached, err := s.cache.Get(ctx, cacheKey); err == nil {
        var config PaymentConfig
        if err := json.Unmarshal(cached, &config); err == nil {
            return &config, nil
        }
    }
    
    // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑ –±–∞–∑—ã
    config, err := s.repository.GetPaymentConfig(ctx)
    if err != nil {
        return nil, err
    }
    
    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –∫–µ—à –Ω–∞ 5 –º–∏–Ω—É—Ç
    configData, _ := json.Marshal(config)
    s.cache.Set(ctx, cacheKey, configData, 5*time.Minute)
    
    return config, nil
}
```

## üìà –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –∞–ª–µ—Ä—Ç—ã

### **–ú–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞**
```go
// Prometheus –º–µ—Ç—Ä–∏–∫–∏
var (
    PaymentAttempts = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "payment_attempts_total",
            Help: "Total number of payment attempts",
        },
        []string{"provider", "currency", "status"},
    )
    
    PaymentDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "payment_processing_duration_seconds",
            Help: "Payment processing duration",
            Buckets: []float64{0.1, 0.5, 1, 2, 5, 10, 30},
        },
        []string{"provider", "status"},
    )
    
    EscrowBalance = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "escrow_balance_total",
            Help: "Total amount in escrow",
        },
        []string{"currency"},
    )
)
```

### **–ê–ª–µ—Ä—Ç—ã**
```yaml
# alerts.yml
groups:
  - name: payment_alerts
    rules:
      - alert: HighPaymentFailureRate
        expr: (rate(payment_attempts_total{status="failed"}[5m]) / rate(payment_attempts_total[5m])) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High payment failure rate detected"
          description: "Payment failure rate is {{ $value | humanizePercentage }} over the last 5 minutes"
      
      - alert: PaymentProcessingDelayed
        expr: histogram_quantile(0.95, payment_processing_duration_seconds) > 30
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Payment processing is taking too long"
          description: "95th percentile of payment processing time is {{ $value }}s"
```

---

## üìã –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞

### ‚úÖ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
- [x] AllSecure –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å API
- [x] Stripe –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å PaymentIntents
- [x] –≠—Å–∫—Ä–æ—É-–º–µ—Ö–∞–Ω–∏–∑–º –¥–ª—è –∑–∞—â–∏—Ç—ã –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π
- [x] Webhook –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–æ–≤
- [x] –†–∞—Å—á–µ—Ç –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–º–∏—Å—Å–∏—è–º–∏
- [x] Real-time —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å—Ç–∞—Ç—É—Å–µ –ø–ª–∞—Ç–µ–∂–µ–π
- [x] –í–∞–ª–∏–¥–∞—Ü–∏—è –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –Ω–∞ –≤—Å–µ—Ö —É—Ä–æ–≤–Ω—è—Ö
- [x] –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ –ø–æ–≤—Ç–æ—Ä–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏
- [x] –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –∏ –º–µ—Ç—Ä–∏–∫–∏ –ø–ª–∞—Ç–µ–∂–µ–π

### üîÑ –ü—Ä–æ—Ü–µ—Å—Å—ã –Ω–∞ –¥–æ—Ä–∞–±–æ—Ç–∫–µ
- [ ] –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–æ–≤ (refunds)
- [ ] –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–æ—à–µ–Ω–Ω–∏—á–µ—Å–∫–∏—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
- [ ] –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ payment –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞–º–∏
- [ ] –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–∞—Å—Å—Ä–æ—á–∫–∏ –∏ –ø–æ–¥–ø–∏—Å–æ–∫
- [ ] –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É—Ä–µ–≥—É–ª–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ø–æ—Ä–æ–≤ —á–µ—Ä–µ–∑ AI

### üìä –ú–µ—Ç—Ä–∏–∫–∏ —É—Å–ø–µ—Ö–∞
- **–ö–æ–Ω–≤–µ—Ä—Å–∏—è –ø–ª–∞—Ç–µ–∂–µ–π**: > 95%
- **–í—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏**: < 5 —Å–µ–∫—É–Ω–¥
- **–í—Ä–µ–º—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è —ç—Å–∫—Ä–æ—É**: < 24 —á–∞—Å–∞ –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
- **–£—Ä–æ–≤–µ–Ω—å —Å–ø–æ—Ä–æ–≤**: < 2%
- **–î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã**: > 99.9%