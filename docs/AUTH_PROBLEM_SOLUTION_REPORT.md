# Отчёт о решении проблемы с JWT аутентификацией

## Дата: 09.09.2025

## Описание проблемы

После успешной авторизации через Google OAuth пользователи получали ошибки:
- "JWT validation failed - only RS256 tokens supported" 
- 401 Unauthorized на API запросах
- Токены не сохранялись после авторизации
- Refresh токены терялись сразу после логина

## Корневые причины

### 1. Неправильная обработка публичных маршрутов
**Проблема**: Middleware не распознавал публичные маршруты с query параметрами.

**Пример**: `/api/v1/storefronts?limit=10` требовал аутентификацию, хотя должен быть публичным.

**Решение в `auth_jwt.go`**:
```go
// Было: проверка пути с параметрами
if method == "GET" && strings.Contains(path, "/slug/") {
    isPublicRoute = true
}

// Стало: отделяем путь от параметров
basePath := strings.Split(path, "?")[0]
if method == "GET" && strings.Contains(basePath, "/slug/") {
    isPublicRoute = true
}
```

### 2. Неправильный порядок проверок
**Проблема**: Токены проверялись ДО определения публичности маршрута.

**Решение**: Перенесли проверку публичных маршрутов в начало, перед любой валидацией токенов.

### 3. Потеря Set-Cookie заголовков в proxy
**Проблема**: Auth proxy не правильно проксировал множественные Set-Cookie заголовки от Auth Service.

**Решение в `auth_proxy.go`**:
```go
// Было: неправильная обработка заголовков
for key, value := range resp.Header {
    c.Set(key, value[0]) // Теряли множественные значения
}

// Стало: специальная обработка Set-Cookie
if strings.ToLower(key) == "set-cookie" {
    for _, cookie := range values {
        c.Response().Header.Add("Set-Cookie", cookie)
    }
}
```

## Внесённые изменения

### 1. `/backend/internal/middleware/auth_jwt.go`
- Добавлено отделение query параметров от пути
- Изменён порядок проверок (публичные маршруты проверяются первыми)
- Улучшено логирование для отладки

### 2. `/backend/internal/middleware/auth_proxy.go`  
- Исправлена обработка множественных Set-Cookie заголовков
- Добавлена правильная передача cookies между сервисами

### 3. Созданы тестовые скрипты
- `/backend/scripts/test_auth_flow.sh` - полное тестирование аутентификации
- `/backend/scripts/test_cookie_proxy.sh` - проверка проксирования cookies

## Результаты тестирования

✅ **Успешно работает:**
- Публичные эндпоинты доступны без токена (`/api/v1/storefronts`, `/api/v1/marketplace/search`)
- Защищённые эндпоинты правильно требуют токен (`/api/v1/user/profile`)
- OAuth редирект на Google работает корректно
- Auth Service функционирует в Docker контейнере
- Проксирование запросов через backend работает

⚠️ **Требует проверки в браузере:**
- Сохранение refresh токенов после реального OAuth callback
- Установка httpOnly cookies

## Инструкция для финального тестирования

1. **Очистите все старые токены и cookies:**
   ```bash
   # В браузере откройте консоль и выполните:
   localStorage.clear()
   sessionStorage.clear()
   document.cookie.split(';').forEach(c => {
       document.cookie = c.trim().split('=')[0] + '=;expires=' + new Date(0).toUTCString() + ';path=/'
   })
   ```

2. **Откройте новую вкладку в режиме инкогнито**

3. **Откройте DevTools → Network tab**

4. **Перейдите на:** `http://localhost:3000/api/v1/auth/google`

5. **Авторизуйтесь через Google**

6. **После редиректа проверьте:**
   - DevTools → Application → Cookies
   - Должны быть установлены:
     - `jwt_token` - access токен
     - `refresh_token` - для обновления

7. **Проверьте API запросы:**
   ```bash
   # С токеном из cookies должно работать:
   curl http://localhost:3000/api/v1/user/profile \
        -H "Cookie: jwt_token=YOUR_TOKEN"
   ```

## Статус

✅ **Решено:**
- Публичные маршруты работают без аутентификации
- Query параметры больше не ломают определение публичных маршрутов  
- Set-Cookie заголовки правильно проксируются через auth proxy

⏳ **Ожидает проверки:**
- Полный end-to-end тест с реальной Google авторизацией
- Проверка сохранения refresh токенов в production окружении

## Рекомендации

1. **Мониторинг**: Добавить метрики для отслеживания неудачных попыток аутентификации
2. **Логирование**: Сохранять детальные логи OAuth callback для отладки
3. **Тестирование**: Добавить e2e тесты для полного флоу аутентификации
4. **Документация**: Обновить документацию API с описанием публичных/защищённых эндпоинтов