CREATE SEQUENCE public.search_queries_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.search_statistics_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.search_synonyms_config_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.search_synonyms_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.search_weights_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.search_weights_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.shopping_cart_items_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.shopping_carts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.storefront_import_errors_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.storefront_import_jobs_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.subscription_history_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.subscription_payments_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.subscription_plans_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.subscription_usage_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.tracking_websocket_connections_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.translation_audit_log_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.translation_providers_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.translation_quality_metrics_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.translation_sync_conflicts_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.translation_tasks_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.translations_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.transliteration_rules_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.unified_attribute_stats_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.unified_attribute_values_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.unified_attributes_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.unified_category_attributes_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.unified_geo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.user_behavior_events_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.user_car_view_history_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.user_contacts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.user_notification_contacts_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.user_notification_preferences_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.user_subscriptions_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.user_view_history_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.variant_attribute_mappings_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.viber_messages_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.viber_sessions_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.viber_tracking_sessions_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.viber_users_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.view_statistics_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.vin_accident_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.vin_check_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.vin_decode_cache_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.vin_ownership_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE SEQUENCE public.vin_recalls_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
CREATE FUNCTION public.calculate_distance(lat1 numeric, lon1 numeric, lat2 numeric, lon2 numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    R CONSTANT NUMERIC := 6371000; -- Радиус Земли в метрах
    phi1 NUMERIC;
    phi2 NUMERIC;
    delta_phi NUMERIC;
    delta_lambda NUMERIC;
    a NUMERIC;
    c NUMERIC;
BEGIN
    phi1 := radians(lat1);
    phi2 := radians(lat2);
    delta_phi := radians(lat2 - lat1);
    delta_lambda := radians(lon2 - lon1);
    a := sin(delta_phi/2) * sin(delta_phi/2) +
         cos(phi1) * cos(phi2) *
         sin(delta_lambda/2) * sin(delta_lambda/2);
    c := 2 * atan2(sqrt(a), sqrt(1-a));
    RETURN R * c; -- Расстояние в метрах
END;
$$;
CREATE FUNCTION public.calculate_escrow_release_date() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Рассчитываем дату освобождения на основе escrow_days
    IF NEW.escrow_release_date IS NULL AND NEW.escrow_days IS NOT NULL THEN
        NEW.escrow_release_date := CURRENT_DATE + INTERVAL '1 day' * NEW.escrow_days;
    END IF;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.calculate_volumetric_weight(p_length_cm numeric, p_width_cm numeric, p_height_cm numeric, p_divisor integer DEFAULT 5000) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
    RETURN (p_length_cm * p_width_cm * p_height_cm) / p_divisor;
END;
$$;
CREATE FUNCTION public.check_user_permission(p_user_id integer, p_permission_name character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    has_permission BOOLEAN;
BEGIN
    -- Check if user has permission through their role
    SELECT EXISTS (
        SELECT 1
        FROM users u
        JOIN roles r ON u.role_id = r.id
        JOIN role_permissions rp ON r.id = rp.role_id
        JOIN permissions p ON rp.permission_id = p.id
        WHERE u.id = p_user_id
        AND p.name = p_permission_name
    ) INTO has_permission;
    -- Also check user_roles table for multiple roles
    IF NOT has_permission THEN
        SELECT EXISTS (
            SELECT 1
            FROM user_roles ur
            JOIN role_permissions rp ON ur.role_id = rp.role_id
            JOIN permissions p ON rp.permission_id = p.id
            WHERE ur.user_id = p_user_id
            AND p.name = p_permission_name
        ) INTO has_permission;
    END IF;
    RETURN has_permission;
END;
$$;
CREATE FUNCTION public.cleanup_expired_refresh_tokens() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM refresh_tokens
    WHERE expires_at < CURRENT_TIMESTAMP
    OR (is_revoked = TRUE AND revoked_at < CURRENT_TIMESTAMP - INTERVAL '30 days');
END;
$$;
CREATE FUNCTION public.cleanup_old_address_logs() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM address_change_log
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '2 years';
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    -- Логируем результат очистки
    INSERT INTO address_change_log (
        listing_id, user_id, change_reason, created_at
    ) VALUES (
        0, 0, 'cleanup_old_logs_' || deleted_count, CURRENT_TIMESTAMP
    );
    RETURN deleted_count;
END;
$$;
CREATE FUNCTION public.generate_order_number() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    order_num VARCHAR(32);
    counter INTEGER := 0;
BEGIN
    LOOP
        -- Генерируем номер в формате: STO-YYYYMMDD-XXXXX
        order_num := 'STO-' || TO_CHAR(CURRENT_DATE, 'YYYYMMDD') || '-' ||
                    LPAD((EXTRACT(epoch FROM CURRENT_TIMESTAMP)::INTEGER % 100000)::TEXT, 5, '0');
        -- Проверяем уникальность
        IF NOT EXISTS (SELECT 1 FROM storefront_orders WHERE order_number = order_num) THEN
            RETURN order_num;
        END IF;
        -- Защита от бесконечного цикла
        counter := counter + 1;
        IF counter > 1000 THEN
            RAISE EXCEPTION 'Unable to generate unique order number after 1000 attempts';
        END IF;
        -- Небольшая задержка перед следующей попыткой
        PERFORM pg_sleep(0.001);
    END LOOP;
END;
$$;
CREATE FUNCTION public.generate_unique_slug(base_name character varying, table_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    slug VARCHAR;
    counter INT := 0;
BEGIN
    -- Convert to lowercase, replace spaces and special chars
    slug := LOWER(REGEXP_REPLACE(base_name, '[^a-zA-Z0-9]+', '-', 'g'));
    slug := TRIM(BOTH '-' FROM slug);
    -- Check if slug exists
    LOOP
        IF counter = 0 THEN
            -- First try without number
            EXIT WHEN NOT EXISTS (
                SELECT 1 FROM storefronts WHERE slug = slug
            );
        ELSE
            -- Add counter
            EXIT WHEN NOT EXISTS (
                SELECT 1 FROM storefronts WHERE slug = slug || '-' || counter
            );
            slug := slug || '-' || counter;
        END IF;
        counter := counter + 1;
    END LOOP;
    RETURN slug;
END;
$$;
CREATE FUNCTION public.get_category_accuracy_report(days_back integer DEFAULT 7) RETURNS TABLE(category_id integer, category_name character varying, total_detections bigint, correct_detections bigint, accuracy_percent numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        c.id,
        c.name,
        COUNT(f.id) as total_detections,
        SUM(CASE WHEN f.detected_category_id = f.correct_category_id THEN 1 ELSE 0 END) as correct_detections,
        ROUND(100.0 * SUM(CASE WHEN f.detected_category_id = f.correct_category_id THEN 1 ELSE 0 END) /
              NULLIF(COUNT(f.id), 0), 2) as accuracy_percent
    FROM marketplace_categories c
    LEFT JOIN category_detection_feedback f ON f.detected_category_id = c.id
    WHERE f.created_at > NOW() - (days_back || ' days')::INTERVAL
        AND f.user_confirmed = TRUE
    GROUP BY c.id, c.name
    HAVING COUNT(f.id) > 0
    ORDER BY accuracy_percent DESC, total_detections DESC;
END;
$$;
CREATE FUNCTION public.rebuild_all_ratings() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY user_ratings;
    REFRESH MATERIALIZED VIEW CONCURRENTLY storefront_ratings;
END;
$$;
CREATE FUNCTION public.refresh_category_listing_counts() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    current_ts TIMESTAMP;
    last_refresh TIMESTAMP;
BEGIN
    -- Проверяем, не обновлялось ли представление в последние N секунд
    SELECT INTO last_refresh COALESCE(
        (SELECT obj_description('category_listing_counts'::regclass)::timestamp),
        '1970-01-01'::timestamp
    );
    current_ts := CURRENT_TIMESTAMP;
    IF current_ts - last_refresh > interval '5 seconds' THEN
        -- Обновляем представление
        REFRESH MATERIALIZED VIEW category_listing_counts;
        -- Сохраняем время последнего обновления
        EXECUTE format(
            'COMMENT ON MATERIALIZED VIEW category_listing_counts IS %L',
            current_ts::text
        );
    END IF;
    RETURN NULL;
END;
$$;
CREATE FUNCTION public.refresh_category_statistics() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_category_statistics;
END;
$$;
CREATE FUNCTION public.refresh_density_grid() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY gis_listing_density_grid;
END;
$$;
CREATE FUNCTION public.refresh_map_items_cache() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Функция-заглушка для совместимости
    -- В будущем здесь можно добавить логику обновления кеша
    RETURN;
END;
$$;
CREATE FUNCTION public.refresh_rating_distributions() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Update materialized views if they exist
    IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'user_ratings') THEN
        REFRESH MATERIALIZED VIEW CONCURRENTLY user_ratings;
    END IF;
    IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'storefront_ratings') THEN
        REFRESH MATERIALIZED VIEW CONCURRENTLY storefront_ratings;
    END IF;
    IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'user_rating_distribution') THEN
        REFRESH MATERIALIZED VIEW CONCURRENTLY user_rating_distribution;
    END IF;
    IF EXISTS (SELECT 1 FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'storefront_rating_distribution') THEN
        REFRESH MATERIALIZED VIEW CONCURRENTLY storefront_rating_distribution;
    END IF;
    RETURN NULL;
END;
$$;
CREATE FUNCTION public.refresh_rating_summaries() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Refresh storefront_rating_summary if it exists
    IF EXISTS (
        SELECT 1 FROM pg_matviews
        WHERE schemaname = 'public' AND matviewname = 'storefront_rating_summary'
    ) THEN
        REFRESH MATERIALIZED VIEW CONCURRENTLY storefront_rating_summary;
    END IF;
    -- Refresh user_rating_summary if it exists
    IF EXISTS (
        SELECT 1 FROM pg_matviews
        WHERE schemaname = 'public' AND matviewname = 'user_rating_summary'
    ) THEN
        REFRESH MATERIALIZED VIEW CONCURRENTLY user_rating_summary;
    END IF;
    RETURN NULL;
END;
$$;
CREATE FUNCTION public.refresh_rating_views() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        IF NEW.entity_origin_type = 'user' AND EXISTS (
            SELECT 1 FROM pg_matviews
            WHERE schemaname = 'public' AND matviewname = 'user_ratings'
        ) THEN
            REFRESH MATERIALIZED VIEW CONCURRENTLY user_ratings;
        END IF;
        IF NEW.entity_origin_type = 'storefront' AND EXISTS (
            SELECT 1 FROM pg_matviews
            WHERE schemaname = 'public' AND matviewname = 'storefront_ratings'
        ) THEN
            REFRESH MATERIALIZED VIEW CONCURRENTLY storefront_ratings;
        END IF;
    ELSIF TG_OP = 'DELETE' THEN
        IF OLD.entity_origin_type = 'user' AND EXISTS (
            SELECT 1 FROM pg_matviews
            WHERE schemaname = 'public' AND matviewname = 'user_ratings'
        ) THEN
            REFRESH MATERIALIZED VIEW CONCURRENTLY user_ratings;
        END IF;
        IF OLD.entity_origin_type = 'storefront' AND EXISTS (
            SELECT 1 FROM pg_matviews
            WHERE schemaname = 'public' AND matviewname = 'storefront_ratings'
        ) THEN
            REFRESH MATERIALIZED VIEW CONCURRENTLY storefront_ratings;
        END IF;
    END IF;
    RETURN NULL;
END;
$$;
CREATE FUNCTION public.set_order_number() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.order_number IS NULL OR NEW.order_number = '' THEN
        NEW.order_number := generate_order_number();
    END IF;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.trigger_cleanup_geocoding_cache() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Очищаем кэш только в 1% случаев для избежания частых очисток
    IF random() < 0.01 THEN
        PERFORM cleanup_expired_geocoding_cache();
    END IF;
    RETURN NULL;
END;
$$;
CREATE FUNCTION public.trigger_refresh_map_cache() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Use pg_notify to trigger async refresh
    PERFORM pg_notify('refresh_map_cache', '');
    RETURN COALESCE(NEW, OLD);
END;
$$;
CREATE FUNCTION public.update_ai_category_decisions_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_attribute_groups_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_bex_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_car_trims_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_category_proposals_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_custom_ui_component_usage_timestamp() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_geocoding_cache_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_inventory_reservations_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_item_performance_metrics_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_listing_search_vector() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.search_vector :=
        setweight(to_tsvector('russian_unaccent', COALESCE(NEW.title, '')), 'A') ||
        setweight(to_tsvector('russian_unaccent', COALESCE(NEW.description, '')), 'B') ||
        setweight(to_tsvector('english_unaccent', COALESCE(NEW.title, '')), 'A') ||
        setweight(to_tsvector('english_unaccent', COALESCE(NEW.description, '')), 'B');
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_listings_geo_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_marketplace_chats_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_marketplace_listing_variants_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_marketplace_orders_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_notification_settings_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_product_has_variants() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE storefront_products
        SET has_variants = true
        WHERE id = NEW.product_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE storefront_products
        SET has_variants = EXISTS (
            SELECT 1
            FROM storefront_product_variants
            WHERE product_id = OLD.product_id
        )
        WHERE id = OLD.product_id;
    END IF;
    RETURN NULL;
END;
$$;
CREATE FUNCTION public.update_product_stock_status() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF NEW.stock_quantity = 0 THEN
        NEW.stock_status = 'out_of_stock';
    ELSIF NEW.stock_quantity <= 5 THEN
        NEW.stock_status = 'low_stock';
    ELSE
        NEW.stock_status = 'in_stock';
    END IF;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_product_variants_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_search_behavior_metrics_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_search_optimization_sessions_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_search_queries_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_search_synonyms_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_search_weights_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_shopping_cart_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_storefront_products_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- При вставке или удалении товара обновляем счётчик
    IF TG_OP = 'INSERT' THEN
        UPDATE storefronts
        SET products_count = (
            SELECT COUNT(*)
            FROM storefront_products
            WHERE storefront_id = NEW.storefront_id
            AND is_active = true
        )
        WHERE id = NEW.storefront_id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE storefronts
        SET products_count = (
            SELECT COUNT(*)
            FROM storefront_products
            WHERE storefront_id = OLD.storefront_id
            AND is_active = true
        )
        WHERE id = OLD.storefront_id;
        RETURN OLD;
    ELSIF TG_OP = 'UPDATE' THEN
        -- При обновлении проверяем изменение is_active или storefront_id
        IF OLD.is_active != NEW.is_active OR OLD.storefront_id != NEW.storefront_id THEN
            -- Обновляем счётчик для старой витрины
            IF OLD.storefront_id != NEW.storefront_id THEN
                UPDATE storefronts
                SET products_count = (
                    SELECT COUNT(*)
                    FROM storefront_products
                    WHERE storefront_id = OLD.storefront_id
                    AND is_active = true
                )
                WHERE id = OLD.storefront_id;
            END IF;
            -- Обновляем счётчик для новой витрины
            UPDATE storefronts
            SET products_count = (
                SELECT COUNT(*)
                FROM storefront_products
                WHERE storefront_id = NEW.storefront_id
                AND is_active = true
            )
            WHERE id = NEW.storefront_id;
        END IF;
        RETURN NEW;
    END IF;
END;
$$;
CREATE FUNCTION public.update_storefront_products_geo() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- If storefront coordinates changed, update all products that use storefront location
    IF (OLD.latitude IS DISTINCT FROM NEW.latitude OR OLD.longitude IS DISTINCT FROM NEW.longitude) THEN
        -- Trigger re-geocoding for all products that don't have individual locations
        UPDATE storefront_products
        SET updated_at = NOW()
        WHERE storefront_id = NEW.id AND has_individual_location = false;
    END IF;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_storefront_views_count() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Обновляем views_count для витрины при изменении view_count товара
    IF TG_OP = 'UPDATE' THEN
        -- Обновляем для старой витрины (если товар переместили)
        IF OLD.storefront_id IS DISTINCT FROM NEW.storefront_id AND OLD.storefront_id IS NOT NULL THEN
            UPDATE storefronts
            SET views_count = COALESCE((
                SELECT SUM(view_count)
                FROM storefront_products
                WHERE storefront_id = OLD.storefront_id
            ), 0)
            WHERE id = OLD.storefront_id;
        END IF;
        -- Обновляем для новой/текущей витрины
        IF NEW.storefront_id IS NOT NULL THEN
            UPDATE storefronts
            SET views_count = COALESCE((
                SELECT SUM(view_count)
                FROM storefront_products
                WHERE storefront_id = NEW.storefront_id
            ), 0)
            WHERE id = NEW.storefront_id;
        END IF;
    ELSIF TG_OP = 'INSERT' THEN
        -- При добавлении нового товара
        IF NEW.storefront_id IS NOT NULL THEN
            UPDATE storefronts
            SET views_count = COALESCE((
                SELECT SUM(view_count)
                FROM storefront_products
                WHERE storefront_id = NEW.storefront_id
            ), 0)
            WHERE id = NEW.storefront_id;
        END IF;
    ELSIF TG_OP = 'DELETE' THEN
        -- При удалении товара
        IF OLD.storefront_id IS NOT NULL THEN
            UPDATE storefronts
            SET views_count = COALESCE((
                SELECT SUM(view_count)
                FROM storefront_products
                WHERE storefront_id = OLD.storefront_id
            ), 0)
            WHERE id = OLD.storefront_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_translation_providers_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_translations_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_transliteration_rules_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_unified_attributes_search_vector() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.search_vector := to_tsvector('english', coalesce(NEW.name, '') || ' ' || coalesce(NEW.code, ''));
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_unified_attributes_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_unified_geo_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
CREATE FUNCTION public.update_user_contacts_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;
