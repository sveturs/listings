# Отчет о нагрузочном тестировании поисковой системы

## Дата тестирования
7 июля 2025 года

## Обзор системы
- **Архитектура**: Go backend + OpenSearch + PostgreSQL + MinIO
- **Версия Go**: 1.24
- **OpenSearch**: docker-cluster (single node)
- **Тестируемые компоненты**:
  - Поисковые API endpoints
  - Автодополнение (suggestions)
  - Похожие объявления
  - Транслитерация
  - Асинхронное логирование

## Результаты нагрузочного тестирования

### 1. Простой поиск (/api/v1/marketplace/search)

| Concurrent Users | Requests | Mean Response Time | RPS | Failed Requests |
|------------------|----------|-------------------|-----|-----------------|
| 50               | 500      | 171.2 ms          | 292 | 427 (85.4%)     |
| 100              | 1000     | 294.3 ms          | 340 | 993 (99.3%)     |
| 200              | 2000     | 644.6 ms          | 310 | 1998 (99.9%)    |

**Анализ**: Высокий процент ошибок типа "Length" связан с вариативным размером поля `took_ms` в JSON ответах.

### 2. Сложный поиск с фильтрами

| Concurrent Users | Requests | Mean Response Time | RPS | Failed Requests |
|------------------|----------|-------------------|-----|-----------------|
| 50               | 500      | 114.4 ms          | 437 | 91 (18.2%)      |
| 100              | 1000     | 215.2 ms          | 465 | 983 (98.3%)     |
| 200              | 2000     | 413.5 ms          | 484 | 1976 (98.8%)    |

### 3. Автодополнение (/api/v1/marketplace/suggestions)

| Concurrent Users | Requests | Mean Response Time | RPS | Failed Requests |
|------------------|----------|-------------------|-----|-----------------|
| 50               | 500      | 55.9 ms           | 894 | 0 (0%)          |
| 100              | 1000     | 96.2 ms           | 1039| 0 (0%)          |
| 200              | 2000     | 166.0 ms          | 1205| 0 (0%)          |

**Отличная производительность** - стабильно высокий RPS без ошибок.

### 4. Похожие объявления (/api/v1/marketplace/listings/{id}/similar)

| Concurrent Users | Requests | Mean Response Time | RPS | Failed Requests |
|------------------|----------|-------------------|-----|-----------------|
| 50               | 500      | 44.2 ms           | 1131| 328 (65.6%)     |
| 100              | 1000     | 81.7 ms           | 1225| 666 (66.6%)     |
| 200              | 2000     | 120.8 ms          | 1656| 1352 (67.6%)    |

**Самый быстрый endpoint**, но высокий процент ошибок из-за вариации размеров ответов.

### 5. Влияние размера результатов

| Size | Mean Response Time | RPS | Failed Requests |
|------|-------------------|-----|-----------------|
| 10   | 269.5 ms          | 186 | 499 (99.8%)     |
| 50   | 267.2 ms          | 187 | 499 (99.8%)     |
| 100  | 284.5 ms          | 176 | 498 (99.6%)     |

**Размер результатов практически не влияет на производительность**.

## Сравнение логирования

### Минимальное логирование (LOG_LEVEL=error)
- **Mean Response Time**: 123.3 ms
- **RPS**: 405.4
- **Failed Requests**: 265 (53%)

### Полное логирование (LOG_LEVEL=info)
- **Mean Response Time**: 142.1 ms  
- **RPS**: 351.9
- **Failed Requests**: 369 (73.8%)

**Overhead логирования**: ~15% снижение производительности

## Анализ потребления памяти (pprof)

### Профилирование памяти до/после нагрузки

**Основные потребители памяти**:
1. `bufio.NewReaderSize` - 3084.01kB (59.81%)
2. `OpenSearchClient.Search` - 1554.07kB (30.14%)
3. `runtime.allocm` - 1026kB (19.90%)
4. `fasthttp.RequestHeader.parseFirstLine` - 1024.02kB (19.86%)

**Горутины**: 265 активных горутин после нагрузочного тестирования

### Отсутствие утечек памяти
- Профилирование показало нормальное потребление памяти
- Основные аллокации связаны с HTTP буферами и OpenSearch клиентом
- Нет критических утечек памяти

## Производительность транслитерации

- **Среднее время ответа**: 21-26ms
- **Стабильность**: Очень стабильная производительность
- **Overhead**: Минимальный overhead транслитерации

## Состояние OpenSearch

- **Статус кластера**: Yellow (нормально для single node)
- **Использование памяти JVM**: 14% (155MB из 1GB)
- **Активные шарды**: 75% (9 из 12)
- **Время отклика OpenSearch**: Стабильно низкое

## Использование системных ресурсов

- **CPU**: Очень низкое использование (0.0-0.2%)
- **Memory**: Стабильное потребление (0.1-0.2%)
- **Network**: Стабильная нагрузка

## Рекомендации по оптимизации

### 1. Критические проблемы

#### Высокий процент ошибок
- **Причина**: Apache Bench считает ошибкой различия в размере ответов (поле `took_ms`)
- **Решение**: Нормализовать размер поля `took_ms` или использовать другие инструменты нагрузочного тестирования

### 2. Оптимизация производительности

#### Логирование
- **Рекомендация**: Установить LOG_LEVEL=warn в production
- **Эффект**: +15% производительности
- **Компромисс**: Меньше диагностической информации

#### Буферизация HTTP
- **Проблема**: Высокое потребление памяти в `bufio` (60% аллокаций)
- **Решение**: Настроить размеры буферов HTTP клиента
- **Код**:
```go
// internal/server/server.go
app.Config.ReadBufferSize = 8192  // вместо дефолтных 4096
app.Config.WriteBufferSize = 8192
```

#### OpenSearch оптимизация
- **Память JVM**: Увеличить heap до 2GB для лучшей производительности
- **Шарды**: Добавить реплики для high availability
- **Кеширование**: Включить кеширование результатов на уровне приложения

### 3. Архитектурные улучшения

#### Кеширование
```go
// Добавить Redis кеш для suggestions
func (s *MarketplaceService) GetSuggestions(ctx context.Context, prefix string, size int) ([]string, error) {
    cacheKey := fmt.Sprintf("suggestions:%s:%d", prefix, size)
    
    // Попробовать получить из кеша
    if cached := s.cache.Get(cacheKey); cached != nil {
        return cached.([]string), nil
    }
    
    // Если нет в кеше, получить из OpenSearch
    results, err := s.repository.GetSuggestions(ctx, prefix, size)
    if err == nil {
        s.cache.Set(cacheKey, results, 5*time.Minute)
    }
    
    return results, err
}
```

#### Connection pooling
```go
// internal/storage/opensearch/client.go
client, err := opensearch.NewClient(opensearch.Config{
    Transport: &http.Transport{
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        IdleConnTimeout:     30 * time.Second,
    },
})
```

#### Асинхронная обработка логов поиска
- **Текущее**: Синхронное логирование в горутинах
- **Рекомендация**: Использовать очередь (например, RabbitMQ/Redis Streams)
- **Эффект**: Снижение latency на 5-10ms

### 4. Мониторинг в production

#### Метрики для отслеживания
- Response time percentiles (p50, p95, p99)
- Error rate by endpoint
- OpenSearch query latency
- Memory usage patterns
- Goroutine count

#### Алерты
- Response time > 500ms
- Error rate > 5%
- Memory usage > 80%
- Goroutine count > 1000

### 5. Масштабирование

#### Горизонтальное масштабирование
- Использовать load balancer (nginx/HAProxy)
- Stateless сервисы за счет вынесения кеша в Redis
- Auto-scaling на основе CPU/memory метрик

#### Вертикальное масштабирование
- **Текущее потребление**: Очень низкое
- **Рекомендация**: Система готова для значительного увеличения нагрузки
- **CPU limit**: Увеличить до 2 cores
- **Memory limit**: Увеличить до 4GB

## Выводы

1. **Система показывает хорошую производительность** при текущей нагрузке
2. **Автодополнение работает отлично** - самый стабильный endpoint
3. **Логирование имеет измеримый overhead** (~15%), рекомендуется оптимизация
4. **Нет критических утечек памяти** - профиль памяти здоровый
5. **OpenSearch справляется с нагрузкой** - низкое использование ресурсов
6. **Система готова к масштабированию** - низкое потребление ресурсов

## Файлы тестирования

- `/data/hostel-booking-system/backend/load_test.sh` - Скрипт нагрузочного тестирования
- `/tmp/load_test_logs/` - Детальные логи тестов
- `/tmp/load_test_results/` - CSV файлы с результатами
- `/tmp/heap_before.prof`, `/tmp/heap_after.prof` - Профили памяти
- `/tmp/goroutines.txt` - Дамп горутин

## Инструменты использованные

- **Apache Bench (ab)** - HTTP нагрузочное тестирование
- **go tool pprof** - Профилирование памяти и CPU
- **curl** - Простые HTTP тесты
- **OpenSearch REST API** - Мониторинг кластера