# Транзакционная безопасность в модуле заказов

## Проблема

До внедрения транзакций, процесс создания заказа мог привести к несогласованности данных:
- Заказ создан, но товар не зарезервирован
- Товар зарезервирован, но позиции заказа не созданы
- Количество товара уменьшено, но резервирование не создано

## Решение

Реализован новый метод `CreateOrderWithTx`, который выполняет все операции в единой транзакции:

### Архитектура

```
CreateOrderWithTx
├── BEGIN TRANSACTION
├── Проверка витрины (SELECT FOR SHARE)
├── Получение позиций корзины (SELECT FOR UPDATE)
├── Создание заказа (INSERT)
├── Для каждой позиции:
│   ├── Блокировка товара (SELECT FOR UPDATE)
│   ├── Проверка наличия
│   ├── Создание резервирования (INSERT)
│   ├── Обновление количества (UPDATE)
│   └── Создание позиции заказа (INSERT)
├── Расчет итогов
├── Обновление заказа (UPDATE)
├── Очистка корзины (DELETE/UPDATE)
└── COMMIT или ROLLBACK

```

### Уровни блокировки

1. **FOR SHARE** - для витрины (разрешает параллельное чтение)
2. **FOR UPDATE** - для товаров и корзины (эксклюзивная блокировка)

### Гарантии ACID

- **Atomicity**: Все операции выполняются или откатываются целиком
- **Consistency**: Проверки на каждом этапе гарантируют целостность
- **Isolation**: READ COMMITTED предотвращает dirty reads
- **Durability**: После COMMIT данные сохранены надежно

## Использование

### В handler:

```go
order, err := h.orderService.CreateOrderWithTx(ctx, h.db, &req, userID)
```

### Обработка ошибок:

```go
if err != nil {
    // Транзакция автоматически откатится
    // Резервирования будут освобождены
    return handleOrderError(err)
}
```

## Таблица резервирований

```sql
CREATE TABLE inventory_reservations (
    id BIGSERIAL PRIMARY KEY,
    product_id BIGINT NOT NULL,
    variant_id BIGINT,
    quantity INTEGER NOT NULL,
    order_id BIGINT NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'reserved',
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL
);
```

### Статусы резервирований:
- `reserved` - товар зарезервирован
- `committed` - резервирование подтверждено (товар списан)
- `released` - резервирование отменено

## Защита от overselling

При параллельных заказах на один товар:

1. Первая транзакция блокирует товар (SELECT FOR UPDATE)
2. Вторая транзакция ждет освобождения блокировки
3. После освобождения проверяет актуальное количество
4. Если товара недостаточно - откатывает транзакцию

## Производительность

- Индексы на всех foreign keys
- Составной индекс на (expires_at, status) для быстрой очистки
- Блокировки минимального уровня где возможно

## Мониторинг

Рекомендуется отслеживать:
- Количество откатов транзакций
- Время выполнения CreateOrderWithTx
- Количество истекших резервирований
- Deadlock'и (если возникают)

## Миграция со старого метода

1. Обновить handler для использования CreateOrderWithTx
2. Запустить в параллель со старым методом
3. После проверки - удалить старый CreateOrder

## Тестирование

См. `order_service_tx_test.go` для примеров тестов:
- Успешное создание заказа
- Откат при ошибке
- Недостаток товара
- Параллельные заказы