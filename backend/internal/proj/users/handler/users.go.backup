package handler

import (
	"strconv"

	"github.com/gofiber/fiber/v2"

	"backend/internal/domain/models"
	"backend/internal/logger"
	globalService "backend/internal/proj/global/service"
	"backend/internal/proj/users/service"
	"backend/internal/types"
	"backend/pkg/utils"
)

type UserHandler struct {
	services    globalService.ServicesInterface
	userService service.UserServiceInterface
}

func NewUserHandler(services globalService.ServicesInterface) *UserHandler {
	return &UserHandler{
		services:    services,
		userService: services.User(),
	}
}

// Response structures for Swagger documentation

// UserProfileResponse представляет ответ с профилем пользователя
type UserProfileResponse struct {
	Success bool                `json:"success" example:"true"`
	Data    *models.UserProfile `json:"data"`
}

// MessageResponse представляет ответ с сообщением
type MessageResponse struct {
	Message string `json:"message" example:"Операция выполнена успешно"`
}

// RegisterResponse представляет ответ после регистрации
type RegisterResponse struct {
	Message string       `json:"message" example:"Пользователь успешно зарегистрирован"`
	User    *models.User `json:"user"`
}

// PublicUserResponse представляет публичные данные пользователя
type PublicUserResponse struct {
	ID         int    `json:"id" example:"1"`
	Name       string `json:"name" example:"Иван Иванов"`
	Email      string `json:"email" example:"user@example.com"`
	PictureURL string `json:"picture_url" example:"https://example.com/avatar.jpg"`
	CreatedAt  string `json:"created_at" example:"2023-01-01T12:00:00Z"`
}

// PublicUserResponseWrapper обертка для публичного профиля
type PublicUserResponseWrapper struct {
	Success bool               `json:"success" example:"true"`
	Data    PublicUserResponse `json:"data"`
}

// AdminCheckResponse представляет ответ проверки администратора
type AdminCheckResponse struct {
	IsAdmin bool `json:"is_admin" example:"false"`
}

// AdminCheckResponseWrapper обертка для проверки администратора
type AdminCheckResponseWrapper struct {
	Success bool               `json:"success" example:"true"`
	Data    AdminCheckResponse `json:"data"`
}

// GetProfile returns current user profile
// @Summary Get current user profile
// @Description Returns full profile of the authenticated user
// @Tags users
// @Accept json
// @Produce json
// @Success 200 {object} utils.SuccessResponseSwag{data=models.UserProfile} "User profile"
// @Failure 401 {object} utils.ErrorResponseSwag "auth.required"
// @Failure 500 {object} utils.ErrorResponseSwag "users.profile.error.fetch"
// @Security BearerAuth
// @Router /api/v1/users/me [get]
func (h *UserHandler) GetProfile(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(int)

	profile, err := h.services.User().GetUserProfile(c.Context(), userID)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "users.profile.error.fetch")
	}

	// Проверяем, является ли пользователь администратором
	isAdmin, err := h.userService.IsUserAdmin(c.Context(), profile.Email)
	if err != nil {
		// Если ошибка при проверке админа, логируем но не прерываем запрос
		logger.Error().Err(err).Int("user_id", userID).Msg("Error checking admin status")
		isAdmin = false
	}

	// Добавляем информацию об админе в профиль
	profile.IsAdmin = isAdmin

	return utils.SuccessResponse(c, profile)
}

// UpdateProfile updates current user profile
// @Summary Update user profile
// @Description Updates profile of the authenticated user
// @Tags users
// @Accept json
// @Produce json
// @Param profile body models.UserProfileUpdate true "Profile update data"
// @Success 200 {object} utils.SuccessResponseSwag{data=MessageResponse} "Profile updated successfully"
// @Failure 400 {object} utils.ErrorResponseSwag "users.profile.error.invalid_data or users.profile.error.validation"
// @Failure 401 {object} utils.ErrorResponseSwag "auth.required"
// @Failure 500 {object} utils.ErrorResponseSwag "users.profile.error.update"
// @Security BearerAuth
// @Router /api/v1/users/me [put]
func (h *UserHandler) UpdateProfile(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(int)

	var update models.UserProfileUpdate
	if err := c.BodyParser(&update); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.profile.error.invalid_data")
	}

	// Валидация данных
	if err := update.Validate(); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.profile.error.validation")
	}

	err := h.services.User().UpdateUserProfile(c.Context(), userID, &update)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "users.profile.error.update")
	}

	return utils.SuccessResponse(c, &MessageResponse{
		Message: "users.profile.success.updated",
	})
}

// RegisterOld регистрирует нового пользователя
// @Summary Register user (deprecated)
// @Description Creates new user in the system. DEPRECATED: Use /api/v1/auth/register instead
// @Tags users
// @Accept json
// @Produce json
// @Param user body RegisterRequest true "Registration data (name, email, password required, phone optional)"
// @Success 201 {object} utils.SuccessResponseSwag{data=RegisterResponse} "User created successfully"
// @Failure 400 {object} utils.ErrorResponseSwag "users.register.error.invalid_data or validation errors"
// @Failure 500 {object} utils.ErrorResponseSwag "users.register.error.password_hash_failed or users.register.error.create_failed"
// @Router /api/v1/users/register [post]
// @Deprecated
func (h *UserHandler) RegisterOld(c *fiber.Ctx) error {
	var registerData RegisterRequest

	if err := c.BodyParser(&registerData); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.register.error.invalid_data")
	}

	// Базовая валидация
	if registerData.Name == "" {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.register.error.name_required")
	}
	if registerData.Email == "" {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.register.error.email_required")
	}
	if registerData.Password == "" {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.register.error.password_required")
	}
	if len(registerData.Password) < 6 {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.register.error.password_too_short")
	}

	// Хеширование пароля
	hashedPassword, err := utils.HashPassword(registerData.Password)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "users.register.error.password_hash_failed")
	}

	user := &models.User{
		Name:     registerData.Name,
		Email:    registerData.Email,
		Password: &hashedPassword,
		Phone:    registerData.Phone,
	}

	err = h.services.User().CreateUser(c.Context(), user)
	if err != nil {
		if err.Error() == "email already exists" {
			return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.register.error.email_exists")
		}
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "users.register.error.create_failed")
	}

	c.Status(fiber.StatusCreated)
	return utils.SuccessResponse(c, &RegisterResponse{
		Message: "users.register.success.created",
		User:    user,
	})
}

// LoginOld авторизует пользователя по email и паролю
// @Summary Login user (deprecated)
// @Description Authenticates user by email and password, creates session and sets session cookie. DEPRECATED: Use /api/v1/auth/login instead
// @Tags users
// @Accept json
// @Produce json
// @Param user body LoginRequest true "Login credentials (email and password required)"
// @Success 200 {object} utils.SuccessResponseSwag{data=LoginResponse} "Authentication successful"
// @Failure 400 {object} utils.ErrorResponseSwag "users.login.error.invalid_data or validation errors"
// @Failure 401 {object} utils.ErrorResponseSwag "users.login.error.invalid_credentials"
// @Router /api/v1/users/login [post]
// @Deprecated
func (h *UserHandler) LoginOld(c *fiber.Ctx) error {
	var loginData LoginRequest

	if err := c.BodyParser(&loginData); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.login.error.invalid_data")
	}

	// Базовая валидация
	if loginData.Email == "" {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.login.error.email_required")
	}
	if loginData.Password == "" {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.login.error.password_required")
	}

	// Получаем пользователя по email
	user, err := h.services.User().GetUserByEmail(c.Context(), loginData.Email)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusUnauthorized, "users.login.error.invalid_credentials")
	}

	// Проверяем пароль
	if user.Password == nil || !utils.CheckPasswordHash(loginData.Password, *user.Password) {
		logger.Info().
			Str("email", loginData.Email).
			Str("ip", c.IP()).
			Str("user_agent", c.Get("User-Agent")).
			Msg("Failed login attempt for user")
		return utils.ErrorResponse(c, fiber.StatusUnauthorized, "users.login.error.invalid_credentials")
	}

	// Создаем сессию для пользователя (как и при Google auth)
	sessionToken := utils.GenerateSessionToken()
	sessionData := &types.SessionData{
		UserID:     user.ID,
		Email:      user.Email,
		Name:       user.Name,
		Provider:   "password",
		PictureURL: user.PictureURL,
	}

	// Сохраняем сессию
	h.services.Auth().SaveSession(sessionToken, sessionData)

	// Устанавливаем session cookie (как и при Google auth)
	c.Cookie(&fiber.Cookie{
		Name:     "session_token",
		Value:    sessionToken,
		Path:     "/",
		Domain:   h.services.Config().GetCookieDomain(),
		MaxAge:   3600 * 24, // 24 часа
		Secure:   h.services.Config().GetCookieSecure(),
		HTTPOnly: true,
		SameSite: h.services.Config().GetCookieSameSite(),
	})

	// Логируем успешный логин
	logger.Info().
		Str("email", user.Email).
		Int("user_id", user.ID).
		Str("ip", c.IP()).
		Str("provider", "password").
		Msg("Successful login for user")

	// Возвращаем ответ без JWT токена (используем только сессию)
	return utils.SuccessResponse(c, &LoginResponse{
		Message: "users.login.success.authenticated",
		User:    user,
	})
}

// GetProfileByID returns public user profile
// @Summary Get public user profile
// @Description Returns public information about user by ID
// @Tags users
// @Accept json
// @Produce json
// @Param id path int true "User ID"
// @Success 200 {object} utils.SuccessResponseSwag{data=PublicUserResponse} "Public user profile"
// @Failure 400 {object} utils.ErrorResponseSwag "users.profile.error.invalid_id"
// @Failure 401 {object} utils.ErrorResponseSwag "auth.required"
// @Failure 404 {object} utils.ErrorResponseSwag "users.profile.error.not_found"
// @Security BearerAuth
// @Router /api/v1/users/{id}/profile [get]
func (h *UserHandler) GetProfileByID(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.profile.error.invalid_id")
	}

	user, err := h.userService.GetUserByID(c.Context(), id)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusNotFound, "users.profile.error.not_found")
	}

	publicUser := PublicUserResponse{
		ID:         user.ID,
		Name:       user.Name,
		Email:      user.Email,
		PictureURL: user.PictureURL,
		CreatedAt:  user.CreatedAt.Format("2006-01-02T15:04:05Z"),
	}

	return utils.SuccessResponse(c, publicUser)
}

// IsAdminSimple checks if user is administrator (simple implementation)
// @Summary Check admin status (simple)
// @Description Checks if user with specified email is administrator (simplified check by ID)
// @Tags users
// @Accept json
// @Produce json
// @Param email path string true "User email"
// @Success 200 {object} utils.SuccessResponseSwag{data=AdminCheckResponse} "Admin status"
// @Failure 400 {object} utils.ErrorResponseSwag "users.admin_check.error.email_required"
// @Failure 401 {object} utils.ErrorResponseSwag "auth.required"
// @Failure 404 {object} utils.ErrorResponseSwag "users.admin_check.error.user_not_found"
// @Security BearerAuth
// @Router /api/v1/users/admin-check/{email} [get]
func (h *UserHandler) IsAdminSimple(c *fiber.Ctx) error {
	email := c.Params("email")
	if email == "" {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.admin_check.error.email_required")
	}

	// Получаем пользователя по email
	user, err := h.userService.GetUserByEmail(c.Context(), email)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusNotFound, "users.admin_check.error.user_not_found")
	}

	// Проверяем, является ли пользователь администратором
	// В этой простой версии считаем администраторами только пользователей с ID 1, 2, 3
	isAdmin := user.ID == 1 || user.ID == 2 || user.ID == 3

	return utils.SuccessResponse(c, &AdminCheckResponse{
		IsAdmin: isAdmin,
	})
}

// GetAllUsers возвращает список всех пользователей с пагинацией (для админов)
// @Summary Get all users
// @Description Returns paginated list of all users (admin only)
// @Tags admin-users
// @Accept json
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(20)
// @Param status query string false "Filter by status (active, inactive, suspended)"
// @Success 200 {object} utils.SuccessResponseSwag{data=UsersListResponse} "Users list"
// @Failure 401 {object} utils.ErrorResponseSwag "auth.required"
// @Failure 403 {object} utils.ErrorResponseSwag "admin.users.error.access_denied"
// @Failure 500 {object} utils.ErrorResponseSwag "admin.users.error.fetch_failed"
// @Security BearerAuth
// @Router /api/v1/admin/users [get]
func (h *UserHandler) GetAllUsers(c *fiber.Ctx) error {
	// Проверяем, что пользователь авторизован
	userID, ok := c.Locals("user_id").(int)
	if !ok || userID == 0 {
		return utils.ErrorResponse(c, fiber.StatusUnauthorized, "auth.required")
	}

	// Проверяем, является ли пользователь администратором
	userEmail := c.Locals("user_email").(string)
	isAdmin, err := h.userService.IsUserAdmin(c.Context(), userEmail)
	if err != nil || !isAdmin {
		return utils.ErrorResponse(c, fiber.StatusForbidden, "admin.users.error.access_denied")
	}

	// Параметры пагинации
	page := c.QueryInt("page", 1)
	limit := c.QueryInt("limit", 20)
	if page < 1 {
		page = 1
	}
	if limit < 1 || limit > 100 {
		limit = 20
	}
	offset := (page - 1) * limit

	// Получаем список пользователей
	users, totalCount, err := h.userService.GetAllUsers(c.Context(), limit, offset)
	if err != nil {
		logger.Error().Err(err).Msg("Error fetching users list")
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "admin.users.error.fetch_failed")
	}

	return utils.SuccessResponse(c, &UsersListResponse{
		Users:      users,
		TotalCount: totalCount,
		Page:       page,
		PageSize:   limit,
	})
}

// UpdateUserStatus обновляет статус пользователя (для админов)
// @Summary Update user status
// @Description Updates user account status (admin only)
// @Tags admin-users
// @Accept json
// @Produce json
// @Param id path int true "User ID"
// @Param status body UpdateUserStatusRequest true "New status"
// @Success 200 {object} utils.SuccessResponseSwag{data=MessageResponse} "Status updated"
// @Failure 400 {object} utils.ErrorResponseSwag "admin.users.error.invalid_id or admin.users.error.invalid_status"
// @Failure 401 {object} utils.ErrorResponseSwag "auth.required"
// @Failure 403 {object} utils.ErrorResponseSwag "admin.users.error.access_denied or admin.users.error.cannot_modify_self"
// @Failure 404 {object} utils.ErrorResponseSwag "admin.users.error.not_found"
// @Failure 500 {object} utils.ErrorResponseSwag "admin.users.error.update_failed"
// @Security BearerAuth
// @Router /api/v1/admin/users/{id}/status [put]
func (h *UserHandler) UpdateUserStatus(c *fiber.Ctx) error {
	// Проверяем авторизацию
	currentUserID, ok := c.Locals("user_id").(int)
	if !ok || currentUserID == 0 {
		return utils.ErrorResponse(c, fiber.StatusUnauthorized, "auth.required")
	}

	// Проверяем права администратора
	userEmail := c.Locals("user_email").(string)
	isAdmin, err := h.userService.IsUserAdmin(c.Context(), userEmail)
	if err != nil || !isAdmin {
		return utils.ErrorResponse(c, fiber.StatusForbidden, "admin.users.error.access_denied")
	}

	// Получаем ID пользователя
	userID, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "admin.users.error.invalid_id")
	}

	// Нельзя изменять свой собственный статус
	if userID == currentUserID {
		return utils.ErrorResponse(c, fiber.StatusForbidden, "admin.users.error.cannot_modify_self")
	}

	// Парсим новый статус
	var req UpdateUserStatusRequest
	if err := c.BodyParser(&req); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "admin.users.error.invalid_status")
	}

	// Обновляем статус
	err = h.userService.UpdateUserStatus(c.Context(), userID, req.Status)
	if err != nil {
		if err.Error() == "user not found" {
			return utils.ErrorResponse(c, fiber.StatusNotFound, "admin.users.error.not_found")
		}
		logger.Error().Err(err).Int("user_id", userID).Msg("Error updating user status")
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "admin.users.error.update_failed")
	}

	return utils.SuccessResponse(c, &MessageResponse{
		Message: "admin.users.success.status_updated",
	})
}

// DeleteUser удаляет пользователя (для админов)
// @Summary Delete user
// @Description Permanently deletes user account (admin only)
// @Tags admin-users
// @Accept json
// @Produce json
// @Param id path int true "User ID"
// @Success 200 {object} utils.SuccessResponseSwag{data=MessageResponse} "User deleted"
// @Failure 400 {object} utils.ErrorResponseSwag "admin.users.error.invalid_id"
// @Failure 401 {object} utils.ErrorResponseSwag "auth.required"
// @Failure 403 {object} utils.ErrorResponseSwag "admin.users.error.access_denied or admin.users.error.cannot_delete_self"
// @Failure 404 {object} utils.ErrorResponseSwag "admin.users.error.not_found"
// @Failure 500 {object} utils.ErrorResponseSwag "admin.users.error.delete_failed"
// @Security BearerAuth
// @Router /api/v1/admin/users/{id} [delete]
func (h *UserHandler) DeleteUser(c *fiber.Ctx) error {
	// Проверяем авторизацию
	currentUserID, ok := c.Locals("user_id").(int)
	if !ok || currentUserID == 0 {
		return utils.ErrorResponse(c, fiber.StatusUnauthorized, "auth.required")
	}

	// Проверяем права администратора
	userEmail := c.Locals("user_email").(string)
	isAdmin, err := h.userService.IsUserAdmin(c.Context(), userEmail)
	if err != nil || !isAdmin {
		return utils.ErrorResponse(c, fiber.StatusForbidden, "admin.users.error.access_denied")
	}

	// Получаем ID пользователя для удаления
	userID, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "admin.users.error.invalid_id")
	}

	// Нельзя удалить самого себя
	if userID == currentUserID {
		return utils.ErrorResponse(c, fiber.StatusForbidden, "admin.users.error.cannot_delete_self")
	}

	// Удаляем пользователя
	err = h.userService.DeleteUser(c.Context(), userID)
	if err != nil {
		if err.Error() == "user not found" {
			return utils.ErrorResponse(c, fiber.StatusNotFound, "admin.users.error.not_found")
		}
		logger.Error().Err(err).Int("user_id", userID).Msg("Error deleting user")
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "admin.users.error.delete_failed")
	}

	logger.Info().
		Int("deleted_user_id", userID).
		Int("admin_id", currentUserID).
		Msg("User deleted by admin")

	return utils.SuccessResponse(c, &MessageResponse{
		Message: "admin.users.success.deleted",
	})
}

// GetPrivacySettings возвращает настройки приватности пользователя
// @Summary Get privacy settings
// @Description Returns privacy settings for the authenticated user
// @Tags users
// @Accept json
// @Produce json
// @Success 200 {object} utils.SuccessResponseSwag{data=models.UserPrivacySettings} "Privacy settings"
// @Failure 401 {object} utils.ErrorResponseSwag "auth.required"
// @Failure 500 {object} utils.ErrorResponseSwag "users.privacy.error.fetch"
// @Security BearerAuth
// @Router /api/v1/users/privacy-settings [get]
func (h *UserHandler) GetPrivacySettings(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(int)

	settings, err := h.userService.GetPrivacySettings(c.Context(), userID)
	if err != nil {
		logger.Error().Err(err).Int("user_id", userID).Msg("Error fetching privacy settings")
		// Возвращаем дефолтные настройки если их нет
		settings = &models.UserPrivacySettings{
			UserID:                        userID,
			AllowContactRequests:          true,
			AllowMessagesFromContactsOnly: false,
		}
	}

	return utils.SuccessResponse(c, settings)
}

// UpdatePrivacySettings обновляет настройки приватности пользователя
// @Summary Update privacy settings
// @Description Updates privacy settings for the authenticated user
// @Tags users
// @Accept json
// @Produce json
// @Param settings body models.UpdatePrivacySettingsRequest true "Privacy settings"
// @Success 200 {object} utils.SuccessResponseSwag{data=MessageResponse} "Settings updated"
// @Failure 400 {object} utils.ErrorResponseSwag "users.privacy.error.invalid_data"
// @Failure 401 {object} utils.ErrorResponseSwag "auth.required"
// @Failure 500 {object} utils.ErrorResponseSwag "users.privacy.error.update"
// @Security BearerAuth
// @Router /api/v1/users/privacy-settings [put]
func (h *UserHandler) UpdatePrivacySettings(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(int)

	var settings models.UpdatePrivacySettingsRequest
	if err := c.BodyParser(&settings); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "users.privacy.error.invalid_data")
	}

	err := h.userService.UpdatePrivacySettings(c.Context(), userID, &settings)
	if err != nil {
		logger.Error().Err(err).Int("user_id", userID).Msg("Error updating privacy settings")
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "users.privacy.error.update")
	}

	return utils.SuccessResponse(c, &MessageResponse{
		Message: "users.privacy.success.updated",
	})
}
