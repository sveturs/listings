=== /data/proj/hostel-booking-system/backend/.env.local ===

# Backend local development variables
DATABASE_URL=postgres://postgres:password@db:5432/hostel_db?sslmode=disable
GOOGLE_CLIENT_ID=917315728307-au9ga5fl7o3bbid9nv7e4l92gut194pq.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
GOOGLE_OAUTH_REDIRECT_URL=http://localhost:3000/auth/google/callback
FRONTEND_URL=http://localhost:3001
ENV=development
PORT=3000



TWILIO_ACCOUNT_SID=your_account_sid
TWILIO_AUTH_TOKEN=your_auth_token
TWILIO_VERIFY_SERVICE_ID=your_service_id
=== /data/proj/hostel-booking-system/backend/Dockerfile ===

FROM golang:1.21

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .

RUN mkdir -p uploads
RUN go mod tidy
RUN CGO_ENABLED=0 GOOS=linux go build -o main ./cmd/api

EXPOSE 3000

ENV APP_MODE production
ENV ENV_FILE .env

CMD ["./main"]

=== nginx.conf ===

upstream api_backend {
    server backend:3000;
}

server {
    listen 80;
    server_name landhub.rs www.landhub.rs;

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl;
    server_name landhub.rs www.landhub.rs;

    ssl_certificate /etc/letsencrypt/live/landhub.rs/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/landhub.rs/privkey.pem;

    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;

    # API routes - более специфичные маршруты должны идти первыми
    location /api/v1/marketplace {
        proxy_pass http://api_backend/api/v1/marketplace;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        error_log /var/log/nginx/marketplace_api_error.log debug;
        access_log /var/log/nginx/marketplace_api_access.log;
    }

    location /api/v1/cars {
        proxy_pass http://api_backend/api/v1/cars;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        error_log /var/log/nginx/cars_api_error.log debug;
        access_log /var/log/nginx/cars_api_access.log;
    }

    location /api/v1/car-bookings {
        proxy_pass http://api_backend/api/v1/car-bookings;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        error_log /var/log/nginx/car_bookings_api_error.log debug;
        access_log /var/log/nginx/car_bookings_api_access.log;
    }

    location /api/ {
        proxy_pass http://api_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        error_log /var/log/nginx/api_error.log debug;
        access_log /var/log/nginx/api_access.log;
    }

    location /auth/ {
        proxy_pass http://api_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        error_log /var/log/nginx/auth_error.log debug;
        access_log /var/log/nginx/auth_access.log;
    }

    location /rooms {
        proxy_pass http://api_backend/rooms;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /cars {
        proxy_pass http://api_backend/cars;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        error_log /var/log/nginx/cars_api_error.log debug;
        access_log /var/log/nginx/cars_api_access.log;
    }
location /ws/chat {
    proxy_pass http://api_backend/ws/chat;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_read_timeout 86400;
    proxy_send_timeout 86400;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_buffering off;
}
    # Статические файлы после API маршрутов
    location /uploads/ {
        alias /usr/share/nginx/uploads/;
        add_header Cache-Control "no-cache";
    }

    # Frontend как последний маршрут
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
        add_header Cache-Control "no-cache";
    }
}
=== deploy.sh ===

#!/bin/bash
set -e  # Останавливаем выполнение при ошибках

echo "Starting deployment..."

cd /opt/hostel-booking-system

# Настраиваем git pull strategy
git config pull.rebase false

# Создаем необходимые директории
mkdir -p backend/uploads
mkdir -p frontend/hostel-frontend/build
mkdir -p certbot/conf
mkdir -p certbot/www

# Сохраняем важные файлы
mkdir -p /tmp/hostel-backup
cp -f backend/.env /tmp/hostel-backup/backend.env 2>/dev/null || true
cp -f frontend/hostel-frontend/.env /tmp/hostel-backup/frontend.env 2>/dev/null || true

# Сохраняем SSL сертификаты
if [ -d "certbot/conf" ]; then
    cp -r certbot/conf /tmp/hostel-backup/ 2>/dev/null || true
fi

# Сохраняем загруженные изображения
cp -r backend/uploads /tmp/hostel-backup/ 2>/dev/null || true

# Обеспечиваем чистое состояние git
git fetch origin
git reset --hard origin/main
git clean -fdx -e "*.env*" -e "uploads/" -e "certbot/"

# Восстанавливаем файлы
cp -f /tmp/hostel-backup/backend.env backend/.env 2>/dev/null || true
cp -f /tmp/hostel-backup/frontend.env frontend/hostel-frontend/.env 2>/dev/null || true
if [ -d "/tmp/hostel-backup/conf" ]; then
    rm -rf certbot/conf
    cp -r /tmp/hostel-backup/conf certbot/ 2>/dev/null || true
fi

# Удаляем старые образы
docker image prune -f

# Очищаем сети и осиротевшие контейнеры
echo "Cleaning up orphan containers and networks..."
docker-compose -f docker-compose.prod.yml down -v --remove-orphans || true
docker network prune -f || true

# Собираем фронтенд
echo "Building frontend..."
cd frontend/hostel-frontend
NODE_ENV=production docker run -v $(pwd):/app -w /app node:18 sh -c "npm install && npm run build"
cd ../..

# Запускаем только базу данных
echo "Starting database..."
docker-compose -f docker-compose.prod.yml up --build -d db

# Проверяем базу данных
echo "Checking database readiness..."
RETRY_COUNT=30
for i in $(seq 1 $RETRY_COUNT); do
    if docker-compose -f docker-compose.prod.yml exec -T db pg_isready -U postgres > /dev/null 2>&1; then
        echo "Database is ready!"
        break
    fi
    echo "Waiting for database to be ready... Attempt $i/$RETRY_COUNT"
    sleep 2
done

if ! docker-compose -f docker-compose.prod.yml exec -T db pg_isready -U postgres > /dev/null 2>&1; then
    echo "Database failed to start"
    exit 1
fi

# Запускаем миграции
echo "Running migrations..."
docker run --rm --network hostel-booking-system_hostel_network -v $(pwd)/backend/migrations:/migrations migrate/migrate -path=/migrations/ -database="postgres://postgres:c9XWc7Cm@db:5432/hostel_db?sslmode=disable" up

# Запускаем остальные сервисы
echo "Starting services..."
docker-compose -f docker-compose.prod.yml up --build -d

echo "Deployment completed!"
=== /data/proj/hostel-booking-system/backend/.env ===

# Backend environment variables
DATABASE_URL=postgres://postgres:c9XWc7Cm@db:5432/hostel_db?sslmode=disable
GOOGLE_CLIENT_ID=917315728307-au9ga5fl7o3bbid9nv7e4l92gut194pq.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
GOOGLE_OAUTH_REDIRECT_URL=https://landhub.rs/auth/google/callback
FRONTEND_URL=https://landhub.rs
ENV=production
PORT=3000

=== /data/proj/hostel-booking-system/backend/cmd/api/main.go ===

package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"backend/internal/config"
	"backend/internal/server"

	"github.com/joho/godotenv"
)

func main() {
	// Загрузка конфигурации из файла окружения
	envFile := os.Getenv("ENV_FILE")
	if envFile == "" {
		envFile = ".env"
	}

	if err := godotenv.Load(envFile); err != nil {
		log.Printf("Warning: Could not load .env file: %s", envFile)
	}

	// Инициализация конфигурации
	cfg, err := config.NewConfig()
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	// Создание и запуск сервера
	srv, err := server.NewServer(cfg)
	if err != nil {
		log.Fatalf("Failed to create server: %v", err)
	}

	// Graceful shutdown
	go func() {
		if err := srv.Start(); err != nil {
			log.Printf("Server error: %v", err)
		}
	}()

	// Ожидание сигнала для graceful shutdown
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	log.Println("Shutting down server...")

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v", err)
	}

	log.Println("Server exited properly")
}

=== /data/proj/hostel-booking-system/backend/internal/types/auth.go ===

package types

import "golang.org/x/oauth2"

type SessionData struct {
    Token      *oauth2.Token `json:"-"`
    UserID     int          `json:"user_id"`
    Name       string       `json:"name"`
    Email      string       `json:"email"`
    GoogleID   string       `json:"google_id"`
    PictureURL string       `json:"picture_url"`
    Provider   string       `json:"provider"`
}
=== /data/proj/hostel-booking-system/backend/internal/storage/storage.go ===

// backend/internal/storage/storage.go
package storage

import (
	"backend/internal/domain/models"
	"context"
)

type Storage interface {
	// User methods
	GetOrCreateGoogleUser(ctx context.Context, user *models.User) (*models.User, error)
	GetUserByEmail(ctx context.Context, email string) (*models.User, error)
	GetUserByID(ctx context.Context, id int) (*models.User, error)
	CreateUser(ctx context.Context, user *models.User) error
	UpdateUser(ctx context.Context, user *models.User) error
	GetUserProfile(ctx context.Context, id int) (*models.UserProfile, error)
	UpdateUserProfile(ctx context.Context, id int, update *models.UserProfileUpdate) error
	UpdateLastSeen(ctx context.Context, id int) error

	// Car methods
	AddCar(ctx context.Context, car *models.Car) (int, error)
	GetAvailableCars(ctx context.Context, filters map[string]string) ([]models.Car, error)
	GetCarWithFeatures(ctx context.Context, carID int) (*models.Car, error)
	GetCarFeatures(ctx context.Context) ([]models.CarFeature, error)
	GetCarCategories(ctx context.Context) ([]models.CarCategory, error)
	CreateCarBooking(ctx context.Context, booking *models.CarBooking) error

	// Car image methods
	AddCarImage(ctx context.Context, image *models.CarImage) (int, error)
	GetCarImages(ctx context.Context, carID string) ([]models.CarImage, error)
	DeleteCarImage(ctx context.Context, imageID string) (string, error)

	// Reviews
	CreateReview(ctx context.Context, review *models.Review) (*models.Review, error)
	GetReviews(ctx context.Context, filter models.ReviewsFilter) ([]models.Review, int64, error)
	GetReviewByID(ctx context.Context, id int) (*models.Review, error)
	UpdateReview(ctx context.Context, review *models.Review) error
	DeleteReview(ctx context.Context, id int) error
	AddReviewResponse(ctx context.Context, response *models.ReviewResponse) error
	AddReviewVote(ctx context.Context, vote *models.ReviewVote) error
	GetReviewVotes(ctx context.Context, reviewId int) (helpful int, notHelpful int, err error)
	GetUserReviewVote(ctx context.Context, userId int, reviewId int) (string, error)
	GetEntityRating(ctx context.Context, entityType string, entityId int) (float64, error)
	QueryRow(ctx context.Context, sql string, args ...interface{}) Row
	Query(ctx context.Context, sql string, args ...interface{}) (Rows, error)

	// Room methods
	AddRoom(ctx context.Context, room *models.Room) (int, error)
	GetRooms(ctx context.Context, filters map[string]string, sortBy string, sortDirection string, limit int, offset int) ([]models.Room, int64, error)
	GetRoomByID(ctx context.Context, id int) (*models.Room, error)
	AddRoomImage(ctx context.Context, image *models.RoomImage) (int, error)
	GetRoomImages(ctx context.Context, roomID string) ([]models.RoomImage, error)
	DeleteRoomImage(ctx context.Context, imageID string) (string, error)

	// Bed methods - добавляем новые методы
	AddBed(ctx context.Context, roomID int, bedNumber string, pricePerNight float64, hasOutlet bool, hasLight bool, hasShelf bool, bedType string) (int, error)
	GetBedByID(ctx context.Context, id int) (*models.Bed, error)
	GetBedsByRoomID(ctx context.Context, roomID int) ([]models.Bed, error)
	UpdateBedAttributes(ctx context.Context, bedID int, bedReq *models.BedRequest) error
	UpdateBedAvailability(ctx context.Context, bedID int, isAvailable bool) error
	UpdateBedPrice(ctx context.Context, bedID int, price float64) error
	GetAvailableBeds(ctx context.Context, roomID string, startDate string, endDate string) ([]models.Bed, error)
	GetBedImages(ctx context.Context, bedID string) ([]models.RoomImage, error)
	AddBedImage(ctx context.Context, image *models.RoomImage) (int, error)

	// Booking methods
	CreateBooking(ctx context.Context, booking *models.BookingRequest) error
	GetAllBookings(ctx context.Context) ([]models.Booking, error)
	DeleteBooking(ctx context.Context, bookingID string, bookingType string) error

	// Marketplace methods
	CreateListing(ctx context.Context, listing *models.MarketplaceListing) (int, error)
	GetListings(ctx context.Context, filters map[string]string, limit int, offset int) ([]models.MarketplaceListing, int64, error)
	GetListingByID(ctx context.Context, id int) (*models.MarketplaceListing, error)
	UpdateListing(ctx context.Context, listing *models.MarketplaceListing) error
	DeleteListing(ctx context.Context, id int, userID int) error
	GetCategoryTree(ctx context.Context) ([]models.CategoryTreeNode, error)

	AddListingImage(ctx context.Context, image *models.MarketplaceImage) (int, error)
	GetListingImages(ctx context.Context, listingID string) ([]models.MarketplaceImage, error)
	DeleteListingImage(ctx context.Context, imageID string) (string, error)

	GetCategories(ctx context.Context) ([]models.MarketplaceCategory, error)
	GetCategoryByID(ctx context.Context, id int) (*models.MarketplaceCategory, error)

	AddToFavorites(ctx context.Context, userID int, listingID int) error
	RemoveFromFavorites(ctx context.Context, userID int, listingID int) error
	GetUserFavorites(ctx context.Context, userID int) ([]models.MarketplaceListing, error)

	// Marketplace Chat methods
	CreateMessage(ctx context.Context, msg *models.MarketplaceMessage) error
	GetMessages(ctx context.Context, listingID int, userID int, offset int, limit int) ([]models.MarketplaceMessage, error)
	GetChats(ctx context.Context, userID int) ([]models.MarketplaceChat, error)
	GetChat(ctx context.Context, chatID int, userID int) (*models.MarketplaceChat, error)
	MarkMessagesAsRead(ctx context.Context, messageIDs []int, userID int) error
	ArchiveChat(ctx context.Context, chatID int, userID int) error

	// Database connection
	Close()
	Ping(ctx context.Context) error
}

type Row interface {
	Scan(dest ...interface{}) error
}

type Rows interface {
	Next() bool
	Scan(dest ...interface{}) error
	Close() error
}

=== /data/proj/hostel-booking-system/backend/internal/storage/postgres/db.go ===

// backend/internal/storage/postgres/db.go
package postgres

import (
    "context"
    "github.com/jackc/pgx/v5/pgxpool"
    "github.com/jackc/pgx/v5"
    "backend/internal/storage"
    "backend/internal/domain/models" 
    "fmt"
    //"log"
    //"strconv"

    carStorage "backend/internal/proj/car/storage/postgres"
    marketplaceStorage "backend/internal/proj/marketplace/storage/postgres"
    reviewStorage "backend/internal/proj/reviews/storage/postgres"
    accommodationStorage "backend/internal/proj/accommodation/storage/postgres"
    userStorage             "backend/internal/proj/users/storage/postgres"
)

type Database struct {
    pool *pgxpool.Pool
    carDB *carStorage.Storage
    marketplaceDB *marketplaceStorage.Storage
    reviewDB *reviewStorage.Storage
    accommodationDB *accommodationStorage.Storage
    usersDB *userStorage.Storage 
    
}

func NewDatabase(dbURL string) (*Database, error) {
    pool, err := pgxpool.New(context.Background(), dbURL)
    if err != nil {
        return nil, fmt.Errorf("error creating connection pool: %w", err)
    }

    return &Database{
        pool:          pool,
        carDB:         carStorage.NewStorage(pool),
        marketplaceDB: marketplaceStorage.NewStorage(pool),
        reviewDB:      reviewStorage.NewStorage(pool),
        accommodationDB: accommodationStorage.NewStorage(pool),
        usersDB:        userStorage.NewStorage(pool),
    }, nil
}

var _ storage.Storage = (*Database)(nil) 

func (db *Database) Close() {
    if db.pool != nil {
        db.pool.Close()
    }
}

func (db *Database) Ping(ctx context.Context) error {
    return db.pool.Ping(ctx)
}

type RowsWrapper struct {
    rows pgx.Rows
}

func (r *RowsWrapper) Next() bool {
    return r.rows.Next()
}

func (r *RowsWrapper) Scan(dest ...interface{}) error {
    return r.rows.Scan(dest...)
}

func (r *RowsWrapper) Close() error {
    r.rows.Close()
    return nil
}

func (db *Database) Query(ctx context.Context, sql string, args ...interface{}) (storage.Rows, error) {
    rows, err := db.pool.Query(ctx, sql, args...)
    if err != nil {
        return nil, err
    }
    return &RowsWrapper{rows: rows}, nil
}

func (db *Database) QueryRow(ctx context.Context, sql string, args ...interface{}) storage.Row {
    return db.pool.QueryRow(ctx, sql, args...)
}

// Car methods
func (db *Database) AddCar(ctx context.Context, car *models.Car) (int, error) {
    return db.carDB.AddCar(ctx, car)
}

func (db *Database) GetAvailableCars(ctx context.Context, filters map[string]string) ([]models.Car, error) {
    return db.carDB.GetAvailableCars(ctx, filters)
}

func (db *Database) GetCarWithFeatures(ctx context.Context, carID int) (*models.Car, error) {
    return db.carDB.GetCarWithFeatures(ctx, carID)
}

func (db *Database) GetCarFeatures(ctx context.Context) ([]models.CarFeature, error) {
    return db.carDB.GetCarFeatures(ctx)
}

func (db *Database) GetCarCategories(ctx context.Context) ([]models.CarCategory, error) {
    return db.carDB.GetCarCategories(ctx)
}

func (db *Database) CreateCarBooking(ctx context.Context, booking *models.CarBooking) error {
    return db.carDB.CreateCarBooking(ctx, booking)
}

// Car image methods
func (db *Database) AddCarImage(ctx context.Context, image *models.CarImage) (int, error) {
    return db.carDB.AddCarImage(ctx, image)
}

func (db *Database) GetCarImages(ctx context.Context, carID string) ([]models.CarImage, error) {
    return db.carDB.GetCarImages(ctx, carID)
}

func (db *Database) DeleteCarImage(ctx context.Context, imageID string) (string, error) {
    return db.carDB.DeleteCarImage(ctx, imageID)
}
// Marketplace methods
func (db *Database) CreateListing(ctx context.Context, listing *models.MarketplaceListing) (int, error) {
    return db.marketplaceDB.CreateListing(ctx, listing)
}

func (db *Database) GetListings(ctx context.Context, filters map[string]string, limit int, offset int) ([]models.MarketplaceListing, int64, error) {
    return db.marketplaceDB.GetListings(ctx, filters, limit, offset)
}

func (db *Database) GetListingByID(ctx context.Context, id int) (*models.MarketplaceListing, error) {
    return db.marketplaceDB.GetListingByID(ctx, id)
}

func (db *Database) UpdateListing(ctx context.Context, listing *models.MarketplaceListing) error {
    return db.marketplaceDB.UpdateListing(ctx, listing)
}

func (db *Database) DeleteListing(ctx context.Context, id int, userID int) error {
    return db.marketplaceDB.DeleteListing(ctx, id, userID)
}

func (db *Database) GetCategories(ctx context.Context) ([]models.MarketplaceCategory, error) {
    return db.marketplaceDB.GetCategories(ctx)
}

func (db *Database) GetCategoryByID(ctx context.Context, id int) (*models.MarketplaceCategory, error) {
    return db.marketplaceDB.GetCategoryByID(ctx, id)
}

func (db *Database) GetCategoryTree(ctx context.Context) ([]models.CategoryTreeNode, error) {
    return db.marketplaceDB.GetCategoryTree(ctx)
}

func (db *Database) AddListingImage(ctx context.Context, image *models.MarketplaceImage) (int, error) {
    return db.marketplaceDB.AddListingImage(ctx, image)
}

func (db *Database) GetListingImages(ctx context.Context, listingID string) ([]models.MarketplaceImage, error) {
    return db.marketplaceDB.GetListingImages(ctx, listingID)
}

func (db *Database) DeleteListingImage(ctx context.Context, imageID string) (string, error) {
    return db.marketplaceDB.DeleteListingImage(ctx, imageID)
}

func (db *Database) AddToFavorites(ctx context.Context, userID int, listingID int) error {
    return db.marketplaceDB.AddToFavorites(ctx, userID, listingID)
}

func (db *Database) RemoveFromFavorites(ctx context.Context, userID int, listingID int) error {
    return db.marketplaceDB.RemoveFromFavorites(ctx, userID, listingID)
}

func (db *Database) GetUserFavorites(ctx context.Context, userID int) ([]models.MarketplaceListing, error) {
    return db.marketplaceDB.GetUserFavorites(ctx, userID)
}
// Добавляем делегирующие методы
func (db *Database) CreateReview(ctx context.Context, review *models.Review) (*models.Review, error) {
    return db.reviewDB.CreateReview(ctx, review)
}

func (db *Database) GetReviews(ctx context.Context, filter models.ReviewsFilter) ([]models.Review, int64, error) {
    return db.reviewDB.GetReviews(ctx, filter)
}

func (db *Database) GetReviewByID(ctx context.Context, id int) (*models.Review, error) {
    return db.reviewDB.GetReviewByID(ctx, id)
}

func (db *Database) UpdateReview(ctx context.Context, review *models.Review) error {
    return db.reviewDB.UpdateReview(ctx, review)
}

func (db *Database) DeleteReview(ctx context.Context, id int) error {
    return db.reviewDB.DeleteReview(ctx, id)
}

func (db *Database) AddReviewResponse(ctx context.Context, response *models.ReviewResponse) error {
    return db.reviewDB.AddReviewResponse(ctx, response)
}

func (db *Database) AddReviewVote(ctx context.Context, vote *models.ReviewVote) error {
    return db.reviewDB.AddReviewVote(ctx, vote)
}

func (db *Database) GetReviewVotes(ctx context.Context, reviewId int) (helpful int, notHelpful int, err error) {
    return db.reviewDB.GetReviewVotes(ctx, reviewId)
}

func (db *Database) GetUserReviewVote(ctx context.Context, userId int, reviewId int) (string, error) {
    return db.reviewDB.GetUserReviewVote(ctx, userId, reviewId)
}

func (db *Database) GetEntityRating(ctx context.Context, entityType string, entityId int) (float64, error) {
    return db.reviewDB.GetEntityRating(ctx, entityType, entityId)
}
// Методы для работы с images
func (db *Database) AddBedImage(ctx context.Context, image *models.RoomImage) (int, error) {
    return db.accommodationDB.AddBedImage(ctx, image)
}

func (db *Database) GetBedImages(ctx context.Context, bedID string) ([]models.RoomImage, error) {
    return db.accommodationDB.GetBedImages(ctx, bedID)
}

func (db *Database) AddRoomImage(ctx context.Context, image *models.RoomImage) (int, error) {
    return db.accommodationDB.AddRoomImage(ctx, image)
}

func (db *Database) GetRoomImages(ctx context.Context, roomID string) ([]models.RoomImage, error) {
    return db.accommodationDB.GetRoomImages(ctx, roomID)
}

func (db *Database) DeleteRoomImage(ctx context.Context, imageID string) (string, error) {
    return db.accommodationDB.DeleteRoomImage(ctx, imageID)
}

// Методы для работы с rooms
func (db *Database) AddRoom(ctx context.Context, room *models.Room) (int, error) {
    return db.accommodationDB.AddRoom(ctx, room)
}

func (db *Database) GetRooms(ctx context.Context, filters map[string]string, sortBy string, sortDirection string, limit int, offset int) ([]models.Room, int64, error) {
    return db.accommodationDB.GetRooms(ctx, filters, sortBy, sortDirection, limit, offset)
}

func (db *Database) GetRoomByID(ctx context.Context, id int) (*models.Room, error) {
    return db.accommodationDB.GetRoomByID(ctx, id)
}

// Методы для работы с beds
func (db *Database) AddBed(ctx context.Context, roomID int, bedNumber string, pricePerNight float64, hasOutlet bool, hasLight bool, hasShelf bool, bedType string) (int, error) {
    return db.accommodationDB.AddBed(ctx, roomID, bedNumber, pricePerNight, hasOutlet, hasLight, hasShelf, bedType)
}

func (db *Database) GetBedByID(ctx context.Context, id int) (*models.Bed, error) {
    return db.accommodationDB.GetBedByID(ctx, id)
}

func (db *Database) GetBedsByRoomID(ctx context.Context, roomID int) ([]models.Bed, error) {
    return db.accommodationDB.GetBedsByRoomID(ctx, roomID)
}

func (db *Database) GetAvailableBeds(ctx context.Context, roomID string, startDate string, endDate string) ([]models.Bed, error) {
    return db.accommodationDB.GetAvailableBeds(ctx, roomID, startDate, endDate)
}

func (db *Database) UpdateBedAvailability(ctx context.Context, bedID int, isAvailable bool) error {
    return db.accommodationDB.UpdateBedAvailability(ctx, bedID, isAvailable)
}

func (db *Database) UpdateBedPrice(ctx context.Context, bedID int, price float64) error {
    return db.accommodationDB.UpdateBedPrice(ctx, bedID, price)
}

func (db *Database) UpdateBedAttributes(ctx context.Context, bedID int, bedReq *models.BedRequest) error {
    return db.accommodationDB.UpdateBedAttributes(ctx, bedID, bedReq)
}

// Методы для работы с bookings
func (db *Database) CreateBooking(ctx context.Context, booking *models.BookingRequest) error {
    return db.accommodationDB.CreateBooking(ctx, booking)
}

func (db *Database) GetAllBookings(ctx context.Context) ([]models.Booking, error) {
    return db.accommodationDB.GetAllBookings(ctx)
}

func (db *Database) DeleteBooking(ctx context.Context, bookingID string, bookingType string) error {
    return db.accommodationDB.DeleteBooking(ctx, bookingID, bookingType)
}


// User methods
func (db *Database) GetUserByEmail(ctx context.Context, email string) (*models.User, error) {
    return db.usersDB.GetUserByEmail(ctx, email)
}

func (db *Database) GetUserByID(ctx context.Context, id int) (*models.User, error) {
    return db.usersDB.GetUserByID(ctx, id)
}

func (db *Database) CreateUser(ctx context.Context, user *models.User) error {
    return db.usersDB.CreateUser(ctx, user)
}

func (db *Database) UpdateUser(ctx context.Context, user *models.User) error {
    return db.usersDB.UpdateUser(ctx, user)
}

func (db *Database) GetOrCreateGoogleUser(ctx context.Context, user *models.User) (*models.User, error) {
    return db.usersDB.GetOrCreateGoogleUser(ctx, user)
}

func (db *Database) GetUserProfile(ctx context.Context, id int) (*models.UserProfile, error) {
    return db.usersDB.GetUserProfile(ctx, id)
}

func (db *Database) UpdateUserProfile(ctx context.Context, id int, update *models.UserProfileUpdate) error {
    return db.usersDB.UpdateUserProfile(ctx, id, update)
}

func (db *Database) UpdateLastSeen(ctx context.Context, id int) error {
    return db.usersDB.UpdateLastSeen(ctx, id)
}

// Добавить следующие методы в структуру Database:

func (db *Database) ArchiveChat(ctx context.Context, chatID int, userID int) error {
    return db.marketplaceDB.ArchiveChat(ctx, chatID, userID)
}

func (db *Database) CreateMessage(ctx context.Context, msg *models.MarketplaceMessage) error {
    return db.marketplaceDB.CreateMessage(ctx, msg)
}

func (db *Database) GetMessages(ctx context.Context, listingID int, userID int, offset int, limit int) ([]models.MarketplaceMessage, error) {
    return db.marketplaceDB.GetMessages(ctx, listingID, userID, offset, limit)
}

func (db *Database) GetChats(ctx context.Context, userID int) ([]models.MarketplaceChat, error) {
    return db.marketplaceDB.GetChats(ctx, userID)
}

func (db *Database) GetChat(ctx context.Context, chatID int, userID int) (*models.MarketplaceChat, error) {
    return db.marketplaceDB.GetChat(ctx, chatID, userID)
}

func (db *Database) MarkMessagesAsRead(ctx context.Context, messageIDs []int, userID int) error {
    return db.marketplaceDB.MarkMessagesAsRead(ctx, messageIDs, userID)
}
=== /data/proj/hostel-booking-system/backend/internal/config/config.go ===

package config

import (
	"fmt"
	"os"
)

type Config struct {
	Port               string
	DatabaseURL        string
	GoogleClientID     string
	GoogleClientSecret string
	GoogleRedirectURL  string
	FrontendURL        string
	Environment        string
}

func NewConfig() (*Config, error) {
	port := os.Getenv("PORT")
	if port == "" {
		port = "3000"
	}

	dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {
		return nil, fmt.Errorf("DATABASE_URL is not set")
	}

	googleClientID := os.Getenv("GOOGLE_CLIENT_ID")
	if googleClientID == "" {
		return nil, fmt.Errorf("GOOGLE_CLIENT_ID is not set")
	}

	googleClientSecret := os.Getenv("GOOGLE_CLIENT_SECRET")
	if googleClientSecret == "" {
		return nil, fmt.Errorf("GOOGLE_CLIENT_SECRET is not set")
	}

	googleRedirectURL := os.Getenv("GOOGLE_OAUTH_REDIRECT_URL")
	if googleRedirectURL == "" {
		return nil, fmt.Errorf("GOOGLE_OAUTH_REDIRECT_URL is not set")
	}

	frontendURL := os.Getenv("FRONTEND_URL")
	if frontendURL == "" {
		return nil, fmt.Errorf("FRONTEND_URL is not set")
	}

	environment := os.Getenv("APP_MODE")
	if environment == "" {
		environment = "development"
	}

	return &Config{
		Port:               port,
		DatabaseURL:        dbURL,
		GoogleClientID:     googleClientID,
		GoogleClientSecret: googleClientSecret,
		GoogleRedirectURL:  googleRedirectURL,
		FrontendURL:        frontendURL,
		Environment:        environment,
	}, nil
}

=== /data/proj/hostel-booking-system/backend/internal/server/server.go ===

// backend/internal/server/server.go
package server

import (
	accommodationHandler "backend/internal/proj/accommodation/handler"
	carHandler "backend/internal/proj/car/handler"
	marketplaceHandler "backend/internal/proj/marketplace/handler"
	reviewHandler "backend/internal/proj/reviews/handler"
	userHandler "backend/internal/proj/users/handler"

	"github.com/gofiber/websocket/v2"

	globalService "backend/internal/proj/global/service"

	"backend/internal/config"
	"backend/internal/middleware"
	"backend/internal/storage/postgres"
	"context"
	"fmt"
	"os"

	"github.com/gofiber/fiber/v2"
)

// Определяем структуру Server перед использованием
type Server struct {
	app           *fiber.App
	cfg           *config.Config
	users         *userHandler.Handler
	accommodation *accommodationHandler.Handler
	car           *carHandler.Handler
	middleware    *middleware.Middleware
	review        *reviewHandler.Handler
	marketplace   *marketplaceHandler.Handler
}

func NewServer(cfg *config.Config) (*Server, error) {
	db, err := postgres.NewDatabase(cfg.DatabaseURL)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize database: %w", err)
	}

	services := globalService.NewService(db, cfg)
	usersHandler := userHandler.NewHandler(services)
	accommodationHandler := accommodationHandler.NewHandler(services)
	carHandler := carHandler.NewHandler(services)
	reviewHandler := reviewHandler.NewHandler(services)
	marketplaceHandler := marketplaceHandler.NewHandler(services)

	middleware := middleware.NewMiddleware(cfg, services)

	// Инициализация Fiber
	app := fiber.New(fiber.Config{
		ErrorHandler: middleware.ErrorHandler,
	})

	// Применение middleware
	middleware.Setup(app)

	// Инициализация сервера
	server := &Server{
		app: app,
		cfg: cfg,
		//		handlers:   	handlers,
		users:         usersHandler,
		middleware:    middleware,
		accommodation: accommodationHandler,
		car:           carHandler,
		review:        reviewHandler,
		marketplace:   marketplaceHandler,
	}

	// Настройка маршрутов
	server.setupRoutes()

	return server, nil
}

// setupRoutes настраивает маршруты сервера
func (s *Server) setupRoutes() {
	// Root path
	s.app.Get("/", func(c *fiber.Ctx) error {
		return c.SendString("Hostel Booking System API")
	})

	// Static files
	s.app.Static("/uploads", "./uploads")
	os.MkdirAll("./uploads", os.ModePerm)

	// Пример маршрутов
	s.app.Get("/rooms", s.accommodation.Room.List)
	s.app.Get("/rooms/:id", s.accommodation.Room.Get)
	s.app.Get("/rooms/:id/images", s.accommodation.Room.ListImages)
	s.app.Get("/rooms/:id/available-beds", s.accommodation.Room.GetAvailableBeds)
	s.app.Get("/beds/:id/images", s.accommodation.Room.ListBedImages)

	// Публичные маршруты для автомобилей
	s.app.Get("/api/v1/cars/available", s.car.Car.GetAvailableCars)
	s.app.Get("/api/v1/cars/:id/images", s.car.Car.GetImages)
	s.app.Post("/api/v1/car-bookings", s.car.Car.CreateBooking)

	// Публичные маршруты маркетплейса
	marketplace := s.app.Group("/api/v1/marketplace")
	marketplace.Get("/listings", s.marketplace.Marketplace.GetListings)
	marketplace.Get("/categories", s.marketplace.Marketplace.GetCategories)
	marketplace.Get("/category-tree", s.marketplace.Marketplace.GetCategoryTree)

	// Публичные маршруты для отзывов
	review := s.app.Group("/api/v1/reviews")
	review.Get("/", s.review.Review.GetReviews)       // Получение списка отзывов
	review.Get("/:id", s.review.Review.GetReviewByID) // Получение отдельного отзыва
	review.Get("/stats", s.review.Review.GetStats)    // Статистика по отзывам

	// Auth routes
	auth := s.app.Group("/auth")
	auth.Get("/session", s.users.Auth.GetSession) // Исправлено
	auth.Get("/google", s.users.Auth.GoogleAuth)
	auth.Get("/google/callback", s.users.Auth.GoogleCallback)
	auth.Get("/logout", s.users.Auth.Logout)

	// Protected API routes
	api := s.app.Group("/api/v1", s.middleware.AuthRequired)
	cars := api.Group("/cars")
	cars.Post("/", s.car.Car.AddCar)
	cars.Post("/:id/images", s.car.Car.UploadImages)

	// Маршруты для отзывов, требующие авторизации
	protectedReviews := s.app.Group("/api/v1/reviews", s.middleware.AuthRequired)
	protectedReviews.Post("/", s.review.Review.CreateReview)            // Создание отзыва
	protectedReviews.Put("/:id", s.review.Review.UpdateReview)          // Обновление отзыва
	protectedReviews.Delete("/:id", s.review.Review.DeleteReview)       // Удаление отзыва
	protectedReviews.Post("/:id/vote", s.review.Review.VoteForReview)   // Голосование за отзыв
	protectedReviews.Post("/:id/response", s.review.Review.AddResponse) // Добавление ответа на отзыв
	protectedReviews.Post("/:id/photos", s.review.Review.UploadPhotos)  // Загрузка фотографий к отзыву

	// Маршруты для статистики по сущностям
	entityStats := s.app.Group("/api/v1/entity")
	entityStats.Get("/:type/:id/rating", s.review.Review.GetEntityRating) // Получение рейтинга сущности
	entityStats.Get("/:type/:id/stats", s.review.Review.GetEntityStats)   // Получение статистики по отзывам сущности

	// Protected room routes
	rooms := api.Group("/rooms")
	rooms.Post("/", s.accommodation.Room.Create)
	rooms.Post("/:id/images", s.accommodation.Room.UploadImages)
	rooms.Delete("/:id/images/:imageId", s.accommodation.Room.DeleteImage)
	rooms.Post("/:id/beds", s.accommodation.Room.AddBed)
	rooms.Post("/:roomId/beds/:bedId/images", s.accommodation.Room.UploadBedImages)

	// Protected booking routes
	bookings := api.Group("/bookings")
	bookings.Post("/", s.accommodation.Booking.Create)
	bookings.Get("/", s.accommodation.Booking.List)
	bookings.Delete("/:id", s.accommodation.Booking.Delete)
	// Protected user routes
	users := s.app.Group("/api/v1/users")
	users.Post("/register", s.users.User.Register)    // Исправлено
	users.Get("/me", s.users.User.GetProfile)         // Исправлено
	users.Put("/me", s.users.User.UpdateProfile)      // Исправлено
	users.Get("/profile", s.users.User.GetProfile)    // Исправлено
	users.Put("/profile", s.users.User.UpdateProfile) // Исправлено

	// Защищенные маршруты маркетплейса
	marketplaceProtected := api.Group("/marketplace")
	marketplaceProtected.Post("/listings", s.marketplace.Marketplace.CreateListing)
	marketplaceProtected.Get("/listings/:id", s.marketplace.Marketplace.GetListing)
	marketplaceProtected.Put("/listings/:id", s.marketplace.Marketplace.UpdateListing)
	marketplaceProtected.Delete("/listings/:id", s.marketplace.Marketplace.DeleteListing)
	marketplaceProtected.Post("/listings/:id/images", s.marketplace.Marketplace.UploadImages)
	marketplaceProtected.Post("/listings/:id/favorite", s.marketplace.Marketplace.AddToFavorites)
	marketplaceProtected.Delete("/listings/:id/favorite", s.marketplace.Marketplace.RemoveFromFavorites)
	marketplaceProtected.Get("/favorites", s.marketplace.Marketplace.GetFavorites)
	// Чат для маркетплейса
	chat := api.Group("/marketplace/chat")
	chat.Get("/", s.marketplace.Chat.GetChats)
	chat.Get("/:listing_id/messages", s.marketplace.Chat.GetMessages)
	chat.Post("/messages", s.marketplace.Chat.SendMessage)
	chat.Put("/messages/read", s.marketplace.Chat.MarkAsRead)
	chat.Post("/:chat_id/archive", s.marketplace.Chat.ArchiveChat) 

	// WebSocket эндпоинт
	s.app.Use("/ws/chat", s.middleware.AuthRequired) // Защищаем WebSocket
	s.app.Get("/ws/chat", websocket.New(s.marketplace.Chat.HandleWebSocket))
}
func (s *Server) Start() error {
	return s.app.Listen(fmt.Sprintf(":%s", s.cfg.Port))
}

// Shutdown останавливает сервер
func (s *Server) Shutdown(ctx context.Context) error {
	return s.app.Shutdown()
}

=== /data/proj/hostel-booking-system/backend/internal/domain/models/review.go ===

// backend/internal/domain/models/review.go

package models

import "time"

type Review struct {
    ID                int       `json:"id"`
    UserID            int       `json:"user_id"`
    EntityType        string    `json:"entity_type"`
    EntityID          int       `json:"entity_id"`
    Rating            int       `json:"rating"`
    Comment           string    `json:"comment,omitempty"`
    Pros              string    `json:"pros,omitempty"`
    Cons              string    `json:"cons,omitempty"`
    Photos            []string  `json:"photos,omitempty"`
    LikesCount        int       `json:"likes_count"`
    IsVerifiedPurchase bool     `json:"is_verified_purchase"`
    Status            string    `json:"status"`
    CreatedAt         time.Time `json:"created_at"`
    UpdatedAt         time.Time `json:"updated_at"`
	HelpfulVotes      int       `json:"helpful_votes"`       
	NotHelpfulVotes   int       `json:"not_helpful_votes"`   
    
    // Дополнительные поля для отображения
    User              *User     `json:"user,omitempty"`
    Responses         []ReviewResponse `json:"responses,omitempty"`
    VotesCount        struct {
        Helpful     int `json:"helpful"`
        NotHelpful  int `json:"not_helpful"`
    } `json:"votes_count,omitempty"`
    CurrentUserVote   string    `json:"current_user_vote,omitempty"`
}

type ReviewResponse struct {
    ID        int       `json:"id"`
    ReviewID  int       `json:"review_id"`
    UserID    int       `json:"user_id"`
    Response  string    `json:"response"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    User      *User     `json:"user,omitempty"`
}

type ReviewVote struct {
    ReviewID  int       `json:"review_id"`
    UserID    int       `json:"user_id"`
    VoteType  string    `json:"vote_type"`
    CreatedAt time.Time `json:"created_at"`
}

// Запрос на создание отзыва
type CreateReviewRequest struct {
    EntityType  string   `json:"entity_type" validate:"required,oneof=listing room car"`
    EntityID    int      `json:"entity_id" validate:"required"`
    Rating      int      `json:"rating" validate:"required,min=1,max=5"`
    Comment     string   `json:"comment"`
    Pros        string   `json:"pros"`
    Cons        string   `json:"cons"`
    Photos      []string `json:"photos"`
}

// Фильтры для получения отзывов
type ReviewsFilter struct {
    EntityType string `query:"entity_type"`
    EntityID   int    `query:"entity_id"`
    UserID     int    `query:"user_id"`
    MinRating  int    `query:"min_rating"`
    MaxRating  int    `query:"max_rating"`
    Status     string `query:"status"`
    SortBy     string `query:"sort_by"` // rating, date, likes
    SortOrder  string `query:"sort_order"` // asc, desc
    Page       int    `query:"page"`
    Limit      int    `query:"limit"`
}
type ReviewStats struct {
    TotalReviews      int     `json:"total_reviews"`
    AverageRating     float64 `json:"average_rating"`
    VerifiedReviews   int     `json:"verified_reviews"`
    RatingDistribution map[int]int `json:"rating_distribution"` // Распределение оценок: {1: 10, 2: 20, ...}
    PhotoReviews      int     `json:"photo_reviews"`          // Количество отзывов с фото
}
=== /data/proj/hostel-booking-system/backend/internal/domain/models/user_profile.go ===

// backend/internal/domain/models/user_profile.go
package models

import (
    "encoding/json"
    "time"
	"fmt"
)

// UserProfile расширяет базовую модель User дополнительными полями профиля
type UserProfile struct {
    User
    Phone            *string          `json:"phone,omitempty"`
    Bio             *string          `json:"bio,omitempty"`
    NotificationEmail bool            `json:"notification_email"`
    NotificationPush bool            `json:"notification_push"`
    Timezone        string           `json:"timezone"`
    LastSeen        *time.Time       `json:"last_seen,omitempty"`
    AccountStatus   string           `json:"account_status"`
    Settings        json.RawMessage  `json:"settings,omitempty"`
}

// UserProfileUpdate используется для частичного обновления профиля
type UserProfileUpdate struct {
    Phone            *string          `json:"phone,omitempty"`
    Bio             *string          `json:"bio,omitempty"`
    NotificationEmail *bool           `json:"notification_email,omitempty"`
    NotificationPush *bool           `json:"notification_push,omitempty"`
    Timezone        *string          `json:"timezone,omitempty"`
    Settings        json.RawMessage  `json:"settings,omitempty"`
}

// Validate проверяет корректность данных профиля
func (up *UserProfileUpdate) Validate() error {
    if up.Phone != nil && len(*up.Phone) > 20 {
        return fmt.Errorf("phone number is too long")
    }
    if up.Bio != nil && len(*up.Bio) > 1000 {
        return fmt.Errorf("bio is too long")
    }
    if up.Timezone != nil && !isValidTimezone(*up.Timezone) {
        return fmt.Errorf("invalid timezone")
    }
    return nil
}

// isValidTimezone проверяет существование часового пояса
func isValidTimezone(tz string) bool {
    _, err := time.LoadLocation(tz)
    return err == nil
}
=== /data/proj/hostel-booking-system/backend/internal/domain/models/booking.go ===

package models

type BookingRequest struct {
	UserID    int    `json:"user_id"`
	RoomID    int    `json:"room_id"`
	BedID     *int   `json:"bed_id,omitempty"`
	StartDate string `json:"start_date"`
	EndDate   string `json:"end_date"`
}

type BedRequest struct {
    BedNumber     string  `json:"bed_number"`
    PricePerNight float64 `json:"price_per_night"`
    HasOutlet     bool    `json:"has_outlet"`
    HasLight      bool    `json:"has_light"` 
    HasShelf      bool    `json:"has_shelf"`
    BedType       string  `json:"bed_type"` // 'top', 'bottom', 'single'
}
=== /data/proj/hostel-booking-system/backend/internal/domain/models/models.go ===

// backend/internal/domain/models/models.go
package models

import "time"

type User struct {
	ID         int       `json:"id"`
	Name       string    `json:"name"`
	Email      string    `json:"email"`
	GoogleID   string    `json:"google_id"`
	PictureURL string    `json:"picture_url"`
	CreatedAt  time.Time `json:"created_at"`
}
type CarCategory struct {
	ID          int    `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type CarImage struct {
	ID          int       `json:"id"`
	CarID       int       `json:"car_id"`
	FilePath    string    `json:"file_path"`
	FileName    string    `json:"file_name"`
	FileSize    int       `json:"file_size"`
	ContentType string    `json:"content_type"`
	IsMain      bool      `json:"is_main"`
	CreatedAt   time.Time `json:"created_at"`
}

type Car struct {
	ID                int        `json:"id"`
	Make              string     `json:"make"`
	Model             string     `json:"model"`
	Year              int        `json:"year"`
	PricePerDay       float64    `json:"price_per_day"`
	Location          string     `json:"location"`
	Latitude          float64    `json:"latitude"`
	Longitude         float64    `json:"longitude"`
	Description       string     `json:"description,omitempty"`
	Availability      bool       `json:"availability"`
	Transmission      string     `json:"transmission"`
	FuelType          string     `json:"fuel_type"`
	Seats             int        `json:"seats"`
	CategoryID        int        `json:"category_id"`
	Category          string     `json:"category"`
	Features          []string   `json:"features"`
	DailyMileageLimit *int       `json:"daily_mileage_limit"` // Изменить на указатель
	InsuranceIncluded bool       `json:"insurance_included"`
	Images            []CarImage `json:"images,omitempty"`
	CreatedAt         time.Time  `json:"created_at"`
}

type CarBooking struct {
	ID              int       `json:"id"`
	CarID           int       `json:"car_id"`
	UserID          int       `json:"user_id"`
	StartDate       time.Time `json:"start_date"`
	EndDate         time.Time `json:"end_date"`
	PickupLocation  string    `json:"pickup_location"`
	DropoffLocation string    `json:"dropoff_location"`
	Status          string    `json:"status"`
	TotalPrice      float64   `json:"total_price"`
	CreatedAt       time.Time `json:"created_at"`
	Car             *Car      `json:"car,omitempty"`
	UserName        string    `json:"user_name,omitempty"`
	UserEmail       string    `json:"user_email,omitempty"`
}
type CarFeature struct {
	ID          int    `json:"id"`
	Name        string `json:"name"`
	Category    string `json:"category"`
	Description string `json:"description,omitempty"`
}

type Room struct {
	ID                 int         `json:"id"`
	Name               string      `json:"name"`
	Capacity           int         `json:"capacity"`
	PricePerNight      float64     `json:"price_per_night"`
	AddressStreet      string      `json:"address_street"`
	AddressCity        string      `json:"address_city"`
	AddressState       string      `json:"address_state"`
	AddressCountry     string      `json:"address_country"`
	AddressPostalCode  string      `json:"address_postal_code"`
	AccommodationType  string      `json:"accommodation_type"`
	IsShared           bool        `json:"is_shared"`
	TotalBeds          *int        `json:"total_beds,omitempty"`     // Сделали указателем
	AvailableBeds      *int        `json:"available_beds,omitempty"` // Сделали указателем
	HasPrivateBathroom bool        `json:"has_private_bathroom"`
	Latitude           *float64    `json:"latitude,omitempty"`  // Сделали указателем
	Longitude          *float64    `json:"longitude,omitempty"` // Сделали указателем
	FormattedAddress   string      `json:"formatted_address"`
	CreatedAt          time.Time   `json:"created_at"`
	ActualPrice        float64     `json:"actual_price"`
	AvailableCount     int         `json:"available_count"`
	Rating             float64     `json:"rating"`
	Images             []RoomImage `json:"images,omitempty"`
}

type RoomImage struct {
	ID          int       `json:"id"`
	RoomID      int       `json:"room_id"`
	BedID       int       `json:"bed_id,omitempty"` // Добавляем это поле
	FilePath    string    `json:"file_path"`
	FileName    string    `json:"file_name"`
	FileSize    int       `json:"file_size"`
	ContentType string    `json:"content_type"`
	IsMain      bool      `json:"is_main"`
	CreatedAt   time.Time `json:"created_at"`
}

type Booking struct {
	ID                int       `json:"id"`
	UserID            int       `json:"user_id"`
	RoomID            int       `json:"room_id"`
	BedID             *int      `json:"bed_id,omitempty"`
	StartDate         time.Time `json:"start_date"`
	EndDate           time.Time `json:"end_date"`
	Status            string    `json:"status"`
	RoomName          string    `json:"room_name"`
	AccommodationType string    `json:"type"`
	UserName          string    `json:"user_name"`
	UserEmail         string    `json:"user_email"`
	BookingType       string    `json:"booking_type"`
}

type Bed struct {
	ID            int     `json:"id"`
	RoomID        int     `json:"room_id"`
	BedNumber     string  `json:"bed_number"`
	IsAvailable   bool    `json:"is_available"`
	PricePerNight float64 `json:"price_per_night"`
	HasOutlet     bool    `json:"has_outlet"`
	HasLight      bool    `json:"has_light"`
	HasShelf      bool    `json:"has_shelf"`
	BedType       string  `json:"bed_type"`
}
type MarketplaceListing struct {
	ID              int                  `json:"id"`
	UserID          int                  `json:"user_id"`
	CategoryID      int                  `json:"category_id"`
	Title           string               `json:"title"`
	Description     string               `json:"description"`
	Price           float64              `json:"price"`
	Condition       string               `json:"condition"`
	Status          string               `json:"status"`
	Location        string               `json:"location"`
	Latitude        *float64             `json:"latitude,omitempty"`
	Longitude       *float64             `json:"longitude,omitempty"`
	City            string               `json:"city"`
	Country         string               `json:"country"`
	ViewsCount      int                  `json:"views_count"`
	CreatedAt       time.Time            `json:"created_at"`
	UpdatedAt       time.Time            `json:"updated_at"`
	Images          []MarketplaceImage   `json:"images,omitempty"`
	User            *User                `json:"user,omitempty"`
	Category        *MarketplaceCategory `json:"category,omitempty"`
	HelpfulVotes    int                  `json:"helpful_votes"`
	NotHelpfulVotes int                  `json:"not_helpful_votes"`
	IsFavorite 		bool 				 `json:"is_favorite"`
	ShowOnMap       bool			     `json:"show_on_map"`
	
}

type MarketplaceCategory struct {
	ID        int       `json:"id"`
	Name      string    `json:"name"`
	Slug      string    `json:"slug"`
	ParentID  *int      `json:"parent_id,omitempty"`
	Icon      string    `json:"icon,omitempty"`
	CreatedAt time.Time `json:"created_at"`
}
type MarketplaceImage struct {
	ID          int       `json:"id"`
	ListingID   int       `json:"listing_id"`
	FilePath    string    `json:"file_path"`
	FileName    string    `json:"file_name"`
	FileSize    int       `json:"file_size"`
	ContentType string    `json:"content_type"`
	IsMain      bool      `json:"is_main"`
	CreatedAt   time.Time `json:"created_at"`
}
type CategoryTreeNode struct {
	ID           int                `json:"id"`
	Name         string             `json:"name"`
	Slug         string             `json:"slug"`
	Icon         string             `json:"icon,omitempty"`
	ParentID     *int               `json:"parent_id,omitempty"`
	CreatedAt    time.Time          `json:"created_at"`
	Level        int                `json:"level"`
	Path         string             `json:"path"`
	ListingCount int                `json:"listing_count"`
	Children     []CategoryTreeNode `json:"children,omitempty"`
}

=== /data/proj/hostel-booking-system/backend/internal/domain/models/marketplace_chat.go ===

// backend/internal/domain/models/marketplace_chat.go
package models

import "time"

type MarketplaceMessage struct {
    ID         int       `json:"id"`
    ChatID     int       `json:"chat_id"`
    ListingID  int       `json:"listing_id"`
    SenderID   int       `json:"sender_id"`
    ReceiverID int       `json:"receiver_id"`
    Content    string    `json:"content"`
    IsRead     bool      `json:"is_read"`
    CreatedAt  time.Time `json:"created_at"`
    UpdatedAt  time.Time `json:"updated_at"`
    
    // Дополнительные поля для отображения
    Sender   *User             `json:"sender,omitempty"`
    Receiver *User             `json:"receiver,omitempty"`
    Listing  *MarketplaceListing `json:"listing,omitempty"`
}

type MarketplaceChat struct {
	ID            int       `json:"id"`
	ListingID     int       `json:"listing_id"`
	BuyerID       int       `json:"buyer_id"`
	SellerID      int       `json:"seller_id"`
	LastMessageAt time.Time `json:"last_message_at"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	IsArchived    bool      `json:"is_archived"`

	// Дополнительные поля для отображения
	Buyer       *User               `json:"buyer,omitempty"`
	Seller      *User               `json:"seller,omitempty"`
	Listing     *MarketplaceListing `json:"listing,omitempty"`
	LastMessage *MarketplaceMessage `json:"last_message,omitempty"`
	UnreadCount int                 `json:"unread_count"`
}

// Структуры для запросов
type CreateMessageRequest struct {
	ListingID  int    `json:"listing_id" validate:"required"`
	ReceiverID int    `json:"receiver_id" validate:"required"`
	Content    string `json:"content" validate:"required"`
}

type GetMessagesRequest struct {
	ListingID int `query:"listing_id"`
	ChatID    int `query:"chat_id"`
	Page      int `query:"page"`
	Limit     int `query:"limit"`
}

type MarkAsReadRequest struct {
	MessageIDs []int `json:"message_ids" validate:"required"`
}

=== /data/proj/hostel-booking-system/backend/internal/proj/users/service/auth.go ===

// backend/internal/proj/users/service/auth.go
package service

import (
    "context"
    "backend/internal/domain/models"
    "backend/internal/types"
    "backend/internal/storage"
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/google"
    oauth2v2 "google.golang.org/api/oauth2/v2"
    "sync"
)

type AuthService struct {
    googleConfig *oauth2.Config
    sessions     sync.Map
    storage      storage.Storage
}

func NewAuthService(
    googleClientID string,
    googleClientSecret string,
    googleRedirectURL string,
    storage storage.Storage,
) *AuthService {
    googleConfig := &oauth2.Config{
        ClientID:     googleClientID,
        ClientSecret: googleClientSecret,
        RedirectURL:  googleRedirectURL,
        Scopes: []string{
            "https://www.googleapis.com/auth/userinfo.profile",
            "https://www.googleapis.com/auth/userinfo.email",
        },
        Endpoint: google.Endpoint,
    }

    return &AuthService{
        googleConfig: googleConfig,
        storage:     storage,
    }
}

func (s *AuthService) GetGoogleAuthURL() string {
    return s.googleConfig.AuthCodeURL(
        "state",
        oauth2.SetAuthURLParam("prompt", "select_account"),
        oauth2.SetAuthURLParam("access_type", "offline"),
        oauth2.SetAuthURLParam("include_granted_scopes", "true"),
    )
}

func (s *AuthService) HandleGoogleCallback(ctx context.Context, code string) (*types.SessionData, error) {
    token, err := s.googleConfig.Exchange(ctx, code)
    if err != nil {
        return nil, err
    }

    oauth2Service, err := oauth2v2.New(s.googleConfig.Client(ctx, token))
    if err != nil {
        return nil, err
    }

    userInfo, err := oauth2Service.Userinfo.Get().Do()
    if err != nil {
        return nil, err
    }

    user, err := s.storage.GetOrCreateGoogleUser(ctx, &models.User{
        Name:       userInfo.Name,
        Email:      userInfo.Email,
        GoogleID:   userInfo.Id,
        PictureURL: userInfo.Picture,
    })
    if err != nil {
        return nil, err
    }

    return &types.SessionData{
        Token:      token,
        UserID:     user.ID,
        Name:       user.Name,
        Email:      user.Email,
        GoogleID:   user.GoogleID,
        PictureURL: user.PictureURL,
        Provider:   "google",
    }, nil
}

func (s *AuthService) SaveSession(token string, data *types.SessionData) {
    s.sessions.Store(token, data)
}

func (s *AuthService) GetSession(token string) (*types.SessionData, bool) {
    if value, ok := s.sessions.Load(token); ok {
        if sessionData, ok := value.(*types.SessionData); ok {
            return sessionData, true
        }
    }
    return nil, false
}

func (s *AuthService) DeleteSession(token string) {
    s.sessions.Delete(token)
}
=== /data/proj/hostel-booking-system/backend/internal/proj/users/service/interface.go ===

// backend/internal/proj/users/service/interface.go
package service

import (
    "context"
    "backend/internal/domain/models"
    "backend/internal/types"
)

type AuthServiceInterface interface {
    GetGoogleAuthURL() string
    HandleGoogleCallback(ctx context.Context, code string) (*types.SessionData, error)
    SaveSession(token string, data *types.SessionData)
    GetSession(token string) (*types.SessionData, bool)
    DeleteSession(token string)
}

type UserServiceInterface interface {
    GetUserByID(ctx context.Context, id int) (*models.User, error)
    GetUserByEmail(ctx context.Context, email string) (*models.User, error)
    CreateUser(ctx context.Context, user *models.User) error
    UpdateUser(ctx context.Context, user *models.User) error
    GetUserProfile(ctx context.Context, id int) (*models.UserProfile, error)
    UpdateUserProfile(ctx context.Context, id int, update *models.UserProfileUpdate) error
    UpdateLastSeen(ctx context.Context, id int) error
}
=== /data/proj/hostel-booking-system/backend/internal/proj/users/service/service.go ===

// backend/internal/proj/users/service/service.go
package service

import (
    "backend/internal/storage"
)

type Service struct {
    Auth AuthServiceInterface
    User UserServiceInterface
}

func NewService(store storage.Storage, googleClientID, googleClientSecret, googleRedirectURL string) *Service {
    return &Service{
        Auth: NewAuthService(googleClientID, googleClientSecret, googleRedirectURL, store),
        User: NewUserService(store),
    }
}
=== /data/proj/hostel-booking-system/backend/internal/proj/users/service/user.go ===

// backend/internal/proj/users/service/user.go
package service

import (
    "context"
    "backend/internal/domain/models"
    "backend/internal/storage"
)

type UserService struct {
    storage storage.Storage
}

func NewUserService(storage storage.Storage) *UserService {
    return &UserService{
        storage: storage,
    }
}

func (s *UserService) GetUserByID(ctx context.Context, id int) (*models.User, error) {
    return s.storage.GetUserByID(ctx, id)
}

func (s *UserService) GetUserByEmail(ctx context.Context, email string) (*models.User, error) {
    return s.storage.GetUserByEmail(ctx, email)
}

func (s *UserService) CreateUser(ctx context.Context, user *models.User) error {
    return s.storage.CreateUser(ctx, user)
}

func (s *UserService) UpdateUser(ctx context.Context, user *models.User) error {
    return s.storage.UpdateUser(ctx, user)
}

func (s *UserService) GetUserProfile(ctx context.Context, id int) (*models.UserProfile, error) {
    return s.storage.GetUserProfile(ctx, id)
}

func (s *UserService) UpdateUserProfile(ctx context.Context, id int, update *models.UserProfileUpdate) error {
    return s.storage.UpdateUserProfile(ctx, id, update)
}

func (s *UserService) UpdateLastSeen(ctx context.Context, id int) error {
    return s.storage.UpdateLastSeen(ctx, id)
}
=== /data/proj/hostel-booking-system/backend/internal/proj/users/storage/interface.go ===

// backend/internal/proj/users/storage/interface.go
package storage

import (
    "context"
    "backend/internal/domain/models"
)

// UserRepository определяет интерфейс для работы с пользователями
type UserRepository interface {
    // User methods
    GetOrCreateGoogleUser(ctx context.Context, user *models.User) (*models.User, error)
    GetUserByEmail(ctx context.Context, email string) (*models.User, error)
    GetUserByID(ctx context.Context, id int) (*models.User, error)
    CreateUser(ctx context.Context, user *models.User) error
    UpdateUser(ctx context.Context, user *models.User) error
}

// ProfileRepository определяет интерфейс для работы с профилями пользователей
type ProfileRepository interface {
    GetUserProfile(ctx context.Context, id int) (*models.UserProfile, error)
    UpdateUserProfile(ctx context.Context, id int, update *models.UserProfileUpdate) error
    UpdateLastSeen(ctx context.Context, id int) error
}

// Repository объединяет все репозитории для домена users
type Repository interface {
    UserRepository
    ProfileRepository
}
=== /data/proj/hostel-booking-system/backend/internal/proj/users/storage/postgres/user_profile.go ===

// backend/internal/proj/users/storage/postgres/user_profile.go
package postgres

import (
    "context"
    "fmt"
    "strings"
    "backend/internal/domain/models"
)

func (s *Storage) GetUserProfile(ctx context.Context, userID int) (*models.UserProfile, error) {
    profile := &models.UserProfile{}
    err := s.pool.QueryRow(ctx, `
        SELECT 
            id, name, email, google_id, picture_url, created_at,
            phone, bio, notification_email, notification_push,
            timezone, last_seen, account_status, settings
        FROM users 
        WHERE id = $1
    `, userID).Scan(
        &profile.ID, &profile.Name, &profile.Email, &profile.GoogleID, &profile.PictureURL,
        &profile.CreatedAt, &profile.Phone, &profile.Bio, &profile.NotificationEmail,
        &profile.NotificationPush, &profile.Timezone, &profile.LastSeen,
        &profile.AccountStatus, &profile.Settings,
    )
    if err != nil {
        return nil, err
    }
    return profile, nil
}

func (s *Storage) UpdateUserProfile(ctx context.Context, userID int, update *models.UserProfileUpdate) error {
    var setFields []string
    var params []interface{}
    paramCount := 1

    if update.Phone != nil {
        setFields = append(setFields, fmt.Sprintf("phone = $%d", paramCount))
        params = append(params, update.Phone)
        paramCount++
    }
    if update.Bio != nil {
        setFields = append(setFields, fmt.Sprintf("bio = $%d", paramCount))
        params = append(params, update.Bio)
        paramCount++
    }
    if update.NotificationEmail != nil {
        setFields = append(setFields, fmt.Sprintf("notification_email = $%d", paramCount))
        params = append(params, update.NotificationEmail)
        paramCount++
    }
    if update.NotificationPush != nil {
        setFields = append(setFields, fmt.Sprintf("notification_push = $%d", paramCount))
        params = append(params, update.NotificationPush)
        paramCount++
    }
    if update.Timezone != nil {
        setFields = append(setFields, fmt.Sprintf("timezone = $%d", paramCount))
        params = append(params, update.Timezone)
        paramCount++
    }
    if update.Settings != nil {
        setFields = append(setFields, fmt.Sprintf("settings = $%d", paramCount))
        params = append(params, update.Settings)
        paramCount++
    }

    if len(setFields) == 0 {
        return nil
    }

    params = append(params, userID)

    query := fmt.Sprintf(`
        UPDATE users 
        SET %s, updated_at = CURRENT_TIMESTAMP
        WHERE id = $%d
    `, strings.Join(setFields, ", "), paramCount)

    _, err := s.pool.Exec(ctx, query, params...)
    return err
}

func (s *Storage) UpdateLastSeen(ctx context.Context, userID int) error {
    _, err := s.pool.Exec(ctx, `
        UPDATE users 
        SET last_seen = CURRENT_TIMESTAMP
        WHERE id = $1
    `, userID)
    return err
}
=== /data/proj/hostel-booking-system/backend/internal/proj/users/storage/postgres/storage.go ===

// backend/internal/proj/users/storage/postgres/storage.go
package postgres

import (
    "github.com/jackc/pgx/v5/pgxpool"
    "backend/internal/proj/users/storage"
)

type Storage struct {
    pool *pgxpool.Pool
}

var _ storage.Repository = (*Storage)(nil)

func NewStorage(pool *pgxpool.Pool) *Storage {
    return &Storage{
        pool: pool,
    }
}
=== /data/proj/hostel-booking-system/backend/internal/proj/users/storage/postgres/user.go ===

// backend/internal/proj/users/storage/postgres/user.go
package postgres

import (
    "context"
    "backend/internal/domain/models"
)

func (s *Storage) GetOrCreateGoogleUser(ctx context.Context, user *models.User) (*models.User, error) {
    var userID int
    
    err := s.pool.QueryRow(ctx, `
        SELECT id FROM users WHERE google_id = $1
    `, user.GoogleID).Scan(&userID)

    if err == nil {
        // Пользователь найден, обновляем информацию
        _, err = s.pool.Exec(ctx, `
            UPDATE users 
            SET name = $1, email = $2, picture_url = $3
            WHERE id = $4
        `, user.Name, user.Email, user.PictureURL, userID)
        if err != nil {
            return nil, err
        }
        user.ID = userID
        return user, nil
    }

    // Пользователь не найден, создаём нового
    err = s.pool.QueryRow(ctx, `
        INSERT INTO users (name, email, google_id, picture_url)
        VALUES ($1, $2, $3, $4)
        ON CONFLICT (email) DO UPDATE 
            SET google_id = $3, 
                picture_url = $4,
                name = $1
        RETURNING id
    `, user.Name, user.Email, user.GoogleID, user.PictureURL).Scan(&userID)

    if err != nil {
        return nil, err
    }

    user.ID = userID
    return user, nil
}

func (s *Storage) GetUserByEmail(ctx context.Context, email string) (*models.User, error) {
    user := &models.User{}
    err := s.pool.QueryRow(ctx, `
        SELECT id, name, email, google_id, picture_url, created_at
        FROM users WHERE email = $1
    `, email).Scan(&user.ID, &user.Name, &user.Email, &user.GoogleID, &user.PictureURL, &user.CreatedAt)
    if err != nil {
        return nil, err
    }
    return user, nil
}

func (s *Storage) GetUserByID(ctx context.Context, id int) (*models.User, error) {
    user := &models.User{}
    err := s.pool.QueryRow(ctx, `
        SELECT id, name, email, google_id, picture_url, created_at
        FROM users WHERE id = $1
    `, id).Scan(&user.ID, &user.Name, &user.Email, &user.GoogleID, &user.PictureURL, &user.CreatedAt)
    if err != nil {
        return nil, err
    }
    return user, nil
}

func (s *Storage) CreateUser(ctx context.Context, user *models.User) error {
    return s.pool.QueryRow(ctx, `
        INSERT INTO users (name, email, google_id, picture_url)
        VALUES ($1, $2, $3, $4)
        RETURNING id
    `, user.Name, user.Email, user.GoogleID, user.PictureURL).Scan(&user.ID)
}

func (s *Storage) UpdateUser(ctx context.Context, user *models.User) error {
    _, err := s.pool.Exec(ctx, `
        UPDATE users 
        SET name = $1, email = $2, picture_url = $3
        WHERE id = $4
    `, user.Name, user.Email, user.PictureURL, user.ID)
    return err
}
=== /data/proj/hostel-booking-system/backend/internal/proj/users/handler/auth.go ===

// backend/internal/proj/users/handler/auth.go
package handler

import (
 	"backend/pkg/utils"
    globalService "backend/internal/proj/global/service"
    "backend/internal/proj/users/service" 
	"github.com/gofiber/fiber/v2"
)

type AuthHandler struct {
    services globalService.ServicesInterface
	authService service.AuthServiceInterface
}

func NewAuthHandler(services globalService.ServicesInterface) *AuthHandler {
	return &AuthHandler{
		services:    services,
		authService: services.Auth(),
	}
}

func (h *AuthHandler) GoogleAuth(c *fiber.Ctx) error {
	// Получаем returnTo из query параметров
	returnTo := c.Query("returnTo")
	if returnTo != "" {
		// Сохраняем в cookie
		c.Cookie(&fiber.Cookie{
			Name:     "returnTo",
			Value:    returnTo,
			Path:     "/",
			MaxAge:   300, // 5 минут
			Secure:   true,
			HTTPOnly: true,
		})
	}
	url := h.services.Auth().GetGoogleAuthURL()
	return c.Redirect(url)
}

func (h *AuthHandler) GoogleCallback(c *fiber.Ctx) error {
	code := c.Query("code")

	sessionData, err := h.services.Auth().HandleGoogleCallback(c.Context(), code)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Authentication failed")
	}

	// Генерация токена сессии
	sessionToken := utils.GenerateSessionToken()
	h.services.Auth().SaveSession(sessionToken, sessionData)

	// Установка cookie
	c.Cookie(&fiber.Cookie{
		Name:     "session_token",
		Value:    sessionToken,
		Path:     "/",
		MaxAge:   3600 * 24,
		Secure:   true,
		HTTPOnly: true,
		SameSite: "Lax",
	})
	returnTo := h.services.Config().FrontendURL // значение по умолчанию
	if saved := c.Cookies("returnTo"); saved != "" {
		returnTo = h.services.Config().FrontendURL + saved
		// Удаляем cookie
		c.Cookie(&fiber.Cookie{
			Name:   "returnTo",
			Value:  "",
			Path:   "/",
			MaxAge: -1,
		})
	}

	// Устанавливаем cookie с токеном
	c.Cookie(&fiber.Cookie{
		Name:     "session_token",
		Value:    sessionToken,
		Path:     "/",
		MaxAge:   3600 * 24,
		Secure:   true,
		HTTPOnly: true,
		SameSite: "Lax",
	})

	return c.Redirect(returnTo)
}

func (h *AuthHandler) GetSession(c *fiber.Ctx) error {
	sessionToken := c.Cookies("session_token")
	if sessionToken == "" {
		return c.JSON(fiber.Map{
			"authenticated": false,
		})
	}

	sessionData, ok := h.services.Auth().GetSession(sessionToken)
	if !ok {
		return c.JSON(fiber.Map{
			"authenticated": false,
		})
	}

	return c.JSON(fiber.Map{
		"authenticated": true,
		"user": fiber.Map{
			"id":          sessionData.UserID, // Добавляем ID пользователя
			"name":        sessionData.Name,
			"email":       sessionData.Email,
			"provider":    sessionData.Provider,
			"picture_url": sessionData.PictureURL, // Добавляем URL изображения
		},
	})
}

func (h *AuthHandler) Logout(c *fiber.Ctx) error {
	sessionToken := c.Cookies("session_token")
	if sessionToken != "" {
		h.services.Auth().DeleteSession(sessionToken)
		c.Cookie(&fiber.Cookie{
			Name:     "session_token",
			Value:    "",
			Path:     "/",
			MaxAge:   -1,
			Secure:   true,
			HTTPOnly: true,
			SameSite: "Lax",
		})
	}
	return c.SendStatus(fiber.StatusOK)
}

=== /data/proj/hostel-booking-system/backend/internal/proj/users/handler/users.go ===

// backend/internal/proj/users/handler/users.go
package handler

import (
	"github.com/gofiber/fiber/v2"
	//    "backend/internal/types"
	"backend/internal/domain/models"
    globalService "backend/internal/proj/global/service"
    "backend/internal/proj/users/service" 
	"backend/pkg/utils"
)

type UserHandler struct {
    services globalService.ServicesInterface
	userService service.UserServiceInterface
}

func NewUserHandler(services globalService.ServicesInterface) *UserHandler {
	return &UserHandler{
		services:    services,
		userService: services.User(),
	}
}

func (h *UserHandler) GetProfile(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(int)

	profile, err := h.services.User().GetUserProfile(c.Context(), userID)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Ошибка получения профиля")
	}

	return utils.SuccessResponse(c, profile)
}

func (h *UserHandler) UpdateProfile(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(int)

	var update models.UserProfileUpdate
	if err := c.BodyParser(&update); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Неверный формат данных")
	}

	err := h.services.User().UpdateUserProfile(c.Context(), userID, &update)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Ошибка обновления профиля")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Профиль успешно обновлен",
	})
}

func (h *UserHandler) Register(c *fiber.Ctx) error {
	var registerData struct {
		Name  string `json:"name"`
		Email string `json:"email"`
	}

	if err := c.BodyParser(&registerData); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Неверный формат данных")
	}

	user := &models.User{
		Name:  registerData.Name,
		Email: registerData.Email,
	}

	err := h.services.User().CreateUser(c.Context(), user)
	if err != nil {
		if err.Error() == "email already exists" {
			return utils.ErrorResponse(c, fiber.StatusBadRequest, "Email уже используется")
		}
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Ошибка регистрации пользователя")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Пользователь успешно зарегистрирован",
		"user":    user,
	})
}

=== /data/proj/hostel-booking-system/backend/internal/proj/users/handler/handler.go ===

// backend/internal/proj/users/handler/handler.go
package handler
import (
    globalService "backend/internal/proj/global/service"
)
type Handler struct {
	Auth *AuthHandler
	User *UserHandler
}

func NewHandler(services globalService.ServicesInterface) *Handler {
	return &Handler{
		Auth: NewAuthHandler(services),
		User: NewUserHandler(services),
	}
}

=== /data/proj/hostel-booking-system/backend/internal/proj/reviews/service/review.go ===

// internal/services/review.go

package service

import (
    "context"
    "backend/internal/domain/models"
    "backend/internal/storage"
	"fmt"
)

type ReviewService struct {
    storage storage.Storage
}

func NewReviewService(storage storage.Storage) *ReviewService {
    return &ReviewService{
        storage: storage,
    }
}

// internal/services/review.go

func (s *ReviewService) CreateReview(ctx context.Context, userId int, req *models.CreateReviewRequest) (*models.Review, error) {
    review := &models.Review{
        UserID:     userId,
        EntityType: req.EntityType,
        EntityID:   req.EntityID,
        Rating:     req.Rating,
        Comment:    req.Comment,
        Pros:       req.Pros,
        Cons:       req.Cons,
        Photos:     req.Photos,
        Status:     "published",
    }
    
    // Проверяем, является ли покупка верифицированной
    review.IsVerifiedPurchase = s.checkVerifiedPurchase(ctx, userId, req.EntityType, req.EntityID)
    
    // Исправляем эту строку, чтобы получить оба возвращаемых значения
    createdReview, err := s.storage.CreateReview(ctx, review)
    if err != nil {
        return nil, err
    }
    
    return createdReview, nil
}

func (s *ReviewService) GetReviews(ctx context.Context, filter models.ReviewsFilter) ([]models.Review, int64, error) {
    return s.storage.GetReviews(ctx, filter)
}

func (s *ReviewService) GetReviewByID(ctx context.Context, id int) (*models.Review, error) {
    return s.storage.GetReviewByID(ctx, id)
}

func (s *ReviewService) UpdateReview(ctx context.Context, userId int, reviewId int, review *models.Review) error {
    // Проверяем, принадлежит ли отзыв пользователю
    existingReview, err := s.storage.GetReviewByID(ctx, reviewId)
    if err != nil {
        return err
    }
    
    if existingReview.UserID != userId {
        return fmt.Errorf("unauthorized to update this review")
    }
    
    review.ID = reviewId
    return s.storage.UpdateReview(ctx, review)
}

func (s *ReviewService) DeleteReview(ctx context.Context, userId int, reviewId int) error {
    // Проверяем, принадлежит ли отзыв пользователю
    review, err := s.storage.GetReviewByID(ctx, reviewId)
    if err != nil {
        return err
    }
    
    if review.UserID != userId {
        return fmt.Errorf("unauthorized to delete this review")
    }
    
    return s.storage.DeleteReview(ctx, reviewId)
}

func (s *ReviewService) VoteForReview(ctx context.Context, userId int, reviewId int, voteType string) error {
    vote := &models.ReviewVote{
        ReviewID: reviewId,
        UserID:   userId,
        VoteType: voteType,
    }
    return s.storage.AddReviewVote(ctx, vote)
}

func (s *ReviewService) AddResponse(ctx context.Context, userId int, reviewId int, responseText string) error {
    response := &models.ReviewResponse{
        ReviewID: reviewId,
        UserID:   userId,
        Response: responseText,
    }
    return s.storage.AddReviewResponse(ctx, response)
}

func (s *ReviewService) GetEntityRating(ctx context.Context, entityType string, entityId int) (float64, error) {
    return s.storage.GetEntityRating(ctx, entityType, entityId)
}

// checkVerifiedPurchase проверяет, совершал ли пользователь покупку
func (s *ReviewService) checkVerifiedPurchase(ctx context.Context, userId int, entityType string, entityId int) bool {
    // В зависимости от типа сущности проверяем наличие покупки/бронирования
    switch entityType {
    case "listing":
        // Проверяем покупки в маркетплейсе
        return true // TODO: реализовать проверку
    case "room":
        // Проверяем бронирования комнат
        return true // TODO: реализовать проверку
    case "car":
        // Проверяем аренду автомобилей
        return true // TODO: реализовать проверку
    default:
        return false
    }
}
func (s *ReviewService) GetReviewStats(ctx context.Context, entityType string, entityId int) (*models.ReviewStats, error) {
    stats := &models.ReviewStats{
        RatingDistribution: make(map[int]int),
    }

    // Получаем общую статистику
    err := s.storage.QueryRow(ctx, `
        SELECT 
            COUNT(*) as total,
            COALESCE(AVG(rating), 0) as avg_rating,
            COUNT(*) FILTER (WHERE is_verified_purchase) as verified,
            COUNT(*) FILTER (WHERE array_length(photos, 1) > 0) as with_photos
        FROM reviews
        WHERE entity_type = $1 
        AND entity_id = $2
        AND status = 'published'
    `, entityType, entityId).Scan(
        &stats.TotalReviews,
        &stats.AverageRating,
        &stats.VerifiedReviews,
        &stats.PhotoReviews,
    )
    if err != nil {
        return nil, err
    }

    // Получаем распределение оценок
    rows, err := s.storage.Query(ctx, `
        SELECT rating, COUNT(*)
        FROM reviews
        WHERE entity_type = $1 
        AND entity_id = $2
        AND status = 'published'
        GROUP BY rating
    `, entityType, entityId)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    for rows.Next() {
        var rating, count int
        if err := rows.Scan(&rating, &count); err != nil {
            return nil, err
        }
        stats.RatingDistribution[rating] = count
    }

    return stats, nil
}

func (s *ReviewService) UpdateReviewPhotos(ctx context.Context, reviewId int, photoUrls []string) error {
    // Получаем текущий отзыв
    review, err := s.storage.GetReviewByID(ctx, reviewId)
    if err != nil {
        return err
    }

    // Обновляем массив фотографий
    review.Photos = photoUrls

    // Сохраняем изменения
    return s.storage.UpdateReview(ctx, review)
}

=== /data/proj/hostel-booking-system/backend/internal/proj/reviews/service/interface.go ===

package service

import (
    "context"
    "backend/internal/domain/models"
)

type ReviewServiceInterface interface {
    CreateReview(ctx context.Context, userId int, review *models.CreateReviewRequest) (*models.Review, error)
    GetReviews(ctx context.Context, filter models.ReviewsFilter) ([]models.Review, int64, error)
    GetReviewByID(ctx context.Context, id int) (*models.Review, error)
    UpdateReview(ctx context.Context, userId int, reviewId int, review *models.Review) error
    DeleteReview(ctx context.Context, userId int, reviewId int) error
    VoteForReview(ctx context.Context, userId int, reviewId int, voteType string) error
    AddResponse(ctx context.Context, userId int, reviewId int, response string) error
    GetEntityRating(ctx context.Context, entityType string, entityId int) (float64, error)
    GetReviewStats(ctx context.Context, entityType string, entityId int) (*models.ReviewStats, error)
    UpdateReviewPhotos(ctx context.Context, reviewId int, photoUrls []string) error
}
=== /data/proj/hostel-booking-system/backend/internal/proj/reviews/service/service.go ===

package service

import (
    "backend/internal/storage"
)

type Service struct {
    Review ReviewServiceInterface // Меняем тип на интерфейс
}

func NewService(storage storage.Storage) *Service {
    return &Service{
        Review: NewReviewService(storage),
    }
}
=== /data/proj/hostel-booking-system/backend/internal/proj/reviews/storage/interface.go ===

package storage

import (
    "context"
    "backend/internal/domain/models"
)

type ReviewRepository interface {
    CreateReview(ctx context.Context, review *models.Review) (*models.Review, error)
    GetReviews(ctx context.Context, filter models.ReviewsFilter) ([]models.Review, int64, error)
    GetReviewByID(ctx context.Context, id int) (*models.Review, error)
    UpdateReview(ctx context.Context, review *models.Review) error
    DeleteReview(ctx context.Context, id int) error
    AddReviewResponse(ctx context.Context, response *models.ReviewResponse) error
    AddReviewVote(ctx context.Context, vote *models.ReviewVote) error 
    GetReviewVotes(ctx context.Context, reviewId int) (helpful int, notHelpful int, err error)
    GetUserReviewVote(ctx context.Context, userId int, reviewId int) (string, error)
    GetEntityRating(ctx context.Context, entityType string, entityId int) (float64, error)
    UpdateReviewVotes(ctx context.Context, reviewId int) error
    GetReviewStats(ctx context.Context, entityType string, entityId int) (*models.ReviewStats, error)
}
=== /data/proj/hostel-booking-system/backend/internal/proj/reviews/storage/postgres/storage.go ===

package postgres

import (
    "github.com/jackc/pgx/v5/pgxpool"
)

type Storage struct {
    pool *pgxpool.Pool
}

func NewStorage(pool *pgxpool.Pool) *Storage {
    return &Storage{
        pool: pool,
    }
}
=== /data/proj/hostel-booking-system/backend/internal/proj/reviews/storage/postgres/reviews.go ===

// internal/proj/reviews/storage/postgres/review.go
package postgres

import (
    "backend/internal/domain/models"
    "context"
    "fmt"
    "log"
    "database/sql"
)

func (s *Storage) CreateReview(ctx context.Context, review *models.Review) (*models.Review, error) {
    err := s.pool.QueryRow(ctx, `
        INSERT INTO reviews (
            user_id, entity_type, entity_id, rating, comment, 
            pros, cons, photos, is_verified_purchase, status
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id, created_at, updated_at
    `,
        review.UserID, review.EntityType, review.EntityID, review.Rating,
        review.Comment, review.Pros, review.Cons, review.Photos,
        review.IsVerifiedPurchase, review.Status,
    ).Scan(&review.ID, &review.CreatedAt, &review.UpdatedAt)

    if err != nil {
        return nil, err
    }

    return review, nil
}

func (s *Storage) GetReviews(ctx context.Context, filter models.ReviewsFilter) ([]models.Review, int64, error) {
    userID, ok := ctx.Value("user_id").(int)
    if !ok {
        userID = 0
    }

    query := `
    SELECT 
        r.id, r.user_id, r.entity_type, r.entity_id, r.rating, 
        r.comment, r.pros, r.cons, r.photos, r.likes_count,
        r.is_verified_purchase, r.status, r.created_at, r.updated_at,
        r.helpful_votes, r.not_helpful_votes,
        u.name as user_name, u.email as user_email, u.picture_url as user_picture,
        COUNT(*) OVER() as total_count,
        (
            SELECT vote_type 
            FROM review_votes 
            WHERE review_id = r.id AND user_id = $1
        ) as current_user_vote
    FROM reviews r
    LEFT JOIN users u ON r.user_id = u.id
    WHERE 1=1`

    params := []interface{}{userID}
    paramCount := 2

    // Добавляем условия фильтрации
    if filter.EntityType != "" {
        query += fmt.Sprintf(" AND r.entity_type = $%d", paramCount)
        params = append(params, filter.EntityType)
        paramCount++
    }

    if filter.EntityID != 0 {
        query += fmt.Sprintf(" AND r.entity_id = $%d", paramCount)
        params = append(params, filter.EntityID)
        paramCount++
    }

    if filter.UserID != 0 {
        query += fmt.Sprintf(" AND r.user_id = $%d", paramCount)
        params = append(params, filter.UserID)
        paramCount++
    }

    if filter.MinRating > 0 {
        query += fmt.Sprintf(" AND r.rating >= $%d", paramCount)
        params = append(params, filter.MinRating)
        paramCount++
    }

    if filter.MaxRating > 0 {
        query += fmt.Sprintf(" AND r.rating <= $%d", paramCount)
        params = append(params, filter.MaxRating)
        paramCount++
    }

    if filter.Status != "" {
        query += fmt.Sprintf(" AND r.status = $%d", paramCount)
        params = append(params, filter.Status)
        paramCount++
    }

    // Добавляем сортировку
    switch filter.SortBy {
    case "rating":
        query += " ORDER BY r.rating " + filter.SortOrder
    case "likes":
        query += " ORDER BY r.likes_count " + filter.SortOrder
    default:
        query += " ORDER BY r.created_at " + filter.SortOrder
    }

    // Добавляем пагинацию
    query += fmt.Sprintf(" LIMIT $%d OFFSET $%d", paramCount, paramCount+1)
    params = append(params, filter.Limit, (filter.Page-1)*filter.Limit)

    rows, err := s.pool.Query(ctx, query, params...)
    if err != nil {
        return nil, 0, fmt.Errorf("error executing query: %w", err)
    }
    defer rows.Close()

    var reviews []models.Review
    var totalCount int64

    for rows.Next() {
        var r models.Review
        r.User = &models.User{}
        var currentUserVote sql.NullString
        err := rows.Scan(
            &r.ID, &r.UserID, &r.EntityType, &r.EntityID, &r.Rating,
            &r.Comment, &r.Pros, &r.Cons, &r.Photos, &r.LikesCount,
            &r.IsVerifiedPurchase, &r.Status, &r.CreatedAt, &r.UpdatedAt,
            &r.HelpfulVotes, &r.NotHelpfulVotes,
            &r.User.Name, &r.User.Email, &r.User.PictureURL,
            &totalCount,
            &currentUserVote,
        )
        if err != nil {
            return nil, 0, fmt.Errorf("error scanning row: %w", err)
        }
        if currentUserVote.Valid {
            r.CurrentUserVote = currentUserVote.String
        }
        
        reviews = append(reviews, r)
    }

    return reviews, totalCount, nil
}

func (s *Storage) GetReviewByID(ctx context.Context, id int) (*models.Review, error) {
    review := &models.Review{
        User: &models.User{},
    }

    err := s.pool.QueryRow(ctx, `
        SELECT 
            r.id, r.user_id, r.entity_type, r.entity_id, r.rating, 
            r.comment, r.pros, r.cons, r.photos, r.likes_count,
            r.is_verified_purchase, r.status, r.created_at, r.updated_at,
            u.name as user_name, u.email as user_email, u.picture_url as user_picture
        FROM reviews r
        LEFT JOIN users u ON r.user_id = u.id
        WHERE r.id = $1
    `, id).Scan(
        &review.ID, &review.UserID, &review.EntityType, &review.EntityID, &review.Rating,
        &review.Comment, &review.Pros, &review.Cons, &review.Photos, &review.LikesCount,
        &review.IsVerifiedPurchase, &review.Status, &review.CreatedAt, &review.UpdatedAt,
        &review.User.Name, &review.User.Email, &review.User.PictureURL,
    )

    if err != nil {
        return nil, err
    }

    // Получаем ответы на отзыв
    rows, err := s.pool.Query(ctx, `
        SELECT 
            rr.id, rr.user_id, rr.response, rr.created_at, rr.updated_at,
            u.name, u.email, u.picture_url
        FROM review_responses rr
        LEFT JOIN users u ON rr.user_id = u.id
        WHERE rr.review_id = $1
        ORDER BY rr.created_at
    `, review.ID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    for rows.Next() {
        response := models.ReviewResponse{
            User: &models.User{},
        }
        err := rows.Scan(
            &response.ID, &response.UserID, &response.Response,
            &response.CreatedAt, &response.UpdatedAt,
            &response.User.Name, &response.User.Email, &response.User.PictureURL,
        )
        if err != nil {
            return nil, err
        }
        review.Responses = append(review.Responses, response)
    }

    helpful, notHelpful, err := s.GetReviewVotes(ctx, review.ID)
    if err != nil {
        return nil, err
    }
    review.VotesCount.Helpful = helpful
    review.VotesCount.NotHelpful = notHelpful

    return review, nil
}

func (s *Storage) UpdateReview(ctx context.Context, review *models.Review) error {
    _, err := s.pool.Exec(ctx, `
        UPDATE reviews 
        SET rating = $1, 
            comment = $2, 
            pros = $3, 
            cons = $4, 
            photos = $5, 
            status = $6,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = $7
    `, 
        review.Rating, review.Comment, review.Pros, review.Cons, 
        review.Photos, review.Status, review.ID,
    )
    return err
}

func (s *Storage) DeleteReview(ctx context.Context, id int) error {
    _, err := s.pool.Exec(ctx, `DELETE FROM reviews WHERE id = $1`, id)
    return err
}

func (s *Storage) AddReviewResponse(ctx context.Context, response *models.ReviewResponse) error {
    return s.pool.QueryRow(ctx, `
        INSERT INTO review_responses (review_id, user_id, response)
        VALUES ($1, $2, $3)
        RETURNING id, created_at, updated_at
    `,
        response.ReviewID, response.UserID, response.Response,
    ).Scan(&response.ID, &response.CreatedAt, &response.UpdatedAt)
}

func (s *Storage) AddReviewVote(ctx context.Context, vote *models.ReviewVote) error {
    _, err := s.pool.Exec(ctx, `
        INSERT INTO review_votes (review_id, user_id, vote_type)
        VALUES ($1, $2, $3)
        ON CONFLICT (review_id, user_id) DO UPDATE
        SET vote_type = EXCLUDED.vote_type
    `,
        vote.ReviewID, vote.UserID, vote.VoteType,
    )
    if err != nil {
        return fmt.Errorf("failed to add or update review vote: %w", err)
    }

    // Пересчет голосов
    err = s.UpdateReviewVotes(ctx, vote.ReviewID)
    if err != nil {
        return fmt.Errorf("failed to update review votes for review_id %d: %w", vote.ReviewID, err)
    }

    return nil
}

func (s *Storage) UpdateReviewVotes(ctx context.Context, reviewId int) error {
    _, err := s.pool.Exec(ctx, `
        WITH vote_counts AS (
            SELECT 
                SUM(CASE WHEN vote_type = 'helpful' THEN 1 ELSE 0 END) as helpful_count,
                SUM(CASE WHEN vote_type = 'not_helpful' THEN 1 ELSE 0 END) as not_helpful_count
            FROM review_votes
            WHERE review_id = $1
        )
        UPDATE reviews r
        SET 
            helpful_votes = COALESCE(vote_counts.helpful_count, 0),
            not_helpful_votes = COALESCE(vote_counts.not_helpful_count, 0),
            updated_at = CURRENT_TIMESTAMP
        FROM vote_counts
        WHERE r.id = $1
    `, reviewId)

    if err != nil {
        log.Printf("Failed to update votes for review_id %d: %v", reviewId, err)
        return fmt.Errorf("failed to update votes for review_id %d: %w", reviewId, err)
    }

    return nil
}

func (s *Storage) GetReviewVotes(ctx context.Context, reviewId int) (helpful int, notHelpful int, err error) {
    err = s.pool.QueryRow(ctx, `
        SELECT 
            COUNT(CASE WHEN vote_type = 'helpful' THEN 1 END) as helpful,
            COUNT(CASE WHEN vote_type = 'not_helpful' THEN 1 END) as not_helpful
        FROM review_votes
        WHERE review_id = $1
    `, reviewId).Scan(&helpful, &notHelpful)
    if err != nil {
        return 0, 0, fmt.Errorf("failed to fetch review votes: %w", err)
    }
    return helpful, notHelpful, nil
}

func (s *Storage) GetUserReviewVote(ctx context.Context, userId int, reviewId int) (string, error) {
    var voteType string
    err := s.pool.QueryRow(ctx, `
        SELECT vote_type FROM review_votes
        WHERE user_id = $1 AND review_id = $2
    `, userId, reviewId).Scan(&voteType)
    return voteType, err
}

func (s *Storage) GetEntityRating(ctx context.Context, entityType string, entityId int) (float64, error) {
    var rating float64
    err := s.pool.QueryRow(ctx, `
        SELECT calculate_entity_rating($1, $2)
    `, entityType, entityId).Scan(&rating)
    return rating, err
}

func (s *Storage) GetReviewStats(ctx context.Context, entityType string, entityId int) (*models.ReviewStats, error) {
    stats := &models.ReviewStats{
        RatingDistribution: make(map[int]int),
    }

    err := s.pool.QueryRow(ctx, `
        SELECT 
            COUNT(*) as total,
            COALESCE(AVG(rating), 0) as avg_rating,
            COUNT(*) FILTER (WHERE is_verified_purchase) as verified,
            COUNT(*) FILTER (WHERE array_length(photos, 1) > 0) as with_photos
        FROM reviews
        WHERE entity_type = $1 
        AND entity_id = $2
        AND status = 'published'
    `, entityType, entityId).Scan(
        &stats.TotalReviews,
        &stats.AverageRating,
        &stats.VerifiedReviews,
        &stats.PhotoReviews,
    )
    if err != nil {
        return nil, err
    }

    // Получаем распределение оценок
    rows, err := s.pool.Query(ctx, `
        SELECT rating, COUNT(*)
        FROM reviews
        WHERE entity_type = $1 
        AND entity_id = $2
        AND status = 'published'
        GROUP BY rating
    `, entityType, entityId)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    for rows.Next() {
        var rating, count int
        if err := rows.Scan(&rating, &count); err != nil {
            return nil, err
        }
        stats.RatingDistribution[rating] = count
    }

    return stats, nil
}
=== /data/proj/hostel-booking-system/backend/internal/proj/reviews/handler/handler.go ===

package handler
import (
     globalService "backend/internal/proj/global/service"
)
type Handler struct {
	Review *ReviewHandler
}

func NewHandler(services globalService.ServicesInterface) *Handler {
	
	return &Handler{
		Review: NewReviewHandler(services),
	}
}

=== /data/proj/hostel-booking-system/backend/internal/proj/reviews/handler/reviews.go ===

// internal/handlers/reviews.go

package handler

import (
	"backend/internal/domain/models"
 	"backend/pkg/utils"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"
    "backend/internal/proj/reviews/service"
    globalService "backend/internal/proj/global/service"


	"github.com/gofiber/fiber/v2"
)

type ReviewHandler struct {
    services        globalService.ServicesInterface
	reviewService   service.ReviewServiceInterface
}

func NewReviewHandler(services globalService.ServicesInterface) *ReviewHandler {
	return &ReviewHandler{
		services:      services,
		reviewService: services.Review(),
	}
}

// internal/handlers/reviews.go

func (h *ReviewHandler) CreateReview(c *fiber.Ctx) error {
	userId := c.Locals("user_id").(int)
	var request models.CreateReviewRequest

	if err := c.BodyParser(&request); err != nil {
		log.Printf("Error parsing request body: %v", err)
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid request body")
	}

	log.Printf("Creating review: %+v", request)
	review, err := h.reviewService.CreateReview(c.Context(), userId, &request)
	if err != nil {
		log.Printf("Error creating review: %v", err)
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error creating review")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Review created successfully",
		"id":      review.ID,
	})
}

func (h *ReviewHandler) GetReviews(c *fiber.Ctx) error {
	filter := models.ReviewsFilter{
		EntityType: c.Query("entity_type"),
		EntityID:   utils.StringToInt(c.Query("entity_id"), 0),
		UserID:     utils.StringToInt(c.Query("user_id"), 0),
		MinRating:  utils.StringToInt(c.Query("min_rating"), 0),
		MaxRating:  utils.StringToInt(c.Query("max_rating"), 5),
		Status:     c.Query("status", "published"),
		SortBy:     c.Query("sort_by", "date"),
		SortOrder:  c.Query("sort_order", "desc"),
		Page:       utils.StringToInt(c.Query("page"), 1),
		Limit:      utils.StringToInt(c.Query("limit"), 20),
	}

	reviews, total, err := h.services.Review().GetReviews(c.Context(), filter)
	if err != nil {
		log.Printf("Error getting reviews: %v", err)
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error getting reviews")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"data": reviews,
		"meta": fiber.Map{
			"total": total,
			"page":  filter.Page,
			"limit": filter.Limit,
		},
	})
}

func (h *ReviewHandler) VoteForReview(c *fiber.Ctx) error {
	userId := c.Locals("user_id").(int)
	reviewId, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid review ID")
	}

	var request struct {
		VoteType string `json:"vote_type"`
	}

	if err := c.BodyParser(&request); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid request body")
	}

	err = h.services.Review().VoteForReview(c.Context(), userId, reviewId, request.VoteType)
	if err != nil {
		log.Printf("Error voting for review: %v", err)
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error voting for review")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Vote recorded successfully",
	})
}

func (h *ReviewHandler) AddResponse(c *fiber.Ctx) error {
	userId := c.Locals("user_id").(int)
	reviewId, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid review ID")
	}

	var request struct {
		Response string `json:"response"`
	}

	if err := c.BodyParser(&request); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid request body")
	}

	err = h.services.Review().AddResponse(c.Context(), userId, reviewId, request.Response)
	if err != nil {
		log.Printf("Error adding response: %v", err)
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error adding response")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Response added successfully",
	})
}

// internal/handlers/reviews.go

func (h *ReviewHandler) GetReviewByID(c *fiber.Ctx) error {
	id, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid review ID")
	}

	review, err := h.services.Review().GetReviewByID(c.Context(), id)
	if err != nil {
		log.Printf("Error getting review: %v", err)
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error getting review")
	}

	return utils.SuccessResponse(c, review)
}

func (h *ReviewHandler) UpdateReview(c *fiber.Ctx) error {
	userId := c.Locals("user_id").(int)
	reviewId, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid review ID")
	}

	var review models.Review
	if err := c.BodyParser(&review); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid request body")
	}

	err = h.services.Review().UpdateReview(c.Context(), userId, reviewId, &review)
	if err != nil {
		log.Printf("Error updating review: %v", err)
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error updating review")
	}

	return utils.SuccessResponse(c, fiber.Map{"message": "Review updated successfully"})
}

func (h *ReviewHandler) GetStats(c *fiber.Ctx) error {
	entityType := c.Query("entity_type")
	entityID := utils.StringToInt(c.Query("entity_id"), 0)

	stats, err := h.services.Review().GetReviewStats(c.Context(), entityType, entityID)
	if err != nil {
		log.Printf("Error getting review stats: %v", err)
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error getting review stats")
	}

	return utils.SuccessResponse(c, stats)
}

func (h *ReviewHandler) UploadPhotos(c *fiber.Ctx) error {
	reviewId, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid review ID")
	}

	// Получаем загруженные файлы
	form, err := c.MultipartForm()
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Error parsing form")
	}

	files := form.File["photos"]
	if len(files) == 0 {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "No files uploaded")
	}

	if len(files) > 10 {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Maximum 10 photos allowed")
	}

	photoUrls := make([]string, 0)
	for _, file := range files {
		// Проверка типа файла
		if !strings.HasPrefix(file.Header.Get("Content-Type"), "image/") {
			return utils.ErrorResponse(c, fiber.StatusBadRequest, "Only images are allowed")
		}

		// Генерируем уникальное имя файла
		filename := fmt.Sprintf("review_%d_%d_%s", reviewId, time.Now().UnixNano(), file.Filename)

		// Сохраняем файл
		if err := c.SaveFile(file, "./uploads/"+filename); err != nil {
			log.Printf("Error saving file: %v", err)
			continue
		}

		photoUrls = append(photoUrls, filename)
	}

	// Обновляем отзыв с новыми фотографиями
	err = h.services.Review().UpdateReviewPhotos(c.Context(), reviewId, photoUrls)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error updating review photos")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Photos uploaded successfully",
		"photos":  photoUrls,
	})
}
func (h *ReviewHandler) DeleteReview(c *fiber.Ctx) error {
	userId := c.Locals("user_id").(int)
	reviewId, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Неверный ID отзыва")
	}

	err = h.services.Review().DeleteReview(c.Context(), userId, reviewId)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Ошибка при удалении отзыва")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Отзыв успешно удален",
	})
}

func (h *ReviewHandler) GetEntityRating(c *fiber.Ctx) error {
	entityType := c.Params("type")
	entityId, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Неверный ID сущности")
	}

	rating, err := h.services.Review().GetEntityRating(c.Context(), entityType, entityId)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Ошибка при получении рейтинга")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"rating": rating,
	})
}

func (h *ReviewHandler) GetEntityStats(c *fiber.Ctx) error {
	entityType := c.Params("type")
	entityId, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Неверный ID сущности")
	}

	stats, err := h.services.Review().GetReviewStats(c.Context(), entityType, entityId)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Ошибка при получении статистики")
	}

	return utils.SuccessResponse(c, stats)
}

=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/service/interface.go ===

// backend/internal/proj/marketplace/service/interface.go
package service

import (
    "context"
    "backend/internal/domain/models"
    "mime/multipart"
    
)

type MarketplaceServiceInterface interface {
    CreateListing(ctx context.Context, listing *models.MarketplaceListing) (int, error)
    GetListings(ctx context.Context, filters map[string]string, limit int, offset int) ([]models.MarketplaceListing, int64, error)
    GetListingByID(ctx context.Context, id int) (*models.MarketplaceListing, error)
    UpdateListing(ctx context.Context, listing *models.MarketplaceListing) error
    DeleteListing(ctx context.Context, id int, userID int) error
    ProcessImage(file *multipart.FileHeader) (string, error)
    AddListingImage(ctx context.Context, image *models.MarketplaceImage) (int, error)
    GetCategories(ctx context.Context) ([]models.MarketplaceCategory, error)
    AddToFavorites(ctx context.Context, userID int, listingID int) error
    RemoveFromFavorites(ctx context.Context, userID int, listingID int) error
    GetCategoryTree(ctx context.Context) ([]models.CategoryTreeNode, error)
    GetUserFavorites(ctx context.Context, userID int) ([]models.MarketplaceListing, error)
    
}
=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/service/chat.go ===

// backend/internal/proj/marketplace/service/chat.go
package service

import (
    "context"
    "fmt"
    "backend/internal/domain/models"
    "backend/internal/storage"
    "sync"
)

type ChatService struct {
    storage storage.Storage
    subscribers sync.Map // map[int]chan *models.MarketplaceMessage
}

func NewChatService(storage storage.Storage) *ChatService {
    return &ChatService{
        storage: storage,
    }
}

// Реализация методов для сообщений
func (s *ChatService) SendMessage(ctx context.Context, msg *models.MarketplaceMessage) error {
    // Проверяем, что отправитель имеет доступ к объявлению
    listing, err := s.storage.GetListingByID(ctx, msg.ListingID)
    if err != nil {
        return err
    }

    // Проверяем, что получатель либо владелец объявления, либо отправитель - владелец
    if msg.ReceiverID != listing.UserID && msg.SenderID != listing.UserID {
        return fmt.Errorf("permission denied")
    }

    if err := s.storage.CreateMessage(ctx, msg); err != nil {
        return err
    }

    // Отправляем сообщение через WebSocket
    s.BroadcastMessage(msg)

    return nil
}

func (s *ChatService) GetMessages(ctx context.Context, listingID, userID int, page, limit int) ([]models.MarketplaceMessage, error) {
    if limit == 0 {
        limit = 20
    }
    offset := (page - 1) * limit
    
    return s.storage.GetMessages(ctx, listingID, userID, offset, limit)
}

func (s *ChatService) MarkMessagesAsRead(ctx context.Context, messageIDs []int, userID int) error {
    return s.storage.MarkMessagesAsRead(ctx, messageIDs, userID)
}

// Реализация методов для чатов
func (s *ChatService) GetChats(ctx context.Context, userID int) ([]models.MarketplaceChat, error) {
    return s.storage.GetChats(ctx, userID)
}

func (s *ChatService) GetChat(ctx context.Context, chatID, userID int) (*models.MarketplaceChat, error) {
    return s.storage.GetChat(ctx, chatID, userID)
}

func (s *ChatService) ArchiveChat(ctx context.Context, chatID, userID int) error {
    return s.storage.ArchiveChat(ctx, chatID, userID)
}

// WebSocket методы
func (s *ChatService) BroadcastMessage(msg *models.MarketplaceMessage) {
    // Отправляем сообщение всем подписчикам
    s.subscribers.Range(func(key, value interface{}) bool {
        if ch, ok := value.(chan *models.MarketplaceMessage); ok {
            // Неблокирующая отправка
            select {
            case ch <- msg:
            default:
                // Канал полный или закрыт, пропускаем
            }
        }
        return true
    })
}

func (s *ChatService) SubscribeToMessages(userID int) chan *models.MarketplaceMessage {
    ch := make(chan *models.MarketplaceMessage, 100)
    s.subscribers.Store(userID, ch)
    return ch
}

func (s *ChatService) UnsubscribeFromMessages(userID int) {
    if value, loaded := s.subscribers.LoadAndDelete(userID); loaded {
        if ch, ok := value.(chan *models.MarketplaceMessage); ok {
            close(ch)
        }
    }
}
=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/service/marketplace.go ===

// backend/internal/proj/marketplace/service/marketplace.go
package service

import (
    "backend/internal/domain/models"
    "backend/internal/storage"
    "context"
    "mime/multipart"
    "path/filepath"
    "fmt"
    "time"
)

type MarketplaceService struct {
    storage storage.Storage
}

func NewMarketplaceService(storage storage.Storage) MarketplaceServiceInterface {
    return &MarketplaceService{
        storage: storage,
    }
}
func (s *MarketplaceService) GetUserFavorites(ctx context.Context, userID int) ([]models.MarketplaceListing, error) {
    return s.storage.GetUserFavorites(ctx, userID)
}
func (s *MarketplaceService) CreateListing(ctx context.Context, listing *models.MarketplaceListing) (int, error) {
    // Устанавливаем начальные значения
    listing.Status = "active"
    listing.ViewsCount = 0
    
    return s.storage.CreateListing(ctx, listing)
}

func (s *MarketplaceService) GetListings(ctx context.Context, filters map[string]string, limit int, offset int) ([]models.MarketplaceListing, int64, error) {
    return s.storage.GetListings(ctx, filters, limit, offset)
}

func (s *MarketplaceService) GetListingByID(ctx context.Context, id int) (*models.MarketplaceListing, error) {
    return s.storage.GetListingByID(ctx, id)
}

func (s *MarketplaceService) UpdateListing(ctx context.Context, listing *models.MarketplaceListing) error {
    return s.storage.UpdateListing(ctx, listing)
}
func (s *MarketplaceService) GetCategoryTree(ctx context.Context) ([]models.CategoryTreeNode, error) {
    return s.storage.GetCategoryTree(ctx)
}
func (s *MarketplaceService) DeleteListing(ctx context.Context, id int, userID int) error {
    // Проверяем, что пользователь является владельцем объявления
    listing, err := s.storage.GetListingByID(ctx, id)
    if err != nil {
        return err
    }
    
    if listing.UserID != userID {
        return fmt.Errorf("не хватает прав для удаления объявления")
    }
    
    return s.storage.DeleteListing(ctx, id, userID)
}

func (s *MarketplaceService) ProcessImage(file *multipart.FileHeader) (string, error) {
    ext := filepath.Ext(file.Filename)
    fileName := fmt.Sprintf("%d%s", time.Now().UnixNano(), ext)

    // Используем переменную в возвращаемом значении
    return fileName, nil
}

func (s *MarketplaceService) AddListingImage(ctx context.Context, image *models.MarketplaceImage) (int, error) {
    return s.storage.AddListingImage(ctx, image)
}

func (s *MarketplaceService) GetCategories(ctx context.Context) ([]models.MarketplaceCategory, error) {
    return s.storage.GetCategories(ctx)
}

func (s *MarketplaceService) AddToFavorites(ctx context.Context, userID int, listingID int) error {
    return s.storage.AddToFavorites(ctx, userID, listingID)
}

func (s *MarketplaceService) RemoveFromFavorites(ctx context.Context, userID int, listingID int) error {
    return s.storage.RemoveFromFavorites(ctx, userID, listingID)
}
=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/service/chat_interface.go ===

// backend/internal/proj/marketplace/service/chat_interface.go
package service

import (
    "context"
    "backend/internal/domain/models"
)

type ChatServiceInterface interface {
    // Сообщения
    SendMessage(ctx context.Context, msg *models.MarketplaceMessage) error
    GetMessages(ctx context.Context, listingID, userID int, page, limit int) ([]models.MarketplaceMessage, error)
    MarkMessagesAsRead(ctx context.Context, messageIDs []int, userID int) error
    
    // Чаты
    GetChats(ctx context.Context, userID int) ([]models.MarketplaceChat, error)
    GetChat(ctx context.Context, chatID, userID int) (*models.MarketplaceChat, error)
    ArchiveChat(ctx context.Context, chatID, userID int) error
    
    // WebSocket
    BroadcastMessage(msg *models.MarketplaceMessage)
    SubscribeToMessages(userID int) chan *models.MarketplaceMessage
    UnsubscribeFromMessages(userID int)
}
=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/service/service.go ===

// backend/internal/proj/marketplace/service/service.go
package service

import (
    "backend/internal/storage"
)

type Service struct {
    Marketplace MarketplaceServiceInterface
    Chat       ChatServiceInterface
}

func NewService(storage storage.Storage) *Service {
    return &Service{
        Marketplace: NewMarketplaceService(storage),
        Chat:       NewChatService(storage),
    }
}
=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/storage/interface.go ===

// internal/proj/marketplace/storage/interface.go
package storage

import (
    "context"
    "backend/internal/domain/models"
)

type MarketplaceRepository interface {
    // Listings
    CreateListing(ctx context.Context, listing *models.MarketplaceListing) (int, error)
    GetListings(ctx context.Context, filters map[string]string, limit int, offset int) ([]models.MarketplaceListing, int64, error)
    GetListingByID(ctx context.Context, id int) (*models.MarketplaceListing, error)
    UpdateListing(ctx context.Context, listing *models.MarketplaceListing) error
    DeleteListing(ctx context.Context, id int, userID int) error
    
    // Categories
    GetCategories(ctx context.Context) ([]models.MarketplaceCategory, error)
    GetCategoryByID(ctx context.Context, id int) (*models.MarketplaceCategory, error)
    GetCategoryTree(ctx context.Context) ([]models.CategoryTreeNode, error)
    
    // Images
    AddListingImage(ctx context.Context, image *models.MarketplaceImage) (int, error)
    GetListingImages(ctx context.Context, listingID string) ([]models.MarketplaceImage, error)
    DeleteListingImage(ctx context.Context, imageID string) (string, error)
    
    // Favorites
    AddToFavorites(ctx context.Context, userID int, listingID int) error
    RemoveFromFavorites(ctx context.Context, userID int, listingID int) error
    GetUserFavorites(ctx context.Context, userID int) ([]models.MarketplaceListing, error)
}
=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/storage/postgres/chat.go ===

// backend/internal/proj/marketplace/storage/postgres/chat.go
package postgres

import (
	"backend/internal/domain/models"
	"context"
	"fmt"
    "github.com/jackc/pgx/v5" 
)

// Реализуем методы хранилища
func (s *Storage) GetChat(ctx context.Context, chatID int, userID int) (*models.MarketplaceChat, error) {
	chat := &models.MarketplaceChat{}
	err := s.pool.QueryRow(ctx, `
        SELECT 
            c.id, c.listing_id, c.buyer_id, c.seller_id,
            c.last_message_at, c.created_at, c.updated_at, c.is_archived,
            l.title,
            (
                SELECT COUNT(*)
                FROM marketplace_messages m
                WHERE m.chat_id = c.id AND m.receiver_id = $2 AND NOT m.is_read
            ) as unread_count
        FROM marketplace_chats c
        JOIN marketplace_listings l ON c.listing_id = l.id
        WHERE c.id = $1 AND (c.buyer_id = $2 OR c.seller_id = $2)
    `, chatID, userID).Scan(
		&chat.ID, &chat.ListingID, &chat.BuyerID, &chat.SellerID,
		&chat.LastMessageAt, &chat.CreatedAt, &chat.UpdatedAt, &chat.IsArchived,
		&chat.Listing.Title,
		&chat.UnreadCount,
	)
	if err != nil {
		return nil, fmt.Errorf("error getting chat: %w", err)
	}
	return chat, nil
}

func (s *Storage) GetChats(ctx context.Context, userID int) ([]models.MarketplaceChat, error) {
	rows, err := s.pool.Query(ctx, `
        WITH unread_counts AS (
            SELECT 
                c.id as chat_id,
                COUNT(*) as unread_count
            FROM marketplace_chats c
            JOIN marketplace_messages m ON m.chat_id = c.id
            WHERE m.receiver_id = $1 AND NOT m.is_read
            GROUP BY c.id
        )
        SELECT 
            c.id, c.listing_id, c.buyer_id, c.seller_id,
            c.last_message_at, c.created_at, c.updated_at, c.is_archived,
            l.title,
            COALESCE(uc.unread_count, 0) as unread_count
        FROM marketplace_chats c
        JOIN marketplace_listings l ON c.listing_id = l.id
        LEFT JOIN unread_counts uc ON c.id = uc.chat_id
        WHERE c.buyer_id = $1 OR c.seller_id = $1
        ORDER BY c.last_message_at DESC
    `, userID)
	if err != nil {
		return nil, fmt.Errorf("error querying chats: %w", err)
	}
	defer rows.Close()

	var chats []models.MarketplaceChat
	for rows.Next() {
		var chat models.MarketplaceChat
		chat.Listing = &models.MarketplaceListing{}

		err := rows.Scan(
			&chat.ID, &chat.ListingID, &chat.BuyerID, &chat.SellerID,
			&chat.LastMessageAt, &chat.CreatedAt, &chat.UpdatedAt, &chat.IsArchived,
			&chat.Listing.Title,
			&chat.UnreadCount,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning chat: %w", err)
		}

		chats = append(chats, chat)
	}

	return chats, nil
}


func (s *Storage) GetMessages(ctx context.Context, listingID int, userID int, offset int, limit int) ([]models.MarketplaceMessage, error) {
    messages := []models.MarketplaceMessage{} 

    rows, err := s.pool.Query(ctx, `
        SELECT 
            m.id, m.chat_id, m.listing_id, m.sender_id, m.receiver_id,
            m.content, m.is_read, m.created_at,
            -- Информация об отправителе
            sender.name as sender_name, 
            sender.picture_url as sender_picture,
            -- Информация о получателе
            receiver.name as receiver_name,
            receiver.picture_url as receiver_picture
        FROM marketplace_messages m
        JOIN marketplace_chats c ON m.chat_id = c.id
        JOIN users sender ON m.sender_id = sender.id
        JOIN users receiver ON m.receiver_id = receiver.id
        WHERE m.listing_id = $1 
        AND (c.buyer_id = $2 OR c.seller_id = $2)
        ORDER BY m.created_at DESC
        LIMIT $3 OFFSET $4
    `, listingID, userID, limit, offset)
    if err != nil {
        return messages, fmt.Errorf("error querying messages: %w", err)
    }
    defer rows.Close()

    for rows.Next() {
        var msg models.MarketplaceMessage
        msg.Sender = &models.User{}
        msg.Receiver = &models.User{}
        
        err := rows.Scan(
            &msg.ID, &msg.ChatID, &msg.ListingID, &msg.SenderID, &msg.ReceiverID,
            &msg.Content, &msg.IsRead, &msg.CreatedAt,
            &msg.Sender.Name, &msg.Sender.PictureURL,
            &msg.Receiver.Name, &msg.Receiver.PictureURL,
        )
        if err != nil {
            return messages, fmt.Errorf("error scanning message: %w", err)
        }
        
        messages = append(messages, msg)
    }

    return messages, nil
}

// backend/internal/proj/marketplace/storage/postgres/chat.go

func (s *Storage) CreateMessage(ctx context.Context, msg *models.MarketplaceMessage) error {
    if msg == nil {
        return fmt.Errorf("message cannot be nil")
    }

    // Инициализируем структуры User, если они nil
    if msg.Sender == nil {
        msg.Sender = &models.User{}
    }
    if msg.Receiver == nil {
        msg.Receiver = &models.User{}
    }

    tx, err := s.pool.Begin(ctx)
    if err != nil {
        return fmt.Errorf("error starting transaction: %w", err)
    }
    defer tx.Rollback(ctx)

    // Проверяем тип данных
    if msg.SenderID == 0 || msg.ReceiverID == 0 || msg.ListingID == 0 {
        return fmt.Errorf("invalid message data: sender_id=%d, receiver_id=%d, listing_id=%d", 
            msg.SenderID, msg.ReceiverID, msg.ListingID)
    }

    // Получаем ID продавца и проверяем существование объявления
    var sellerID int
    err = tx.QueryRow(ctx, `
        SELECT user_id 
        FROM marketplace_listings 
        WHERE id = $1
    `, msg.ListingID).Scan(&sellerID)
    if err != nil {
        if err == pgx.ErrNoRows {
            return fmt.Errorf("listing not found: %d", msg.ListingID)
        }
        return fmt.Errorf("error getting listing seller: %w", err)
    }

    // Определяем кто покупатель, а кто продавец
    var buyerID int
    if msg.SenderID == sellerID {
        buyerID = msg.ReceiverID
    } else {
        buyerID = msg.SenderID
    }

    // Создаем или получаем существующий чат
    var chatID int
    err = tx.QueryRow(ctx, `
        WITH user_info AS (
            SELECT id, name, picture_url 
            FROM users 
            WHERE id IN ($1, $2)
        ),
        chat_insert AS (
            INSERT INTO marketplace_chats (
                listing_id, 
                buyer_id, 
                seller_id, 
                last_message_at
            ) VALUES ($3, $4, $5, CURRENT_TIMESTAMP)
            ON CONFLICT (listing_id, buyer_id, seller_id) 
            DO UPDATE SET 
                last_message_at = CURRENT_TIMESTAMP
            RETURNING id
        )
        SELECT 
            ci.id,
            (SELECT name FROM user_info WHERE id = $1) as sender_name,
            (SELECT picture_url FROM user_info WHERE id = $1) as sender_picture,
            (SELECT name FROM user_info WHERE id = $2) as receiver_name,
            (SELECT picture_url FROM user_info WHERE id = $2) as receiver_picture
        FROM chat_insert ci
    `, 
        msg.SenderID, msg.ReceiverID, 
        msg.ListingID, buyerID, sellerID,
    ).Scan(
        &chatID,
        &msg.Sender.Name,
        &msg.Sender.PictureURL,
        &msg.Receiver.Name,
        &msg.Receiver.PictureURL,
    )

    if err != nil {
        return fmt.Errorf("error creating/getting chat: %w", err)
    }

    // Создаем сообщение
    err = tx.QueryRow(ctx, `
        INSERT INTO marketplace_messages (
            chat_id,
            listing_id,
            sender_id,
            receiver_id,
            content,
            is_read
        ) VALUES ($1, $2, $3, $4, $5, false)
        RETURNING id, created_at
    `,
        chatID,
        msg.ListingID,
        msg.SenderID,
        msg.ReceiverID,
        msg.Content,
    ).Scan(&msg.ID, &msg.CreatedAt)

    if err != nil {
        return fmt.Errorf("error creating message: %w", err)
    }

    msg.ChatID = chatID
    return tx.Commit(ctx)
}
func (s *Storage) MarkMessagesAsRead(ctx context.Context, messageIDs []int, userID int) error {
	_, err := s.pool.Exec(ctx, `
        UPDATE marketplace_messages
        SET is_read = true
        WHERE id = ANY($1) AND receiver_id = $2
    `, messageIDs, userID)
	if err != nil {
		return fmt.Errorf("error marking messages as read: %w", err)
	}
	return nil
}

func (s *Storage) ArchiveChat(ctx context.Context, chatID int, userID int) error {
	result, err := s.pool.Exec(ctx, `
        UPDATE marketplace_chats
        SET is_archived = true
        WHERE id = $1 AND (buyer_id = $2 OR seller_id = $2)
    `, chatID, userID)
	if err != nil {
		return fmt.Errorf("error archiving chat: %w", err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("chat not found or permission denied")
	}

	return nil
}

=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/storage/postgres/storage.go ===

// internal/proj/marketplace/storage/postgres/storage.go
package postgres

import (
    "github.com/jackc/pgx/v5/pgxpool"
)

type Storage struct {
    pool *pgxpool.Pool
}

func NewStorage(pool *pgxpool.Pool) *Storage {
    return &Storage{
        pool: pool,
    }
}
=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/storage/postgres/marketplace.go ===

// backend/internal/storage/postgres/marketplace.go
package postgres

import (
	"backend/internal/domain/models"
	"context"
	"encoding/json"
	"fmt"
	"strconv"

	"log"
	"strings"
	"time" // добавляем импорт time
	// "github.com/jackc/pgx/v5"  // добавляем импорт pgx
)

func (s *Storage) CreateListing(ctx context.Context, listing *models.MarketplaceListing) (int, error) {
    var listingID int
    err := s.pool.QueryRow(ctx, `
        INSERT INTO marketplace_listings (
            user_id, category_id, title, description, price,
            condition, status, location, latitude, longitude,
            address_city, address_country, show_on_map
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
        RETURNING id
    `,
        listing.UserID, listing.CategoryID, listing.Title, listing.Description,
        listing.Price, listing.Condition, listing.Status, listing.Location,
        listing.Latitude, listing.Longitude, listing.City, listing.Country, listing.ShowOnMap,
    ).Scan(&listingID)

    return listingID, err
}
func (s *Storage) AddListingImage(ctx context.Context, image *models.MarketplaceImage) (int, error) {
	var imageID int
	err := s.pool.QueryRow(ctx, `
        INSERT INTO marketplace_images (
            listing_id, file_path, file_name, file_size, 
            content_type, is_main
        ) VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id
    `,
		image.ListingID, image.FilePath, image.FileName,
		image.FileSize, image.ContentType, image.IsMain,
	).Scan(&imageID)

	return imageID, err
}

func (s *Storage) GetListingImages(ctx context.Context, listingID string) ([]models.MarketplaceImage, error) {
	// Преобразуем listingID в int, так как принимаем строку
	id, err := strconv.Atoi(listingID)
	if err != nil {
		return nil, fmt.Errorf("invalid listing ID: %w", err)
	}

	query := `
        SELECT 
            id, 
            listing_id,
            file_path,
            file_name,
            file_size,
            content_type,
            is_main,
            created_at
        FROM marketplace_images
        WHERE listing_id = $1
        ORDER BY is_main DESC, created_at DESC
    `

	rows, err := s.pool.Query(ctx, query, id)
	if err != nil {
		return nil, fmt.Errorf("error querying images: %w", err)
	}
	defer rows.Close()

	var images []models.MarketplaceImage
	for rows.Next() {
		var img models.MarketplaceImage
		err := rows.Scan(
			&img.ID,
			&img.ListingID,
			&img.FilePath,
			&img.FileName,
			&img.FileSize,
			&img.ContentType,
			&img.IsMain,
			&img.CreatedAt,
		)
		if err != nil {
			log.Printf("Error scanning image row: %v", err)
			continue
		}
		images = append(images, img)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating over images: %w", err)
	}

	return images, nil
}

func (s *Storage) DeleteListingImage(ctx context.Context, imageID string) (string, error) {
	var filePath string
	err := s.pool.QueryRow(ctx,
		"SELECT file_path FROM marketplace_images WHERE id = $1",
		imageID,
	).Scan(&filePath)
	if err != nil {
		return "", err
	}

	_, err = s.pool.Exec(ctx,
		"DELETE FROM marketplace_images WHERE id = $1",
		imageID,
	)
	if err != nil {
		return "", err
	}

	return filePath, nil
}

func (s *Storage) GetListings(ctx context.Context, filters map[string]string, limit int, offset int) ([]models.MarketplaceListing, int64, error) {
	// Сначала создаем CTE для получения ID всех подкатегорий
	baseQuery := `
        WITH RECURSIVE category_tree AS (
            -- Базовый случай: выбранная категория
            SELECT id, parent_id, name
            FROM marketplace_categories
            WHERE id = COALESCE($1::int, id)
            
            UNION ALL
            
            -- Рекурсивная часть: все дочерние категории
            SELECT c.id, c.parent_id, c.name
            FROM marketplace_categories c
            INNER JOIN category_tree ct ON c.parent_id = ct.id
        ),
        listing_data AS (
            SELECT 
                l.*,
                u.name as user_name, 
                u.email as user_email,
                c.name as category_name, 
                c.slug as category_slug,
                COALESCE(
                    (SELECT json_agg(
                        json_build_object(
                            'id', mi.id,
                            'listing_id', mi.listing_id,
                            'file_path', mi.file_path,
                            'file_name', mi.file_name,
                            'file_size', mi.file_size,
                            'content_type', mi.content_type,
                            'is_main', mi.is_main,
                            'created_at', to_char(mi.created_at, 'YYYY-MM-DD"T"HH24:MI:SS"Z"')
                        )
                    ) 
                    FROM marketplace_images mi 
                    WHERE mi.listing_id = l.id
                    ),
                    '[]'::json
                ) as images
            FROM marketplace_listings l
            JOIN users u ON l.user_id = u.id
            JOIN marketplace_categories c ON l.category_id = c.id
            WHERE 1=1
    `

	var conditions []string
	var args []interface{}
	argCount := 1 // Начинаем с 1 для category_id

	// Добавляем фильтр по категории
	if v := filters["category_id"]; v != "" {
		args = append(args, v)
		conditions = append(conditions, "AND l.category_id IN (SELECT id FROM category_tree)")
	} else {
		args = append(args, nil) // nil для COALESCE в CTE
	}

	// Добавляем условия фильтрации
	if v := filters["min_price"]; v != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("AND l.price >= $%d", argCount))
		args = append(args, v)
	}
	if v := filters["max_price"]; v != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("AND l.price <= $%d", argCount))
		args = append(args, v)
	}
	if v := filters["query"]; v != "" {
		argCount++
		conditions = append(conditions, fmt.Sprintf("AND (LOWER(l.title) LIKE LOWER($%d) OR LOWER(l.description) LIKE LOWER($%d))", argCount, argCount+1))
		args = append(args, "%"+v+"%", "%"+v+"%")
		argCount++
	}

	// Добавляем условия в запрос
	if len(conditions) > 0 {
		baseQuery += " " + strings.Join(conditions, " ")
	}

	// Закрываем CTE и добавляем основной запрос
	baseQuery += `)
        SELECT *, COUNT(*) OVER() as total_count 
        FROM listing_data 
        ORDER BY created_at DESC 
        LIMIT $` + fmt.Sprintf("%d", argCount+1) + ` OFFSET $` + fmt.Sprintf("%d", argCount+2)

	args = append(args, limit, offset)

	// Выполняем запрос
	rows, err := s.pool.Query(ctx, baseQuery, args...)
	if err != nil {
		return nil, 0, fmt.Errorf("error querying listings: %w", err)
	}
	defer rows.Close()

	var listings []models.MarketplaceListing
	var totalCount int64

	for rows.Next() {
		var listing models.MarketplaceListing
		// Инициализируем вложенные структуры
		listing.User = &models.User{}
		listing.Category = &models.MarketplaceCategory{}
		var imagesJSON []byte

		err := rows.Scan(
			&listing.ID, &listing.UserID, &listing.CategoryID, &listing.Title,
			&listing.Description, &listing.Price, &listing.Condition, &listing.Status,
			&listing.Location, &listing.Latitude, &listing.Longitude, &listing.City,
			&listing.Country, &listing.ViewsCount, &listing.CreatedAt, &listing.UpdatedAt, &listing.ShowOnMap,
			&listing.User.Name, &listing.User.Email,
			&listing.Category.Name, &listing.Category.Slug,
			&imagesJSON, &totalCount,
		)
		if err != nil {
			log.Printf("Error scanning row: %v", err)
			return nil, 0, fmt.Errorf("error scanning listing: %w", err)
		}

		if len(imagesJSON) > 0 {
			if err := json.Unmarshal(imagesJSON, &listing.Images); err != nil {
				log.Printf("Error parsing images JSON for listing %d: %v", listing.ID, err)
				log.Printf("Raw JSON: %s", string(imagesJSON))
				listing.Images = []models.MarketplaceImage{}
			} else {
				log.Printf("Successfully parsed %d images for listing %d", len(listing.Images), listing.ID)
			}
		} else {
			listing.Images = []models.MarketplaceImage{}
		}

		listings = append(listings, listing)
	}

	return listings, totalCount, nil
}
func (s *Storage) GetCategoryTree(ctx context.Context) ([]models.CategoryTreeNode, error) {
	query := `
        WITH RECURSIVE category_tree AS (
            -- Корневые категории
            SELECT 
                c.id,
                c.name,
                c.slug,
                c.icon,
                c.parent_id,
                c.created_at,
                0 as level,
                c.name::text as path  -- Добавляем явное приведение типа
            FROM marketplace_categories c
            WHERE parent_id IS NULL

            UNION ALL

            -- Дочерние категории
            SELECT 
                c.id,
                c.name,
                c.slug,
                c.icon,
                c.parent_id,
                c.created_at,
                ct.level + 1,
                (ct.path || ' > ' || c.name)::text -- Добавляем явное приведение типа
            FROM marketplace_categories c
            JOIN category_tree ct ON c.parent_id = ct.id
        )
        SELECT 
            id, name, slug, icon, parent_id, created_at, 
            level, path,
            (SELECT COUNT(*) FROM marketplace_listings WHERE category_id = ct.id) as listing_count
        FROM category_tree ct
        ORDER BY path;
    `

	rows, err := s.pool.Query(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("error querying category tree: %w", err)
	}
	defer rows.Close()

	var categories []models.CategoryTreeNode
	for rows.Next() {
		var cat models.CategoryTreeNode
		err := rows.Scan(
			&cat.ID, &cat.Name, &cat.Slug, &cat.Icon, &cat.ParentID,
			&cat.CreatedAt, &cat.Level, &cat.Path, &cat.ListingCount,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning category: %w", err)
		}
		categories = append(categories, cat)
	}

	return categories, rows.Err()
}
func (s *Storage) AddToFavorites(ctx context.Context, userID int, listingID int) error {
	_, err := s.pool.Exec(ctx, `
        INSERT INTO marketplace_favorites (user_id, listing_id)
        VALUES ($1, $2)
        ON CONFLICT (user_id, listing_id) DO NOTHING
    `, userID, listingID)
	return err
}

func (s *Storage) RemoveFromFavorites(ctx context.Context, userID int, listingID int) error {
	_, err := s.pool.Exec(ctx, `
        DELETE FROM marketplace_favorites
        WHERE user_id = $1 AND listing_id = $2
    `, userID, listingID)
	return err
}

func (s *Storage) GetUserFavorites(ctx context.Context, userID int) ([]models.MarketplaceListing, error) {
    query := `
        SELECT 
            l.id, 
            l.user_id, 
            l.category_id, 
            l.title, 
            l.description,
            l.price, 
            l.condition, 
            l.status, 
            l.location, 
            l.latitude,
            l.longitude, 
            l.address_city, 
            l.address_country, 
            l.views_count,
            l.created_at, 
            l.updated_at,
            u.name, 
            u.email, 
            COALESCE(u.picture_url, ''),
            c.name as category_name, 
            c.slug as category_slug,
            true as is_favorite
        FROM marketplace_listings l
        JOIN marketplace_favorites f ON l.id = f.listing_id
        LEFT JOIN users u ON l.user_id = u.id
        LEFT JOIN marketplace_categories c ON l.category_id = c.id
        WHERE f.user_id = $1
        ORDER BY f.created_at DESC
    `

    rows, err := s.pool.Query(ctx, query, userID)
    if err != nil {
        return nil, fmt.Errorf("error querying favorites: %w", err)
    }
    defer rows.Close()

    var listings []models.MarketplaceListing
    for rows.Next() {
        listing := models.MarketplaceListing{
            User:     &models.User{},
            Category: &models.MarketplaceCategory{},
        }
        var userPictureURL string

        err := rows.Scan(
            &listing.ID,
            &listing.UserID,
            &listing.CategoryID,
            &listing.Title,
            &listing.Description,
            &listing.Price,
            &listing.Condition,
            &listing.Status,
            &listing.Location,
            &listing.Latitude,
            &listing.Longitude,
            &listing.City,
            &listing.Country,
            &listing.ViewsCount,
            &listing.CreatedAt,
            &listing.UpdatedAt,
            &listing.User.Name,
            &listing.User.Email,
            &userPictureURL,
            &listing.Category.Name,
            &listing.Category.Slug,
            &listing.IsFavorite,
        )
        if err != nil {
            log.Printf("Error scanning listing: %v", err)
            continue
        }

        // Присваиваем отдельно
        listing.User.PictureURL = userPictureURL
        listing.User.ID = listing.UserID

        // Получаем изображения для каждого объявления
        images, err := s.GetListingImages(ctx, fmt.Sprintf("%d", listing.ID))
        if err != nil {
            log.Printf("Error getting images for listing %d: %v", listing.ID, err)
            listing.Images = []models.MarketplaceImage{} // Пустой массив вместо nil
        } else {
            listing.Images = images
        }

        listings = append(listings, listing)
    }

    if err = rows.Err(); err != nil {
        return nil, fmt.Errorf("error iterating rows: %w", err)
    }

    return listings, nil
}
func (s *Storage) DeleteListing(ctx context.Context, id int, userID int) error {
	result, err := s.pool.Exec(ctx, `
        DELETE FROM marketplace_listings
        WHERE id = $1 AND user_id = $2
    `, id, userID)

	if err != nil {
		return err
	}

	rowsAffected := result.RowsAffected()
	if rowsAffected == 0 {
		return fmt.Errorf("listing not found or you don't have permission to delete it")
	}

	return nil
}

func (s *Storage) UpdateListing(ctx context.Context, listing *models.MarketplaceListing) error {
	result, err := s.pool.Exec(ctx, `
        UPDATE marketplace_listings
        SET 
            title = $1,
            description = $2,
            price = $3,
            condition = $4,
            status = $5,
            location = $6,
            latitude = $7,
            longitude = $8,
            address_city = $9,
            address_country = $10,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = $11 AND user_id = $12
    `,
		listing.Title,
		listing.Description,
		listing.Price,
		listing.Condition,
		listing.Status,
		listing.Location,
		listing.Latitude,
		listing.Longitude,
		listing.City,
		listing.Country,
        listing.ShowOnMap,
		listing.ID,
		listing.UserID,
	)

	if err != nil {
		return err
	}

	rowsAffected := result.RowsAffected()
	if rowsAffected == 0 {
		return fmt.Errorf("listing not found or you don't have permission to update it")
	}

	return nil
}
func (s *Storage) GetCategories(ctx context.Context) ([]models.MarketplaceCategory, error) {
	rows, err := s.pool.Query(ctx, `
        SELECT 
            id, name, slug, parent_id, icon, created_at
        FROM marketplace_categories
        ORDER BY 
            CASE WHEN parent_id IS NULL THEN 0 ELSE 1 END,
            name
    `)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var categories []models.MarketplaceCategory
	for rows.Next() {
		var cat models.MarketplaceCategory
		err := rows.Scan(
			&cat.ID,
			&cat.Name,
			&cat.Slug,
			&cat.ParentID,
			&cat.Icon,
			&cat.CreatedAt,
		)
		if err != nil {
			continue
		}
		categories = append(categories, cat)
	}

	return categories, rows.Err()
}

func (s *Storage) GetCategoryByID(ctx context.Context, id int) (*models.MarketplaceCategory, error) {
	cat := &models.MarketplaceCategory{}
	err := s.pool.QueryRow(ctx, `
        SELECT 
            id, name, slug, parent_id, icon, created_at
        FROM marketplace_categories
        WHERE id = $1
    `, id).Scan(
		&cat.ID,
		&cat.Name,
		&cat.Slug,
		&cat.ParentID,
		&cat.Icon,
		&cat.CreatedAt,
	)
	if err != nil {
		return nil, err
	}

	return cat, nil
}

func (s *Storage) GetListingByID(ctx context.Context, id int) (*models.MarketplaceListing, error) {
    userID, _ := ctx.Value("user_id").(int)
    
    // Используем COALESCE для NULL значений
    query := `
        SELECT 
            l.id, 
            l.user_id, 
            l.category_id, 
            l.title, 
            l.description,
            l.price, 
            l.condition, 
            l.status, 
            l.location, 
            l.latitude,
            l.longitude, 
            l.address_city, 
            l.address_country, 
            l.views_count,
            l.created_at, 
            l.updated_at,
            l.show_on_map,
            u.name, 
            u.email, 
            COALESCE(u.picture_url, ''),
            c.name as category_name, 
            c.slug as category_slug,
            EXISTS (
                SELECT 1 
                FROM marketplace_favorites mf 
                WHERE mf.listing_id = l.id 
                AND mf.user_id = $2
            ) as is_favorite
        FROM marketplace_listings l
        LEFT JOIN users u ON l.user_id = u.id
        LEFT JOIN marketplace_categories c ON l.category_id = c.id
        WHERE l.id = $1`

    listing := &models.MarketplaceListing{
        User:     &models.User{},
        Category: &models.MarketplaceCategory{},
        ShowOnMap: true,
    }
    

    var userPictureURL string
    err := s.pool.QueryRow(ctx, query, id, userID).Scan(
        &listing.ID,
        &listing.UserID,
        &listing.CategoryID,
        &listing.Title,
        &listing.Description,
        &listing.Price,
        &listing.Condition,
        &listing.Status,
        &listing.Location,
        &listing.Latitude,
        &listing.Longitude,
        &listing.City,
        &listing.Country,
        &listing.ViewsCount,
        &listing.CreatedAt,
        &listing.UpdatedAt,
        &listing.ShowOnMap,
        &listing.User.Name,
        &listing.User.Email,
        &userPictureURL,
        &listing.Category.Name,
        &listing.Category.Slug,
        &listing.IsFavorite,
    )

    if err != nil {
        return nil, fmt.Errorf("error fetching listing: %w", err)
    }

    // Присваиваем picture_url после сканирования
    listing.User.PictureURL = userPictureURL

    // Копируем ID пользователя
    listing.User.ID = listing.UserID

    // Увеличиваем счетчик просмотров в отдельной горутине
    go func() {
        timeoutCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        _, err = s.pool.Exec(timeoutCtx, `
            UPDATE marketplace_listings 
            SET views_count = views_count + 1 
            WHERE id = $1
        `, id)
        if err != nil {
            log.Printf("Error updating views count: %v", err)
        }
    }()

    // Получаем изображения
    images, err := s.GetListingImages(ctx, fmt.Sprintf("%d", id))
    if err != nil {
        log.Printf("Error getting images for listing %d: %v", id, err)
        listing.Images = []models.MarketplaceImage{} // Пустой массив вместо nil
    } else {
        listing.Images = images
    }

    return listing, nil
}
=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/handler/chat.go ===

// backend/internal/proj/marketplace/handler/chat.go

package handler

import (
    "backend/internal/domain/models"
    globalService "backend/internal/proj/global/service"
    "backend/pkg/utils"
    "context"
	"log"
    "encoding/json"
    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/websocket/v2"
)

type ChatHandler struct {
    services globalService.ServicesInterface
}

func NewChatHandler(services globalService.ServicesInterface) *ChatHandler {
    return &ChatHandler{
        services: services,
    }
}

// REST эндпоинты
func (h *ChatHandler) GetChats(c *fiber.Ctx) error {
    userID := c.Locals("user_id").(int)
    
    chats, err := h.services.Chat().GetChats(c.Context(), userID)
    if err != nil {
        return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error fetching chats")
    }
    
    return utils.SuccessResponse(c, chats)
}

func (h *ChatHandler) GetMessages(c *fiber.Ctx) error {
    userID := c.Locals("user_id").(int)
    listingID, err := c.ParamsInt("listing_id")
    if err != nil {
        return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid listing ID")
    }
    
    page := utils.StringToInt(c.Query("page"), 1)
    limit := utils.StringToInt(c.Query("limit"), 20)
    
    messages, err := h.services.Chat().GetMessages(c.Context(), listingID, userID, page, limit)
    if err != nil {
        return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error fetching messages")
    }
    
    return utils.SuccessResponse(c, messages)
}

// backend/internal/proj/marketplace/handler/chat.go

func (h *ChatHandler) SendMessage(c *fiber.Ctx) error {
    userID := c.Locals("user_id").(int)
    
    var req models.CreateMessageRequest
    if err := c.BodyParser(&req); err != nil {
        return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid request body")
    }

    // Валидация входных данных
    if req.ListingID == 0 || req.ReceiverID == 0 || req.Content == "" {
        return utils.ErrorResponse(c, fiber.StatusBadRequest, "Missing required fields")
    }
    
    msg := &models.MarketplaceMessage{
        ListingID:  req.ListingID,
        SenderID:   userID,
        ReceiverID: req.ReceiverID,
        Content:    req.Content,
        Sender:     &models.User{},    // Инициализируем структуры
        Receiver:   &models.User{},
    }
    
    if err := h.services.Chat().SendMessage(c.Context(), msg); err != nil {
        log.Printf("Error sending message: %v", err)
        return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error sending message")
    }
    
    return utils.SuccessResponse(c, msg)
}

func (h *ChatHandler) MarkAsRead(c *fiber.Ctx) error {
    userID := c.Locals("user_id").(int)
    
    var req models.MarkAsReadRequest
    if err := c.BodyParser(&req); err != nil {
        return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid request body")
    }
    
    if err := h.services.Chat().MarkMessagesAsRead(c.Context(), req.MessageIDs, userID); err != nil {
        return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error marking messages as read")
    }
    
    return utils.SuccessResponse(c, fiber.Map{"message": "Messages marked as read"})
}
func (h *ChatHandler) ArchiveChat(c *fiber.Ctx) error {
    userID := c.Locals("user_id").(int)
    chatID, err := c.ParamsInt("chat_id")
    if err != nil {
        return utils.ErrorResponse(c, fiber.StatusBadRequest, "Неверный ID чата")
    }

    err = h.services.Chat().ArchiveChat(c.Context(), chatID, userID)
    if err != nil {
        return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Ошибка при архивировании чата")
    }

    return utils.SuccessResponse(c, fiber.Map{
        "message": "Чат архивирован", 
    })
}
// WebSocket хендлер
func (h *ChatHandler) HandleWebSocket(c *websocket.Conn) {
    if c == nil {
        return // Защита от nil pointer
    }

    userID := c.Locals("user_id").(int)
    
    // Подписываемся на сообщения
    msgChan := h.services.Chat().SubscribeToMessages(userID)
    defer h.services.Chat().UnsubscribeFromMessages(userID)

    // Создаем контекст, который будет отменен при закрытии соединения
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // Горутина для чтения сообщений от клиента
    go func() {
        defer cancel()
        for {
            messageType, message, err := c.ReadMessage()
            if err != nil {
                if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                    log.Printf("error reading message: %v", err)
                }
                return
            }
            
            if messageType == websocket.TextMessage {
                var msg models.MarketplaceMessage
                if err := json.Unmarshal(message, &msg); err != nil {
                    continue
                }
                
                msg.SenderID = userID
                if err := h.services.Chat().SendMessage(ctx, &msg); err != nil {
                    errMsg := fiber.Map{"error": err.Error()}
                    if errBytes, err := json.Marshal(errMsg); err == nil {
                        c.WriteMessage(websocket.TextMessage, errBytes)
                    }
                }
            }
        }
    }()
    
    // Основной цикл для отправки сообщений клиенту
    for {
        select {
        case msg, ok := <-msgChan:
            if !ok {
                return
            }
            // Отправляем только сообщения, относящиеся к этому пользователю
            if msg.SenderID == userID || msg.ReceiverID == userID {
                if data, err := json.Marshal(msg); err == nil {
                    if err := c.WriteMessage(websocket.TextMessage, data); err != nil {
                        return
                    }
                }
            }
        case <-ctx.Done():
            return
        }
    }
}
=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/handler/handler.go ===

package handler
import (
    globalService "backend/internal/proj/global/service"
)

type Handler struct {
    Marketplace *MarketplaceHandler
    Chat       *ChatHandler
}

func NewHandler(services globalService.ServicesInterface) *Handler {
    return &Handler{
        Marketplace: NewMarketplaceHandler(services),
        Chat:       NewChatHandler(services),
    }
}
=== /data/proj/hostel-booking-system/backend/internal/proj/marketplace/handler/marketplace.go ===

// backend/internal/handlers/marketplace.go
package handler

import (
	"backend/internal/domain/models"
     globalService "backend/internal/proj/global/service"

	"backend/pkg/utils"
	"log"
	"strconv"
    "context"
    "backend/internal/proj/marketplace/service"
	"github.com/gofiber/fiber/v2"
)

type MarketplaceHandler struct {
    services            globalService.ServicesInterface
	marketplaceService  service.MarketplaceServiceInterface
}

func NewMarketplaceHandler(services globalService.ServicesInterface) *MarketplaceHandler {
	return &MarketplaceHandler{
		services:           services,
		marketplaceService: services.Marketplace(),
	}
}

func (h *MarketplaceHandler) CreateListing(c *fiber.Ctx) error {
	// Получаем ID пользователя из контекста
	userID, ok := c.Locals("user_id").(int)
	if !ok {
		log.Printf("Failed to get user_id from context: %v", c.Locals("user_id"))
		return utils.ErrorResponse(c, fiber.StatusUnauthorized, "Требуется авторизация")
	}

	var listing models.MarketplaceListing
	if err := c.BodyParser(&listing); err != nil {
		log.Printf("Failed to parse request body: %v", err)
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Некорректные данные")
	}

	// Устанавливаем ID пользователя из контекста
	listing.UserID = userID

	// Валидация обязательных полей
	if listing.Title == "" || listing.Description == "" || listing.Price <= 0 || listing.CategoryID == 0 {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Заполните все обязательные поля")
	}

	// Создаем объявление
	listingID, err := h.marketplaceService.CreateListing(c.Context(), &listing)
	if err != nil {
		log.Printf("Failed to create listing: %v", err)
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Ошибка при создании объявления")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"id":      listingID,
		"message": "Объявление успешно создано",
	})
}
func (h *MarketplaceHandler) GetCategoryTree(c *fiber.Ctx) error {
	categories, err := h.marketplaceService.GetCategoryTree(c.Context())
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error fetching category tree")
	}

	// Строим дерево из плоского списка
	categoryMap := make(map[int]*models.CategoryTreeNode)
	var rootCategories []*models.CategoryTreeNode

	for i := range categories {
		cat := &categories[i]
		categoryMap[cat.ID] = cat

		if cat.ParentID == nil {
			rootCategories = append(rootCategories, cat)
		} else {
			parent := categoryMap[*cat.ParentID]
			if parent != nil {
				parent.Children = append(parent.Children, *cat)
			}
		}
	}

	return utils.SuccessResponse(c, rootCategories)
}
func (h *MarketplaceHandler) UploadImages(c *fiber.Ctx) error {
	log.Printf("Starting image upload for listing ID: %v", c.Params("id"))
	listingID, err := c.ParamsInt("id")
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Некорректный ID объявления")
	}

	// Получаем файлы из формы
	form, err := c.MultipartForm()
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Ошибка при получении файлов")
	}

	files := form.File["images"]
	if len(files) == 0 {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Нет файлов для загрузки")
	}

	if len(files) > 10 {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Максимум 10 фотографий")
	}

	var uploadedImages []models.MarketplaceImage
	mainImageIndex := 0
	if mainIdx := c.FormValue("main_image_index"); mainIdx != "" {
		mainImageIndex, _ = strconv.Atoi(mainIdx)
	}

	for i, file := range files {
		// Обработка файла
		log.Printf("Processing file %d: Name=%s, Size=%d, ContentType=%s", i, file.Filename, file.Size, file.Header.Get("Content-Type"))
		fileName, err := h.marketplaceService.ProcessImage(file)
		if err != nil {
			log.Printf("Failed to process image: %v", err)
			continue
		}

		// Сохраняем информацию о файле
		image := models.MarketplaceImage{
			ListingID:   listingID,
			FilePath:    fileName,
			FileName:    file.Filename,
			FileSize:    int(file.Size),
			ContentType: file.Header.Get("Content-Type"),
			IsMain:      i == mainImageIndex,
		}

		// Сохраняем файл
		err = c.SaveFile(file, "./uploads/"+fileName)
		if err != nil {
			log.Printf("Failed to save file: %v", err)
			continue
		}
		log.Printf("Image saved: %s", image.FilePath)
		// Сохраняем информацию в базу
		imageID, err := h.marketplaceService.AddListingImage(c.Context(), &image)
		if err != nil {
			log.Printf("Failed to save image info: %v", err)
			continue
		}

		image.ID = imageID
		uploadedImages = append(uploadedImages, image)
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Изображения успешно загружены",
		"images":  uploadedImages,
	})
}
func (h *MarketplaceHandler) GetListings(c *fiber.Ctx) error {
	filters := map[string]string{
		"category_id": c.Query("category_id"),
		"city":        c.Query("city"),
		"min_price":   c.Query("min_price"),
		"max_price":   c.Query("max_price"),
		"query":       c.Query("query"),
		"condition":   c.Query("condition"),
		"sort_by":     c.Query("sort_by"),
	}

	page, _ := strconv.Atoi(c.Query("page", "1"))
	limit, _ := strconv.Atoi(c.Query("limit", "20"))
	offset := (page - 1) * limit

	listings, total, err := h.marketplaceService.GetListings(c.Context(), filters, limit, offset)
	if err != nil {
		log.Printf("Error getting listings: %v", err)
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error fetching listings")
	}

	log.Printf("Found %d listings", len(listings))

	// Добавляем информацию о том, добавлено ли объявление в избранное
	// userID, ok := c.Locals("user_id").(int)
	//if ok {
	// TODO: Добавить проверку избранного для авторизованных пользователей
	//}

	return utils.SuccessResponse(c, fiber.Map{
		"data": listings,
		"meta": fiber.Map{
			"total": total,
			"page":  page,
			"limit": limit,
		},
	})
}
func (h *MarketplaceHandler) AddToFavorites(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(int)
	listingID, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid listing ID")
	}

	err = h.marketplaceService.AddToFavorites(c.Context(), userID, listingID)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error adding to favorites")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Added to favorites successfully",
	})
}
func (h *MarketplaceHandler) RemoveFromFavorites(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(int)
	listingID, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid listing ID")
	}

	err = h.marketplaceService.RemoveFromFavorites(c.Context(), userID, listingID)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error removing from favorites")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Removed from favorites successfully",
	})
}

// GetListing - получение объявления по ID
// backend/internal/handlers/marketplace.go

func (h *MarketplaceHandler) GetListing(c *fiber.Ctx) error {
    // Получаем user_id из контекста, если пользователь авторизован
    var userID int
    if uid := c.Locals("user_id"); uid != nil {
        var ok bool
        userID, ok = uid.(int)
        if !ok {
            log.Printf("Invalid user_id type in context: %T", uid)
            userID = 0
        }
    }

    id, err := strconv.Atoi(c.Params("id"))
    if err != nil {
        return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid listing ID")
    }

    log.Printf("GetListing: userID=%d, listingID=%d", userID, id)

    // Создаем контекст с user_id
    ctx := context.WithValue(c.Context(), "user_id", userID)

    listing, err := h.marketplaceService.GetListingByID(ctx, id)
    if err != nil {
        log.Printf("Error getting listing %d: %v", id, err)
        if err.Error() == "listing not found" {
            return utils.ErrorResponse(c, fiber.StatusNotFound, "Listing not found")
        }
        return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error fetching listing")
    }

    // Добавляем логирование для отладки
    log.Printf("GetListing result: listingID=%d, isFavorite=%v, userID=%d", id, listing.IsFavorite, userID)

    return utils.SuccessResponse(c, listing)
}

// UpdateListing - обновление объявления
func (h *MarketplaceHandler) UpdateListing(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(int)
	listingID, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid listing ID")
	}

	var listing models.MarketplaceListing
	if err := c.BodyParser(&listing); err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid input format")
	}

	listing.ID = listingID
	listing.UserID = userID

	err = h.marketplaceService.UpdateListing(c.Context(), &listing)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error updating listing")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Listing updated successfully",
	})
}

// DeleteListing - удаление объявления
func (h *MarketplaceHandler) DeleteListing(c *fiber.Ctx) error {
	userID := c.Locals("user_id").(int)
	listingID, err := strconv.Atoi(c.Params("id"))
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusBadRequest, "Invalid listing ID")
	}

	err = h.marketplaceService.DeleteListing(c.Context(), listingID, userID)
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error deleting listing")
	}

	return utils.SuccessResponse(c, fiber.Map{
		"message": "Listing deleted successfully",
	})
}

// GetCategories - получение списка категорий
func (h *MarketplaceHandler) GetCategories(c *fiber.Ctx) error {
	categories, err := h.marketplaceService.GetCategories(c.Context())
	if err != nil {
		return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Error fetching categories")
	}

	return utils.SuccessResponse(c, categories)
}
func (h *MarketplaceHandler) GetFavorites(c *fiber.Ctx) error {
    userID, ok := c.Locals("user_id").(int)
    if !ok {
        log.Printf("GetFavorites: no user_id in context")
        return utils.ErrorResponse(c, fiber.StatusUnauthorized, "Требуется авторизация")
    }

    log.Printf("GetFavorites: fetching favorites for userID=%d", userID)

    ctx := context.WithValue(c.Context(), "user_id", userID)

    favorites, err := h.marketplaceService.GetUserFavorites(ctx, userID)
    if err != nil {
        log.Printf("GetFavorites error: %v", err)
        return utils.ErrorResponse(c, fiber.StatusInternalServerError, "Ошибка при получении избранных объявлений")
    }

    log.Printf("GetFavorites: found %d favorites for userID=%d", len(favorites), userID)
    return utils.SuccessResponse(c, favorites)
}
=== /data/proj/hostel-booking-system/backend/internal/proj/global/service/interface.go ===

package service

import (
    userService "backend/internal/proj/users/service"
    accommodationService "backend/internal/proj/accommodation/service"
    carService "backend/internal/proj/car/service"
    marketplaceService "backend/internal/proj/marketplace/service"
    reviewService "backend/internal/proj/reviews/service"
    chatService "backend/internal/proj/marketplace/service"
    "backend/internal/config"
)

type ServicesInterface interface {
    Auth() userService.AuthServiceInterface
    Room() accommodationService.RoomServiceInterface
    Bed() accommodationService.BedServiceInterface
    Booking() accommodationService.BookingServiceInterface
    User() userService.UserServiceInterface
    Car() carService.CarServiceInterface
    Config() *config.Config
    Marketplace() marketplaceService.MarketplaceServiceInterface
    Review() reviewService.ReviewServiceInterface
    Chat() chatService.ChatServiceInterface
}
=== /data/proj/hostel-booking-system/backend/internal/proj/global/service/service.go ===

package service

import (
    "backend/internal/config"
    "backend/internal/storage"
    userService "backend/internal/proj/users/service"
    accommodationService "backend/internal/proj/accommodation/service"
    carService "backend/internal/proj/car/service"
    marketplaceService "backend/internal/proj/marketplace/service"
    reviewService "backend/internal/proj/reviews/service"
)

type Service struct {
    users         *userService.Service
    accommodation *accommodationService.Service
    car          *carService.Service
    marketplace  *marketplaceService.Service
    review       *reviewService.Service
    chat         *marketplaceService.Service
    config       *config.Config
}

func NewService(storage storage.Storage, cfg *config.Config) *Service {
    return &Service{
        users:         userService.NewService(storage, cfg.GoogleClientID, cfg.GoogleClientSecret, cfg.GoogleRedirectURL),
        accommodation: accommodationService.NewService(storage),
        car:          carService.NewService(storage),
        marketplace:  marketplaceService.NewService(storage),
        review:       reviewService.NewService(storage),
        chat:         marketplaceService.NewService(storage),
        config:       cfg,
    }
}

// Реализация методов интерфейса
func (s *Service) Auth() userService.AuthServiceInterface {
    return s.users.Auth
}

func (s *Service) User() userService.UserServiceInterface {
    return s.users.User
}

func (s *Service) Car() carService.CarServiceInterface {
    return s.car.Car
}

func (s *Service) Room() accommodationService.RoomServiceInterface {
    return s.accommodation.Room
}

func (s *Service) Booking() accommodationService.BookingServiceInterface {
    return s.accommodation.Booking
}

func (s *Service) Config() *config.Config {
    return s.config
}

func (s *Service) Marketplace() marketplaceService.MarketplaceServiceInterface {
    return s.marketplace.Marketplace
}

func (s *Service) Review() reviewService.ReviewServiceInterface {
    return s.review.Review
}

func (s *Service) Chat() marketplaceService.ChatServiceInterface {
    return s.chat.Chat
}

func (s *Service) Bed() accommodationService.BedServiceInterface {
    return s.accommodation.Bed
}
=== /data/proj/hostel-booking-system/backend/internal/middleware/auth.go ===

package middleware

import (
    "github.com/gofiber/fiber/v2"
    "backend/pkg/utils"
    "log"
)

func (m *Middleware) AuthRequired(c *fiber.Ctx) error {
    sessionToken := c.Cookies("session_token")
    if sessionToken == "" {
        return utils.ErrorResponse(c, fiber.StatusUnauthorized, "Authentication required")
    }

    sessionData, ok := m.services.Auth().GetSession(sessionToken)
    if !ok {
        return utils.ErrorResponse(c, fiber.StatusUnauthorized, "Invalid or expired session")
    }

    log.Printf("AuthRequired: setting userID=%d for session token %s", sessionData.UserID, sessionToken)

    // Устанавливаем user_id в контекст
    c.Locals("user_id", sessionData.UserID)
    c.Locals("user", sessionData)

    return c.Next()
}
=== /data/proj/hostel-booking-system/backend/internal/middleware/cors.go ===

// backend/internal/middleware/cors.go
package middleware

import (
    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/fiber/v2/middleware/cors"
    "strings"
)

func (m *Middleware) CORS() fiber.Handler {
    return cors.New(cors.Config{
        AllowOrigins: strings.Join([]string{
            m.config.FrontendURL,
            "http://localhost:3000",
            "http://localhost:3001",
            "http://landhub.rs",
            "https://landhub.rs",
        }, ","),
        AllowMethods:     "GET,POST,HEAD,PUT,DELETE,PATCH,OPTIONS",
        AllowHeaders:     "Origin, Content-Type, Accept, Authorization, X-Requested-With",
        ExposeHeaders:    "Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type",
        AllowCredentials: true,
        MaxAge:          300, // 5 минут в секундах
    })
}
=== /data/proj/hostel-booking-system/backend/internal/middleware/logger.go ===

package middleware

import (
    "github.com/gofiber/fiber/v2"
    "time"
    "log"
)

func (m *Middleware) Logger() fiber.Handler {
	return func(c *fiber.Ctx) error {
		start := time.Now()
		
		// Продолжаем обработку запроса
		err := c.Next()
		
		// Логируем информацию о запросе
		msg := "%s - %s %s - %d - %v"
		if err != nil {
			msg = "%s - %s %s - %d - %v - Error: %v"
		}

		duration := time.Since(start)
		
		if err != nil {
			log.Printf(msg,
				c.IP(),
				c.Method(),
				c.Path(),
				c.Response().StatusCode(),
				duration,
				err,
			)
		} else {
			log.Printf(msg,
				c.IP(),
				c.Method(),
				c.Path(),
				c.Response().StatusCode(),
				duration,
			)
		}

		return err
	}
}
=== /data/proj/hostel-booking-system/backend/internal/middleware/middleware.go ===

//backend/internal/middleware/middleware.go
package middleware

import (
	"backend/internal/config"


	"github.com/gofiber/fiber/v2"

	globalService "backend/internal/proj/global/service" 
)

type Middleware struct {
	config   *config.Config
    services globalService.ServicesInterface 
}

func NewMiddleware(cfg *config.Config, services globalService.ServicesInterface) *Middleware {
    return &Middleware{
        config:   cfg,
        services: services,
    }
}

func (m *Middleware) Setup(app *fiber.App) {
	app.Use(m.Logger())
	app.Use(m.CORS())
}

// ErrorHandler обрабатывает все ошибки приложения
func (m *Middleware) ErrorHandler(c *fiber.Ctx, err error) error {
	code := fiber.StatusInternalServerError

	if e, ok := err.(*fiber.Error); ok {
		code = e.Code
	}

	return c.Status(code).JSON(fiber.Map{
		"error": err.Error(),
	})
}

=== /data/proj/hostel-booking-system/backend/pkg/logger/logger.go ===

package logger

import (
	"fmt"
	"log"
	"os"
	"time"
)

type Logger struct {
	debug *log.Logger
	info  *log.Logger
	error *log.Logger
}

func New() *Logger {
	flags := log.Ldate | log.Ltime | log.Lmicroseconds | log.Lshortfile

	return &Logger{
		debug: log.New(os.Stdout, "DEBUG: ", flags),
		info:  log.New(os.Stdout, "INFO: ", flags),
		error: log.New(os.Stderr, "ERROR: ", flags),
	}
}

func (l *Logger) Debug(format string, v ...interface{}) {
	l.debug.Output(2, fmt.Sprintf(format, v...))
}

func (l *Logger) Info(format string, v ...interface{}) {
	l.info.Output(2, fmt.Sprintf(format, v...))
}

func (l *Logger) Error(format string, v ...interface{}) {
	l.error.Output(2, fmt.Sprintf(format, v...))
}
=== /data/proj/hostel-booking-system/backend/pkg/utils/utils.go ===

//backend/pkg/utils/utils.go
package utils

import (
	"crypto/rand"
	"encoding/hex"
	"github.com/gofiber/fiber/v2"
	"strconv"
)

func GenerateSessionToken() string {
	b := make([]byte, 32)
	if _, err := rand.Read(b); err != nil {
		return ""
	}
	return hex.EncodeToString(b)
}

func ErrorResponse(c *fiber.Ctx, status int, message string) error {
	return c.Status(status).JSON(fiber.Map{
		"error": message,
	})
}

func SuccessResponse(c *fiber.Ctx, data interface{}) error {
	return c.JSON(fiber.Map{
		"success": true,
		"data":    data,
	})
}
func StringToInt(str string, defaultValue int) int {
    if str == "" {
        return defaultValue
    }
    val, err := strconv.Atoi(str)
    if err != nil {
        return defaultValue
    }
    return val
}
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/maps/MapProvider.js ===

import React, { createContext, useContext, useState, useCallback } from 'react';
import { LoadScript } from '@react-google-maps/api';

const MapContext = createContext(null);
const libraries = ["places", "geometry", "marker"];

export const MapProvider = ({ children }) => {
    const [isLoaded, setIsLoaded] = useState(false);

    const handleLoad = useCallback(() => {
        setIsLoaded(true);
    }, []);

    return (
        <MapContext.Provider value={{ isLoaded }}>
            <LoadScript
                googleMapsApiKey={process.env.REACT_APP_GOOGLE_MAPS_API_KEY}
                libraries={libraries}
                onLoad={handleLoad}
            >
                {children}
            </LoadScript>
        </MapContext.Provider>
    );
};

export const useMap = () => {
    const context = useContext(MapContext);
    if (!context) {
        throw new Error('useMap must be used within a MapProvider');
    }
    return context;
};

export default MapProvider;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/maps/MiniMap.js ===

//frontend/hostel-frontend/src/components/maps/MiniMap.js
import React from 'react';
import { GoogleMap, Marker } from '@react-google-maps/api';
import { Box, IconButton, Typography } from '@mui/material';
import { MapPin, Maximize2 } from 'lucide-react';

const MiniMap = ({ latitude, longitude, title, address, onClick, onExpand }) => {
    const mapContainerStyle = {
        width: '100%',
        height: '200px',
        borderRadius: '4px'
    };

    const center = {
        lat: latitude,
        lng: longitude
    };

    const options = {
        disableDefaultUI: true,
        zoomControl: true,
        clickableIcons: false,
        scrollwheel: false,
        gestureHandling: "greedy"
    };

    return (
        <Box sx={{ position: 'relative' }}>
            <GoogleMap
                mapContainerStyle={mapContainerStyle}
                center={center}
                zoom={14}
                options={options}
                onClick={onClick}
            >
                <Marker position={center} />
            </GoogleMap>

            {onExpand && (
                <IconButton
                    onClick={onExpand}
                    sx={{
                        position: 'absolute',
                        top: 8,
                        right: 8,
                        bgcolor: 'background.paper',
                        '&:hover': {
                            bgcolor: 'background.paper',
                        }
                    }}
                >
                    <Maximize2 size={20} />
                </IconButton>
            )}

            <Box
                sx={{
                    position: 'absolute',
                    bottom: 0,
                    left: 0,
                    right: 0,
                    bgcolor: 'rgba(255, 255, 255, 0.9)',
                    p: 1,
                    display: 'flex',
                    alignItems: 'center',
                    gap: 1
                }}
            >
                <MapPin size={16} />
                <Typography variant="body2" noWrap>
                    {address}
                </Typography>
            </Box>
        </Box>
    );
};

export default MiniMap;

=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/shared/GalleryViewer.js ===

// frontend/hostel-frontend/src/components/shared/GalleryViewer.js
import React, { useState } from 'react';
import {
    Dialog,
    IconButton,
    Box,
    Grid,
    DialogContent,
    Stack,
} from '@mui/material';
import {
    Close as CloseIcon,
    ChevronLeft as ChevronLeftIcon,
    ChevronRight as ChevronRightIcon,
} from '@mui/icons-material';

const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;

const GalleryViewer = ({
    images,
    open: externalOpen,
    onClose: externalClose,
    initialIndex = 0,
    galleryMode = 'thumbnails',
    thumbnailSize = { width: '100%', height: '100px' },
    gridColumns = { xs: 4, sm: 3, md: 2 }
}) => {
    const [selectedIndex, setSelectedIndex] = useState(galleryMode === 'fullscreen' ? initialIndex : null);
    const isOpen = externalOpen !== undefined ? externalOpen : selectedIndex !== null;

    if (!images || images.length === 0) return null;

    const getImageUrl = (image) => {
        if (!image) return '';
        if (typeof image === 'string') return `${BACKEND_URL}/uploads/${image}`;
        if (image.file_path) return `${BACKEND_URL}/uploads/${image.file_path}`;
        return '';
    };

    const handleOpen = (index) => {
        setSelectedIndex(index);
    };

    const handleClose = (e) => {
        e?.stopPropagation();
        setSelectedIndex(null);
        if (externalClose) {
            externalClose();
        }
    };

    const handlePrev = (e) => {
        e?.stopPropagation();
        setSelectedIndex(prev => (prev > 0 ? prev - 1 : images.length - 1));
    };

    const handleNext = (e) => {
        e?.stopPropagation();
        setSelectedIndex(prev => (prev < images.length - 1 ? prev + 1 : 0));
    };

    return (
        <>
            {/* Превью изображений */}
            {galleryMode === 'thumbnails' && (
                <Grid container spacing={1}>
                    {images.map((image, index) => (
                        <Grid item {...gridColumns} key={index}>
                            <Box
                                component="img"
                                src={getImageUrl(image)}
                                alt={`Preview ${index + 1}`}
                                sx={{
                                    width: thumbnailSize.width,
                                    height: thumbnailSize.height,
                                    objectFit: 'cover',
                                    borderRadius: 1,
                                    cursor: 'pointer',
                                    '&:hover': {
                                        opacity: 0.8,
                                        transform: 'scale(1.05)',
                                        transition: 'all 0.2s'
                                    }
                                }}
                                onClick={() => handleOpen(index)}
                            />
                        </Grid>
                    ))}
                </Grid>
            )}

            {/* Полноэкранный просмотр */}
            <Dialog
                open={isOpen}
                onClose={handleClose}
                maxWidth="xl"
                fullWidth
                onClick={handleClose}
                sx={{
                    '.MuiDialog-paper': {
                        m: 0,
                        maxHeight: '100vh',
                        bgcolor: 'black'
                    }
                }}
            >
                <DialogContent
                    sx={{
                        position: 'relative',
                        p: 0,
                        height: '100vh',
                        display: 'flex',
                        flexDirection: 'column',
                        alignItems: 'center',
                        justifyContent: 'space-between'
                    }}
                >
                    {/* Основное изображение */}
                    <Box sx={{
                        flex: 1,
                        width: '100%',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        position: 'relative'
                    }}>
                        <IconButton
                            onClick={handleClose}
                            sx={{
                                position: 'absolute',
                                right: 8,
                                top: 8,
                                color: 'white',
                                zIndex: 1,
                                '&:hover': { bgcolor: 'rgba(255, 255, 255, 0.1)' }
                            }}
                        >
                            <CloseIcon />
                        </IconButton>

                        {images.length > 1 && (
                            <>
                                <IconButton
                                    onClick={handlePrev}
                                    sx={{
                                        position: 'absolute',
                                        left: 8,
                                        color: 'white',
                                        zIndex: 1,
                                        '&:hover': { bgcolor: 'rgba(255, 255, 255, 0.1)' }
                                    }}
                                >
                                    <ChevronLeftIcon />
                                </IconButton>
                                <IconButton
                                    onClick={handleNext}
                                    sx={{
                                        position: 'absolute',
                                        right: 8,
                                        color: 'white',
                                        zIndex: 1,
                                        '&:hover': { bgcolor: 'rgba(255, 255, 255, 0.1)' }
                                    }}
                                >
                                    <ChevronRightIcon />
                                </IconButton>
                            </>
                        )}

                        <Box
                            component="img"
                            src={getImageUrl(images[selectedIndex || 0])}
                            alt={`Image ${(selectedIndex || 0) + 1}`}
                            sx={{
                                maxWidth: '100%',
                                maxHeight: 'calc(100vh - 120px)', // Оставляем место для превью
                                objectFit: 'contain',
                                cursor: 'pointer'
                            }}
                            onClick={(e) => {
                                e.stopPropagation();
                                if (images.length > 1) {
                                    handleNext(e);
                                }
                            }}
                        />
                    </Box>

                    {/* Полоса превью */}
                    {images.length > 1 && (
                        <Stack
                            direction="row"
                            spacing={1}
                            sx={{
                                p: 1,
                                width: '100%',
                                overflowX: 'auto',
                                bgcolor: 'rgba(0, 0, 0, 0.5)',
                                height: 100,
                                alignItems: 'center'
                            }}
                            onClick={(e) => e.stopPropagation()}
                        >
                            {images.map((image, index) => (
                                <Box
                                    key={index}
                                    component="img"
                                    src={getImageUrl(image)}
                                    alt={`Thumbnail ${index + 1}`}
                                    onClick={() => setSelectedIndex(index)}
                                    sx={{
                                        height: 80,
                                        width: 'auto',
                                        cursor: 'pointer',
                                        borderRadius: 1,
                                        opacity: selectedIndex === index ? 1 : 0.6,
                                        transition: 'all 0.2s',
                                        border: selectedIndex === index ? '2px solid white' : 'none',
                                        '&:hover': {
                                            opacity: 1
                                        }
                                    }}
                                />
                            ))}
                        </Stack>
                    )}
                </DialogContent>
            </Dialog>
        </>
    );
};

export default GalleryViewer;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/reviews/index.js ===

//frontend/hostel-frontend/src/components/reviews/index.js
export { ReviewForm, ReviewCard, RatingStats } from './ReviewComponents';
export { default as ReviewsSection } from './ReviewsSection';
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/reviews/ReviewsSection.js ===

// frontend/hostel-frontend/src/components/reviews/ReviewsSection.js
import React, { useState, useEffect } from 'react';
import { Box, Button, Dialog, DialogTitle, DialogContent, Alert, Snackbar } from '@mui/material';
import { PencilLine } from 'lucide-react';
import { ReviewForm, ReviewCard, RatingStats } from './ReviewComponents';
import axios from '../../api/axios';

const ReviewsSection = ({
    entityType,
    entityId,
    entityTitle,
    canReview = true,
    onReviewsCountChange
}) => {
    const [reviews, setReviews] = useState([]);
    const [stats, setStats] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [showReviewForm, setShowReviewForm] = useState(false);
    const [editingReview, setEditingReview] = useState(null);
    const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' });

    // Загрузка отзывов и статистики
    const fetchData = async () => {
        try {
            setLoading(true);
            const [reviewsResponse, statsResponse] = await Promise.all([
                axios.get('/api/v1/reviews', {
                    params: {
                        entity_type: entityType,
                        entity_id: entityId
                    }
                }),
                axios.get(`/api/v1/entity/${entityType}/${entityId}/stats`)
            ]);

            setReviews(reviewsResponse.data.data.data || []);
            setStats(statsResponse.data.data);
        } catch (err) {
            setError('Не удалось загрузить отзывы');
            console.error('Error fetching reviews:', err);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchData();
    }, [entityType, entityId]);

    useEffect(() => {
        if (reviews && onReviewsCountChange) {
            onReviewsCountChange(reviews.length);
        }
    }, [reviews, onReviewsCountChange]);

    const handleReviewSubmit = async ({ reviewData, photosFormData }) => {
        try {
            const response = await axios.post('/api/v1/reviews', reviewData);
            const reviewId = response.data.data.id;

            if (photosFormData && photosFormData.getAll('photos').length > 0) {
                try {
                    await axios.post(`/api/v1/reviews/${reviewId}/photos`, photosFormData, {
                        headers: {
                            'Content-Type': 'multipart/form-data'
                        }
                    });
                } catch (photoErr) {
                    console.error('Error uploading photos:', photoErr);
                    setSnackbar({
                        open: true,
                        message: 'Отзыв создан, но возникла ошибка при загрузке фотографий',
                        severity: 'warning'
                    });
                    return;
                }
            }

            setShowReviewForm(false);
            setEditingReview(null);
            fetchData();
            setSnackbar({
                open: true,
                message: 'Отзыв успешно создан',
                severity: 'success'
            });
        } catch (err) {
            console.error('Error submitting review:', err);
            setSnackbar({
                open: true,
                message: err.response?.data?.error || 'Ошибка при сохранении отзыва',
                severity: 'error'
            });
        }
    };

    const handleVote = async (reviewId, voteType) => {
        const oldReviews = [...reviews];

        setReviews((prevReviews) =>
            prevReviews.map((review) =>
                review.id === reviewId
                    ? {
                        ...review,
                        votes_count: {
                            ...review.votes_count,
                            [voteType]: (review.votes_count?.[voteType] || 0) + 1,
                        },
                        current_user_vote: voteType,
                    }
                    : review
            )
        );

        try {
            await axios.post(`/api/v1/reviews/${reviewId}/vote`, {
                vote_type: voteType,
            });

            setTimeout(() => {
                fetchData();
            }, 1000);
        } catch (err) {
            setReviews(oldReviews);
            setSnackbar({
                open: true,
                message: 'Ошибка при голосовании',
                severity: 'error',
            });
        }
    };

    const handleReply = async (reviewId, response) => {
        try {
            await axios.post(`/api/v1/reviews/${reviewId}/response`, { response });
            fetchData();
            setSnackbar({
                open: true,
                message: 'Ответ успешно добавлен',
                severity: 'success'
            });
        } catch (err) {
            setSnackbar({
                open: true,
                message: 'Ошибка при добавлении ответа',
                severity: 'error'
            });
        }
    };

    const handleDelete = async (reviewId) => {
        try {
            await axios.delete(`/api/v1/reviews/${reviewId}`);
            fetchData();
            setSnackbar({
                open: true,
                message: 'Отзыв успешно удален',
                severity: 'success'
            });
        } catch (err) {
            setSnackbar({
                open: true,
                message: 'Ошибка при удалении отзыва',
                severity: 'error'
            });
        }
    };

    const handleReport = async (reviewId) => {
        try {
            await axios.post(`/api/v1/reviews/${reviewId}/report`);
            setSnackbar({
                open: true,
                message: 'Жалоба отправлена',
                severity: 'success'
            });
        } catch (err) {
            setSnackbar({
                open: true,
                message: 'Ошибка при отправке жалобы',
                severity: 'error'
            });
        }
    };

    return (
        <Box>
            {stats && <RatingStats stats={stats} />}

            {canReview && (
                <Button
                    variant="contained"
                    onClick={() => setShowReviewForm(true)}
                    startIcon={<PencilLine />}
                    sx={{ mb: 3 }}
                >
                    Написать отзыв
                </Button>
            )}

            {Array.isArray(reviews) && reviews.map(review => (
                <ReviewCard
                    key={review.id}
                    review={review}
                    onVote={handleVote}
                    onReply={handleReply}
                    onEdit={(review) => {
                        setEditingReview(review);
                        setShowReviewForm(true);
                    }}
                    onDelete={handleDelete}
                    onReport={handleReport}
                />
            ))}

            <Dialog
                open={showReviewForm}
                onClose={() => {
                    setShowReviewForm(false);
                    setEditingReview(null);
                }}
                maxWidth="md"
                fullWidth
            >
                <DialogTitle>
                    {editingReview ? 'Редактирование отзыва' : 'Новый отзыв'}
                </DialogTitle>
                <DialogContent>
                    <ReviewForm
                        entityType={entityType}
                        entityId={entityId}
                        initialData={editingReview}
                        onSubmit={handleReviewSubmit}
                        onCancel={() => {
                            setShowReviewForm(false);
                            setEditingReview(null);
                        }}
                    />
                </DialogContent>
            </Dialog>

            <Snackbar
                open={snackbar.open}
                autoHideDuration={6000}
                onClose={() => setSnackbar({ ...snackbar, open: false })}
            >
                <Alert
                    onClose={() => setSnackbar({ ...snackbar, open: false })}
                    severity={snackbar.severity}
                    sx={{ width: '100%' }}
                >
                    {snackbar.message}
                </Alert>
            </Snackbar>
        </Box>
    );
};

export default ReviewsSection;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/reviews/ReviewCard.js ===

// src/components/reviews/ReviewCard.js
import React from 'react';
import { Card, CardContent, Typography, Rating } from '@mui/material';

const ReviewCard = ({ review }) => {
    return (
        <Card>
            <CardContent>
                <Rating value={review.rating} readOnly />
                <Typography>{review.comment}</Typography>
            </CardContent>
        </Card>
    );
};

export default ReviewCard;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/reviews/PhotoViewer.js ===

//frontend/hostel-frontend/src/components/reviews/PhotoViewer.js
import React from 'react';
import {
    Dialog,
    IconButton,
    Box,
} from '@mui/material';
import {
    ChevronLeft as ChevronLeftIcon,
    ChevronRight as ChevronRightIcon,
    Close as CloseIcon,
} from '@mui/icons-material';

const PhotoViewer = ({ open, onClose, photos, currentIndex = 0 }) => {
    const [index, setIndex] = React.useState(currentIndex);
    const BACKEND_URL = process.env.REACT_APP_BACKEND_URL;

    const handlePrevious = (e) => {
        e.stopPropagation();
        setIndex((prev) => (prev > 0 ? prev - 1 : photos.length - 1));
    };

    const handleNext = (e) => {
        e.stopPropagation();
        setIndex((prev) => (prev < photos.length - 1 ? prev + 1 : 0));
    };

    return (
        <Dialog
            open={open}
            onClose={onClose}
            maxWidth="xl"
            fullWidth
            onClick={onClose}
        >
            <Box
                sx={{
                    position: 'relative',
                    height: 'calc(100vh - 64px)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    bgcolor: 'black'
                }}
            >
                {/* Кнопка закрытия */}
                <IconButton
                    onClick={onClose}
                    sx={{
                        position: 'absolute',
                        right: 8,
                        top: 8,
                        color: 'white'
                    }}
                >
                    <CloseIcon />
                </IconButton>

                {/* Навигационные кнопки */}
                {photos.length > 1 && (
                    <>
                        <IconButton
                            onClick={handlePrevious}
                            sx={{
                                position: 'absolute',
                                left: 8,
                                color: 'white',
                                '&:hover': { bgcolor: 'rgba(255, 255, 255, 0.1)' }
                            }}
                        >
                            <ChevronLeftIcon fontSize="large" />
                        </IconButton>
                        <IconButton
                            onClick={handleNext}
                            sx={{
                                position: 'absolute',
                                right: 8,
                                color: 'white',
                                '&:hover': { bgcolor: 'rgba(255, 255, 255, 0.1)' }
                            }}
                        >
                            <ChevronRightIcon fontSize="large" />
                        </IconButton>
                    </>
                )}

                {/* Изображение */}
                <Box
                    component="img"
                    src={`${BACKEND_URL}/uploads/${photos[index]}`}
                    alt={`Photo ${index + 1}`}
                    sx={{
                        maxHeight: '100%',
                        maxWidth: '100%',
                        objectFit: 'contain',
                        cursor: 'zoom-out'
                    }}
                    onClick={(e) => {
                        e.stopPropagation();
                        onClose();
                    }}
                />
            </Box>
        </Dialog>
    );
};

export default PhotoViewer;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/marketplace/MobileComponents.js ===

//frontend/hostel-frontend/src/components/marketplace/mobile/MobileComponents.js
import React, { useState } from 'react';
import {
    Box,
    Drawer,
    AppBar,
    Toolbar,
    IconButton,
    Typography,
    Badge,
    InputBase,
    Button,
    Chip,
    Stack,
    Divider,
    alpha,
    Paper
} from '@mui/material';
import {
    Search,
    Sliders, 
    ArrowLeft,
    X,
    Check,
} from 'lucide-react';

// Компактная карточка для мобильной версии
const MobileListingCard = ({ listing }) => {
    return (
        <Box
            component={Paper}
            variant="outlined"
            sx={{
                display: 'flex',
                flexDirection: 'column',
                height: '100%',
                overflow: 'hidden',
                borderRadius: 1,
            }}
        >
            {/* Изображение */}
            <Box
                sx={{
                    position: 'relative',
                    paddingTop: '100%',
                    overflow: 'hidden',
                    backgroundColor: 'grey.100'
                }}
            >
                <img
                    src={`${process.env.REACT_APP_BACKEND_URL}/uploads/${listing.images?.[0]?.file_path}`}
                    alt={listing.title}
                    style={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover'
                    }}
                />
                {listing.images?.length > 1 && (
                    <Chip
                        label={`+${listing.images.length - 1}`}
                        size="small"
                        sx={{
                            position: 'absolute',
                            bottom: 8,
                            right: 8,
                            bgcolor: 'rgba(0,0,0,0.6)',
                            color: 'white',
                            height: 20,
                            '& .MuiChip-label': { px: 1 }
                        }}
                    />
                )}
            </Box>

            {/* Контент */}
            <Box sx={{ p: 1, flexGrow: 1 }}>
                <Typography
                    variant="h6"
                    sx={{
                        fontSize: '0.875rem',
                        fontWeight: 500,
                        mb: 0.5,
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        display: '-webkit-box',
                        WebkitLineClamp: 2,
                        WebkitBoxOrient: 'vertical'
                    }}
                >
                    {listing.title}
                </Typography>

                <Typography
                    variant="subtitle1"
                    sx={{
                        fontSize: '1rem',
                        fontWeight: 600,
                        color: 'primary.main'
                    }}
                >
                    {new Intl.NumberFormat('ru-RU', {
                        style: 'currency',
                        currency: 'RUB',
                        maximumFractionDigits: 0
                    }).format(listing.price)}
                </Typography>

                <Typography
                    variant="caption"
                    color="text.secondary"
                    sx={{
                        display: 'block',
                        mt: 0.5,
                        fontSize: '0.75rem'
                    }}
                >
                    {listing.location}
                </Typography>
            </Box>
        </Box>
    );
};

// Мобильная шапка с поиском
const MobileHeader = ({ onOpenFilters, filtersCount }) => (
    <AppBar 
        position="sticky" 
        color="inherit" 
        elevation={0}
        sx={{ 
            borderBottom: 1,
            borderColor: 'divider'
        }}
    >
        <Toolbar sx={{ gap: 1, minHeight: 56 }}>
            <Box
                sx={{
                    flex: 1,
                    display: 'flex',
                    bgcolor: (theme) => alpha(theme.palette.common.black, 0.05),
                    borderRadius: 1,
                    px: 1,
                }}
            >
                <InputBase
                    placeholder="Поиск объявлений"
                    startAdornment={<Search size={18} style={{ marginRight: 8 }} />}
                    sx={{ flex: 1, fontSize: '0.875rem' }}
                />
            </Box>
            <IconButton 
    onClick={onOpenFilters}
    sx={{ position: 'relative' }}
>
    <Sliders size={20} />
    {filtersCount > 0 && (
        <Box
            sx={{
                position: 'absolute',
                top: 8,
                right: 8,
                width: 8,
                height: 8,
                bgcolor: 'primary.main',
                borderRadius: '50%'
            }}
        />
    )}
</IconButton>
        </Toolbar>
    </AppBar>
);

// Мобильные фильтры
const MobileFilters = ({ open, onClose, filters, onFilterChange, categories }) => {
    const [tempFilters, setTempFilters] = useState(filters);
    
    const handleApply = () => {
        onFilterChange(tempFilters);
        onClose();
    };

    const handleReset = () => {
        setTempFilters({
            query: '',
            category_id: '',
            min_price: '',
            max_price: '',
            condition: '',
            sort_by: 'date_desc'
        });
    };

    return (
        <Drawer
            anchor="right"
            open={open}
            onClose={onClose}
            PaperProps={{
                sx: { width: '100%', maxWidth: 400 }
            }}
        >
            {/* Шапка */}
            <Box sx={{ 
                display: 'flex', 
                alignItems: 'center', 
                px: 2,
                py: 1,
                borderBottom: 1,
                borderColor: 'divider'
            }}>
                <IconButton onClick={onClose} edge="start">
                    <ArrowLeft />
                </IconButton>
                <Typography 
                    variant="subtitle1"
                    sx={{ 
                        flex: 1,
                        ml: 2,
                        fontWeight: 500
                    }}
                >
                    Фильтры
                </Typography>
                <Button 
                    variant="text" 
                    onClick={handleReset}
                    size="small"
                >
                    Сбросить
                </Button>
            </Box>

            {/* Контент */}
            <Box sx={{ 
                flex: 1,
                overflowY: 'auto',
                px: 2,
                py: 2
            }}>
                <Typography variant="subtitle2" gutterBottom>
                    Категории
                </Typography>
                <Stack spacing={1} sx={{ mb: 3 }}>
                    {categories.map(category => (
                        <Button
                            key={category.id}
                            variant={tempFilters.category_id === category.id ? "contained" : "outlined"}
                            size="small"
                            onClick={() => setTempFilters(prev => ({
                                ...prev,
                                category_id: category.id
                            }))}
                            sx={{ 
                                justifyContent: 'flex-start',
                                px: 1.5,
                                py: 0.75
                            }}
                        >
                            {category.name}
                        </Button>
                    ))}
                </Stack>

                <Typography variant="subtitle2" gutterBottom>
                    Цена
                </Typography>
                <Stack direction="row" spacing={1} sx={{ mb: 3 }}>
                    <InputBase
                        placeholder="От"
                        type="number"
                        value={tempFilters.min_price}
                        onChange={(e) => setTempFilters(prev => ({
                            ...prev,
                            min_price: e.target.value
                        }))}
                        sx={{
                            flex: 1,
                            border: 1,
                            borderColor: 'divider',
                            borderRadius: 1,
                            px: 1,
                            py: 0.5
                        }}
                    />
                    <InputBase
                        placeholder="До"
                        type="number"
                        value={tempFilters.max_price}
                        onChange={(e) => setTempFilters(prev => ({
                            ...prev,
                            max_price: e.target.value
                        }))}
                        sx={{
                            flex: 1,
                            border: 1,
                            borderColor: 'divider',
                            borderRadius: 1,
                            px: 1,
                            py: 0.5
                        }}
                    />
                </Stack>

                <Typography variant="subtitle2" gutterBottom>
                    Состояние
                </Typography>
                <Stack direction="row" spacing={1} sx={{ mb: 3 }}>
                    {['new', 'used'].map((condition) => (
                        <Button
                            key={condition}
                            variant={tempFilters.condition === condition ? "contained" : "outlined"}
                            size="small"
                            onClick={() => setTempFilters(prev => ({
                                ...prev,
                                condition: condition
                            }))}
                            sx={{ flex: 1 }}
                        >
                            {condition === 'new' ? 'Новое' : 'Б/у'}
                        </Button>
                    ))}
                </Stack>

                <Typography variant="subtitle2" gutterBottom>
                    Сортировка
                </Typography>
                <Stack spacing={1}>
                    {[
                        { value: 'date_desc', label: 'Сначала новые' },
                        { value: 'price_asc', label: 'Сначала дешевле' },
                        { value: 'price_desc', label: 'Сначала дороже' }
                    ].map((option) => (
                        <Button
                            key={option.value}
                            variant={tempFilters.sort_by === option.value ? "contained" : "outlined"}
                            size="small"
                            onClick={() => setTempFilters(prev => ({
                                ...prev,
                                sort_by: option.value
                            }))}
                            sx={{ 
                                justifyContent: 'flex-start',
                                px: 1.5,
                                py: 0.75
                            }}
                        >
                            {option.label}
                        </Button>
                    ))}
                </Stack>
            </Box>

            {/* Футер */}
            <Box sx={{ 
                p: 2, 
                borderTop: 1,
                borderColor: 'divider'
            }}>
                <Button
                    variant="contained"
                    fullWidth
                    size="large"
                    onClick={handleApply}
                    startIcon={<Check />}
                >
                    Применить
                </Button>
            </Box>
        </Drawer>
    );
};

export { MobileListingCard, MobileHeader, MobileFilters };
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/marketplace/ImprovedCategoryTree.js ===

//frontend/hostel-frontend/src/components/marketplace/ImprovedCategoryTree.js
import React, { useState } from 'react';
import {
  List,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Collapse,
  Typography,
  Box,
  useTheme
} from '@mui/material';
import {
  ChevronRight,
  ChevronDown,
} from 'lucide-react';

const CategoryTreeItem = ({ 
  category, 
  selectedId, 
  onSelect,
  level = 0 
}) => {
  const [isOpen, setIsOpen] = useState(level === 0);
  const theme = useTheme();

  const getTotalListings = (cat) => {
    let total = cat.listing_count || 0;
    if (cat.children) {
      total += cat.children.reduce((sum, child) => sum + getTotalListings(child), 0);
    }
    return total;
  };

  const totalListings = getTotalListings(category);
  const hasChildren = category.children && category.children.length > 0;
  const isSelected = selectedId === category.id;

  return (
    <>
      <ListItemButton
        dense
        onClick={() => {
          if (hasChildren) {
            setIsOpen(!isOpen);
          }
          onSelect(category.id);
        }}
        selected={isSelected}
        sx={{
          pl: level * 2 + 1,
          py: 0.5,
          minHeight: 32,
          color: isSelected ? 'primary.main' : 'text.primary',
          '&:hover': {
            color: 'primary.main',
          },
          '&.Mui-selected': {
            backgroundColor: theme.palette.primary.main + '08',
            '&:hover': {
              backgroundColor: theme.palette.primary.main + '12',
            }
          }
        }}
      >
        <ListItemIcon 
          sx={{ 
            minWidth: 24,
            color: 'inherit'
          }}
        >
          {hasChildren && (
            isOpen ? <ChevronDown size={18} /> : <ChevronRight size={18} />
          )}
        </ListItemIcon>

        <ListItemText
          primary={
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Typography
                variant="body2"
                sx={{
                  fontWeight: isSelected ? 500 : 400,
                  fontSize: '0.875rem',
                }}
              >
                {category.name}
              </Typography>
              {totalListings > 0 && (
                <Typography
                  variant="caption"
                  sx={{
                    ml: 0.5,
                    color: isSelected ? 'primary.main' : 'text.secondary',
                  }}
                >
                  {totalListings}
                </Typography>
              )}
            </Box>
          }
        />
      </ListItemButton>

      {hasChildren && (
        <Collapse in={isOpen} timeout="auto">
          <List component="div" disablePadding>
            {category.children.map((child) => (
              <CategoryTreeItem
                key={child.id}
                category={child}
                selectedId={selectedId}
                onSelect={onSelect}
                level={level + 1}
              />
            ))}
          </List>
        </Collapse>
      )}
    </>
  );
};

const CompactCategoryTree = ({ categories, selectedId, onSelectCategory }) => {
  if (!categories?.length) {
    return (
      <Typography variant="body2" color="text.secondary" sx={{ p: 2 }}>
        Категории не найдены
      </Typography>
    );
  }

  return (
    <List 
      component="nav" 
      disablePadding
      sx={{
        '& .MuiListItemButton-root': {
          borderRadius: 0,
        }
      }}
    >
      {categories.map((category) => (
        <CategoryTreeItem
          key={category.id}
          category={category}
          selectedId={selectedId}
          onSelect={onSelectCategory}
        />
      ))}
    </List>
  );
};

export default CompactCategoryTree;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/marketplace/chat/ChatComponents.js ===

// frontend/hostel-frontend/src/components/marketplace/chat/ChatComponents.js

import React, { useState, useRef, useEffect } from 'react';
import {
    Box,
    Paper,
    Typography,
    Avatar,
    TextField,
    IconButton,
    List,
    ListItem,
    ListItemAvatar,
    ListItemText,
    Badge,
    Stack,
     
    Chip,
    Button,
    useTheme,
    useMediaQuery,
} from '@mui/material';
import {Phone, ArrowLeft } from '@mui/icons-material';
import {
    Send as SendIcon,
    Archive as ArchiveIcon,
} from '@mui/icons-material';
import { formatDistanceToNow } from 'date-fns';
import { ru } from 'date-fns/locale';
export const ChatWindow = ({ messages = [], onSendMessage, currentUser }) => {

    const [newMessage, setNewMessage] = useState('');
    const messagesEndRef = useRef(null);
    const [processedMessages, setProcessedMessages] = useState([]);

    useEffect(() => {
        const uniqueMessages = Object.values(
            messages.reduce((acc, message) => {
                acc[message.id] = message;
                return acc;
            }, {})
        ).sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

        setProcessedMessages(uniqueMessages);
    }, [messages]);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    };

    useEffect(() => {
        scrollToBottom();
    }, [processedMessages]);

    const handleSend = (e) => {
        e.preventDefault();
        if (newMessage.trim()) {
            onSendMessage(newMessage.trim());
            setNewMessage('');
        }
    };

    const formatTime = (dateString) => {
        const date = new Date(dateString);
        return date.toLocaleTimeString('ru-RU', {
            hour: '2-digit',
            minute: '2-digit'
        });
    };

    const formatDate = (dateString) => {
        const date = new Date(dateString);
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);

        if (date.toDateString() === today.toDateString()) {
            return 'Сегодня';
        } else if (date.toDateString() === yesterday.toDateString()) {
            return 'Вчера';
        }
        return date.toLocaleDateString('ru-RU', {
            day: 'numeric',
            month: 'long'
        });
    };

    // Группируем сообщения по датам
    const messagesByDate = processedMessages.reduce((acc, message) => {
        const date = formatDate(message.created_at);
        if (!acc[date]) {
            acc[date] = [];
        }
        acc[date].push(message);
        return acc;
    }, {});

    return (
        <Paper
            elevation={0}
            sx={{
                height: '100%',
                display: 'flex',
                flexDirection: 'column',
                bgcolor: 'grey.50',
                borderRadius: 2,
                overflow: 'hidden'
            }}
        >
            <Box
                sx={{
                    flex: 1,
                    overflowY: 'auto',
                    p: 2,
                    '&::-webkit-scrollbar': {
                        width: '8px',
                    },
                    '&::-webkit-scrollbar-track': {
                        background: 'transparent'
                    },
                    '&::-webkit-scrollbar-thumb': {
                        background: 'rgba(0,0,0,0.1)',
                        borderRadius: '4px',
                    },
                }}
            >
                {Object.entries(messagesByDate).map(([date, dateMessages]) => (
                    <Box key={date}>
                        <Box
                            sx={{
                                display: 'flex',
                                justifyContent: 'center',
                                my: 2,
                            }}
                        >
                            <Typography
                                variant="caption"
                                sx={{
                                    px: 2,
                                    py: 0.5,
                                    bgcolor: 'grey.200',
                                    borderRadius: 5,
                                    color: 'text.secondary'
                                }}
                            >
                                {date}
                            </Typography>
                        </Box>
                        {dateMessages.map((message) => (
                            <Box
                                key={message.id}
                                sx={{
                                    mb: 1,
                                    display: 'flex',
                                    justifyContent: message.sender_id === currentUser.id ? 'flex-end' : 'flex-start',
                                }}
                            >
                                <Box
                                    sx={{
                                        maxWidth: '70%',
                                        bgcolor: message.sender_id === currentUser.id ? 'primary.main' : 'background.paper',
                                        color: message.sender_id === currentUser.id ? 'white' : 'text.primary',
                                        borderRadius: 2,
                                        boxShadow: 1,
                                        p: 1.5,
                                    }}
                                >
                                    <Typography variant="body1" sx={{ mb: 0.5 }}>
                                        {message.content}
                                    </Typography>
                                    <Typography
                                        variant="caption"
                                        sx={{
                                            display: 'block',
                                            textAlign: 'right',
                                            opacity: 0.8
                                        }}
                                    >
                                        {formatTime(message.created_at)}
                                    </Typography>
                                </Box>
                            </Box>
                        ))}
                    </Box>
                ))}
                <div ref={messagesEndRef} />
            </Box>

            <Box
                component="form"
                onSubmit={handleSend}
                sx={{
                    p: 2,
                    bgcolor: 'background.paper',
                    borderTop: 1,
                    borderColor: 'divider',
                }}
            >
                <Stack direction="row" spacing={1}>
                    <TextField
                        fullWidth
                        size="small"
                        placeholder="Введите сообщение..."
                        value={newMessage}
                        onChange={(e) => setNewMessage(e.target.value)}
                        multiline
                        maxRows={4}
                        sx={{
                            '& .MuiOutlinedInput-root': {
                                borderRadius: 2,
                                bgcolor: 'grey.50'
                            }
                        }}
                    />
                    <IconButton
                        color="primary"
                        type="submit"
                        disabled={!newMessage.trim()}
                        sx={{
                            bgcolor: newMessage.trim() ? 'primary.main' : 'grey.200',
                            color: newMessage.trim() ? 'white' : 'grey.400',
                            '&:hover': {
                                bgcolor: newMessage.trim() ? 'primary.dark' : 'grey.300',
                            }
                        }}
                    >
                        <SendIcon />
                    </IconButton>
                </Stack>
            </Box>
        </Paper>
    );
};

// Компонент списка чатов
export const ChatList = ({ chats, selectedChatId, onSelectChat, onArchiveChat }) => {
    const formatPrice = (price) => {
        return new Intl.NumberFormat('ru-RU', {
            style: 'currency',
            currency: 'RUB',
            maximumFractionDigits: 0
        }).format(price);
    };

    return (
        <Paper sx={{
            height: '100%',
            border: 1,
            borderColor: 'divider',
            borderRadius: 2,
            overflow: 'hidden'
        }}>
            <List sx={{ p: 0 }}>
                {chats.map((chat) => (
                    <ListItem
                        key={chat.id}
                        button
                        selected={selectedChatId === chat.id}
                        onClick={() => onSelectChat(chat)}
                        sx={{
                            borderBottom: 1,
                            borderColor: 'divider',
                            '&:last-child': { borderBottom: 0 },
                            '&.Mui-selected': {
                                bgcolor: 'primary.light',
                                '&:hover': {
                                    bgcolor: 'primary.light',
                                }
                            }
                        }}
                    >
                        <Box sx={{ width: '100%' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                                <Avatar
                                    src={chat.listing?.images?.[0]?.file_path}
                                    variant="rounded"
                                    sx={{ width: 48, height: 48, mr: 1.5 }}
                                />
                                <Box sx={{ flex: 1 }}>
                                    <Typography variant="subtitle2" noWrap>
                                        {chat.listing?.title}
                                    </Typography>
                                    <Typography
                                        variant="body2"
                                        color="primary"
                                        sx={{ fontWeight: 'medium' }}
                                    >
                                        {formatPrice(chat.listing?.price)}
                                    </Typography>
                                </Box>
                                {chat.unread_count > 0 && (
                                    <Chip
                                        size="small"
                                        label={chat.unread_count}
                                        color="primary"
                                        sx={{ ml: 1 }}
                                    />
                                )}
                            </Box>

                            <Box sx={{
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'space-between'
                            }}>
                                <Typography
                                    variant="caption"
                                    sx={{
                                        color: 'text.secondary',
                                        display: 'flex',
                                        alignItems: 'center'
                                    }}
                                >
                                    {chat.other_user?.name || 'Пользователь'}
                                </Typography>
                                <Typography variant="caption" color="text.secondary">
                                    {formatDistanceToNow(new Date(chat.last_message_at), {
                                        addSuffix: true,
                                        locale: ru
                                    })}
                                </Typography>
                            </Box>

                            {chat.last_message && (
                                <Typography
                                    variant="body2"
                                    color="text.secondary"
                                    sx={{
                                        mt: 0.5,
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        display: '-webkit-box',
                                        WebkitLineClamp: 1,
                                        WebkitBoxOrient: 'vertical',
                                    }}
                                >
                                    {chat.last_message.content}
                                </Typography>
                            )}
                        </Box>
                    </ListItem>
                ))}
            </List>
        </Paper>
    );
};

// Компонент заголовка чата
export const ChatHeader = ({ chat, onBack, onArchive }) => {
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const formatPrice = (price) => {
        return new Intl.NumberFormat('ru-RU', {
            style: 'currency',
            currency: 'RUB',
            maximumFractionDigits: 0
        }).format(price || 0);
    };

    const formatLastSeen = (date) => {
        if (!date) return 'не в сети';
        const lastSeen = new Date(date);
        const now = new Date();
        const diffMinutes = Math.floor((now - lastSeen) / (1000 * 60));

        if (diffMinutes < 1) return 'в сети';
        if (diffMinutes < 60) return `был(а) ${diffMinutes} мин. назад`;
        if (diffMinutes < 1440) {
            const hours = Math.floor(diffMinutes / 60);
            return `был(а) ${hours} ч. назад`;
        }
        return 'был(а) давно';
    };

    return (
        <Paper
            elevation={1}
            sx={{
                bgcolor: 'background.paper',
                borderBottom: 1,
                borderColor: 'divider',
            }}
        >
            {/* Основная информация */}
            <Box sx={{ p: 2 }}>
                <Stack direction="row" spacing={2} alignItems="center">
                    {/* Кнопка "Назад" для мобильной версии */}
                    {isMobile && (
                        <IconButton onClick={onBack} edge="start" sx={{ mr: 1 }}>
                            <ArrowLeft />
                        </IconButton>
                    )}

                    {/* Изображение товара */}
                    <Avatar
                        variant="rounded"
                        src={chat.listing?.images?.[0]?.file_path}
                        sx={{
                            width: 48,
                            height: 48,
                            borderRadius: 1,
                            border: 1,
                            borderColor: 'divider'
                        }}
                    />

                    {/* Информация о товаре и продавце */}
                    <Box sx={{ flex: 1, minWidth: 0 }}>
                        <Typography variant="subtitle1" noWrap>
                            {chat.listing?.title}
                        </Typography>
                        <Stack direction="row" spacing={2} alignItems="center">
                            <Typography
                                variant="subtitle2"
                                color="primary.main"
                                sx={{ fontWeight: 500 }}
                            >
                                {formatPrice(chat.listing?.price)}
                            </Typography>
                            <Box
                                component="span"
                                sx={{
                                    width: 4,
                                    height: 4,
                                    borderRadius: '50%',
                                    bgcolor: 'grey.400'
                                }}
                            />
                            <Typography variant="body2" color="text.secondary" noWrap>
                                {chat.other_user?.name}
                            </Typography>
                        </Stack>
                    </Box>

                    {/* Действия */}
                    <Stack direction="row" spacing={1}>
                        {/* Кнопка архивации */}
                        <IconButton
                            onClick={() => onArchive?.(chat.id)}
                            sx={{
                                color: 'grey.600',
                                '&:hover': {
                                    color: 'warning.main',
                                    bgcolor: 'warning.lighter'
                                }
                            }}
                        >
                            <ArchiveIcon fontSize="small" />
                        </IconButton>

                        {/* Кнопка звонка */}
                        <IconButton
                            href={`tel:${chat.other_user?.phone}`}
                            sx={{
                                color: 'grey.600',
                                '&:hover': {
                                    color: 'success.main',
                                    bgcolor: 'success.lighter'
                                }
                            }}
                        >
                            <Phone fontSize="small" />
                        </IconButton>

                        {/* Переход к объявлению */}
                        <Button
                            variant="outlined"
                            size="small"
                            onClick={() => window.open(`/marketplace/listings/${chat.listing?.id}`, '_blank')}
                            sx={{
                                minWidth: 'auto',
                                px: 2,
                                borderRadius: 1,
                                display: { xs: 'none', sm: 'inline-flex' }
                            }}
                        >
                            Открыть объявление
                        </Button>
                    </Stack>
                </Stack>
            </Box>
        </Paper>
    );
};

// Компонент пустого состояния
export const EmptyState = ({ text }) => (
    <Box
        sx={{
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            p: 3,
            textAlign: 'center',
        }}
    >
        <Typography variant="h6" color="text.secondary" gutterBottom>
            {text}
        </Typography>
    </Box>
);
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/marketplace/chat/ChatService.js ===

import axios from '../../../api/axios';
class ChatService {
    constructor(userId) {
        this.userId = userId;
        this.ws = null;
        this.messageHandlers = new Set();
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectTimeout = null;
        this.isConnecting = false;
    }

    connect() {
        if (this.ws?.readyState === WebSocket.OPEN || this.isConnecting) {
            return;
        }
    
        this.isConnecting = true;
        clearTimeout(this.reconnectTimer);
    
        try {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            // Используем window.location.host для локальной разработки
            const host = process.env.NODE_ENV === 'development' ? 
                'localhost:3000' : // для разработки
                window.location.host; // для продакшена
    
            const wsUrl = `${protocol}//${host}/ws/chat`;
            console.log('Попытка подключения к WebSocket:', wsUrl);
    
            this.ws = new WebSocket(wsUrl);
    
            this.ws.onopen = () => {
                console.log('WebSocket соединение установлено');
                this.isConnecting = false;
                this.reconnectAttempts = 0;
    
                // После успешного подключения отправляем авторизационные данные
                this.ws.send(JSON.stringify({
                    type: 'auth',
                    user_id: this.userId
                }));
            };
    
            this.ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    this.messageHandlers.forEach(handler => handler(message));
                } catch (error) {
                    console.error('Ошибка обработки сообщения:', error);
                }
            };
    
            this.ws.onerror = (error) => {
                console.error('WebSocket ошибка:', error);
                this.isConnecting = false;
            };
    
            this.ws.onclose = (event) => {
                console.log('WebSocket соединение закрыто:', event.code, event.reason);
                this.isConnecting = false;
                if (event.code !== 1000 && event.code !== 1005) {
                    this.handleReconnect();
                }
            };
    
        } catch (error) {
            console.error('Ошибка при создании WebSocket:', error);
            this.isConnecting = false;
            this.handleReconnect();
        }
    }

    handleReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts || this.isConnecting) {
            return;
        }

        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = setTimeout(() => {
            this.reconnectAttempts++;
            this.connect();
        }, Math.min(1000 * Math.pow(2, this.reconnectAttempts), 10000));
    }

    disconnect() {
        clearTimeout(this.reconnectTimer);
        this.reconnectAttempts = this.maxReconnectAttempts; 
        this.isConnecting = false;

        if (this.ws) {
            try {
                this.ws.close();
            } catch (e) {
                console.error('Ошибка при закрытии WebSocket:', e);
            }
            this.ws = null;
        }
    }

    async sendMessage(message) {
        try {
            // Пробуем отправить через WebSocket
            if (this.ws?.readyState === WebSocket.OPEN) {
                this.ws.send(JSON.stringify({
                    type: 'message',
                    ...message
                }));
                return;
            }

            // Если WebSocket недоступен, отправляем через HTTP
            console.log('WebSocket недоступен, отправка через HTTP');
            const response = await axios.post('/api/v1/marketplace/chat/messages', message);

            // После успешной отправки через HTTP пробуем переподключить WebSocket
            if (this.reconnectAttempts < this.maxReconnectAttempts) {
                this.connect();
            }

            return response.data;

        } catch (error) {
            console.error('Ошибка отправки сообщения:', error);
            throw error;
        }
    }

    onMessage(handler) {
        this.messageHandlers.add(handler);
        return () => this.messageHandlers.delete(handler);
    }

    async getMessageHistory(chatId, listingId) {
        if (!chatId || !listingId) {
            console.error('Отсутствует chatId или listingId:', { chatId, listingId });
            return [];
        }
    
        try {
            // Добавляем retry логику
            let attempts = 3;
            while (attempts > 0) {
                try {
                    const response = await axios.get(`/api/v1/marketplace/chat/${listingId}/messages`);
                    
                    if (response.data?.data) {
                        return response.data.data.sort((a, b) =>
                            new Date(a.created_at) - new Date(b.created_at)
                        );
                    }
                    break;
                } catch (error) {
                    attempts--;
                    if (attempts === 0) throw error;
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            return [];
        } catch (error) {
            console.error('Ошибка получения истории сообщений:', error);
            return [];
        }
    }
    async markMessagesAsRead(messageIds) {
        try {
            await axios.put('/api/v1/marketplace/chat/messages/read', {
                message_ids: messageIds
            });
        } catch (error) {
            console.error('Ошибка отметки сообщений как прочитанных:', error);
        }
    }
}

export default ChatService;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/marketplace/chat/ChatButton.js ===

// frontend/hostel-frontend/src/components/marketplace/chat/ChatButton.js
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../../contexts/AuthContext';
import {
    Button,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    Alert,
} from '@mui/material';
import { MessageCircle } from 'lucide-react';
import axios from '../../../api/axios';

const ChatButton = ({ listing, isMobile }) => {
    const navigate = useNavigate();
    const { user, login } = useAuth();
    const [open, setOpen] = useState(false);
    const [message, setMessage] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const handleClick = () => {
        if (!user) {
            const returnUrl = window.location.pathname;
            const encodedReturnUrl = encodeURIComponent(returnUrl);
            login(`?returnTo=${encodedReturnUrl}`);
            return;
        }

        if (user.id === listing.user_id) {
            navigate('/marketplace/chat');
            return;
        }

        setOpen(true);
    };

    const handleSend = async () => {
        if (!message.trim()) return;
        
        setLoading(true);
        setError('');
    
        try {
            await axios.post('/api/v1/marketplace/chat/messages', {
                listing_id: listing.id,
                receiver_id: listing.user_id,
                content: message.trim()
            }, {
                withCredentials: true  
            });
            
            setOpen(false);
            setMessage('');
            navigate('/marketplace/chat');
        } catch (error) {
            console.error('Error sending message:', error);
            setError(
                error.response?.data?.message || 
                'Не удалось отправить сообщение. Пожалуйста, попробуйте позже.'
            );
        } finally {
            setLoading(false);
        }
    };

    return (
        <>
            <Button
                variant="outlined"
                fullWidth
                startIcon={!isMobile && <MessageCircle />}
                onClick={handleClick}
            >
                {isMobile ? <MessageCircle size={20} /> : 'Написать'}
            </Button>

            <Dialog 
                open={open} 
                onClose={() => !loading && setOpen(false)} 
                maxWidth="sm" 
                fullWidth
            >
                <DialogTitle>Написать продавцу</DialogTitle>
                <DialogContent>
                    {error && (
                        <Alert severity="error" sx={{ mb: 2 }}>
                            {error}
                        </Alert>
                    )}
                    <TextField
                        autoFocus
                        fullWidth
                        multiline
                        rows={4}
                        placeholder="Введите сообщение..."
                        value={message}
                        onChange={(e) => setMessage(e.target.value)}
                        sx={{ mt: 2 }}
                        disabled={loading}
                    />
                </DialogContent>
                <DialogActions>
                    <Button 
                        onClick={() => setOpen(false)}
                        disabled={loading}
                    >
                        Отмена
                    </Button>
                    <Button
                        variant="contained"
                        onClick={handleSend}
                        disabled={!message.trim() || loading}
                    >
                        {loading ? 'Отправка...' : 'Отправить'}
                    </Button>
                </DialogActions>
            </Dialog>
        </>
    );
};

export default ChatButton;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/marketplace/ListingCard.js ===

// src/components/marketplace/ListingCard.js
import React from 'react';
import {
    Card,
    CardContent,
    CardMedia,
    Typography,
    Box,
    Chip,
    Button,
    Rating,
    Stack
} from '@mui/material';
import { Star } from 'lucide-react';
import { MapPin as LocationIcon, Clock as AccessTime, Camera } from 'lucide-react';

const BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:3000';

const ListingCard = ({ listing, isMobile }) => {
    const formatPrice = (price) => {
        return new Intl.NumberFormat('ru-RU', {
            style: 'currency',
            currency: 'RUB',
            maximumFractionDigits: 0
        }).format(price || 0);
    };

    const formatDate = (dateString) => {
        if (!dateString) return '';
        return new Date(dateString).toLocaleDateString('ru-RU', {
            day: 'numeric',
            month: 'long',
            year: 'numeric'
        });
    };

    const getMainImageUrl = () => {
        if (!listing.images || listing.images.length === 0) {
            return '/placeholder.jpg';
        }
        
        const mainImage = listing.images.find(img => img.is_main) || listing.images[0];
        if (!mainImage || !mainImage.file_path) {
            return '/placeholder.jpg';
        }
        
        return `${BACKEND_URL}/uploads/${mainImage.file_path}`;
    };

    return (
        <Card sx={{
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            '&:hover': {
                transform: 'translateY(-4px)',
                boxShadow: 3,
                transition: 'all 0.2s ease-in-out'
            }
        }}>
            <Box sx={{ position: 'relative', pt: isMobile ? '100%' : '75%' }}>
                <CardMedia
                    component="img"
                    sx={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover'
                    }}
                    image={getMainImageUrl()}
                    alt={listing.title || 'Изображение отсутствует'}
                />
                {listing.images && listing.images.length > 1 && !isMobile && (
                    <Chip
                        icon={<Camera size={16} />}
                        label={`${listing.images.length} фото`}
                        size="small"
                        sx={{
                            position: 'absolute',
                            bottom: 8,
                            right: 8,
                            bgcolor: 'rgba(0,0,0,0.6)',
                            color: 'white'
                        }}
                    />
                )}
            </Box>

            <CardContent sx={{ 
                flexGrow: 1, 
                p: isMobile ? 1 : 2,
                '&:last-child': { pb: isMobile ? 1 : 2 }
            }}>
                <Typography 
                    variant={isMobile ? "body2" : "h6"} 
                    noWrap
                    sx={{ 
                        fontSize: isMobile ? '0.875rem' : undefined,
                        fontWeight: 'medium'
                    }}
                >
                    {listing.title || 'Без названия'}
                </Typography>

                {/*  рейтинг */}
                {listing.rating > 0 && (
                    <Stack direction="row" spacing={0.5} alignItems="center" sx={{ mt: 1 }}>
                        <Rating 
                            value={listing.rating} 
                            readOnly 
                            size="small" 
                            precision={0.1}
                        />
                        <Typography 
                            variant="body2" 
                            color="text.secondary"
                        >
                            ({listing.reviews_count})
                        </Typography>
                    </Stack>
                )}

                <Typography 
                    variant={isMobile ? "body2" : "h5"} 
                    color="primary" 
                    sx={{ 
                        mt: 0.5,
                        fontSize: isMobile ? '0.875rem' : undefined,
                        fontWeight: 'bold'
                    }}
                >
                    {formatPrice(listing.price)}
                </Typography>

                {!isMobile && (
                    <>
                        <Box sx={{ mt: 1, display: 'flex', alignItems: 'center', color: 'text.secondary' }}>
                            <LocationIcon size={18} style={{ marginRight: 4 }} />
                            <Typography variant="body2" noWrap>
                                {listing.city || 'Местоположение не указано'}
                            </Typography>
                        </Box>

                        <Box sx={{ mt: 1, display: 'flex', alignItems: 'center', color: 'text.secondary' }}>
                            <AccessTime size={18} style={{ marginRight: 4 }} />
                            <Typography variant="body2">
                                {formatDate(listing.created_at)}
                            </Typography>
                        </Box>

                        <Button
                            variant="contained"
                            fullWidth
                            sx={{ mt: 2 }}
                        >
                            Подробнее
                        </Button>
                    </>
                )}
            </CardContent>
        </Card>
    );
};

export default ListingCard;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/marketplace/CategoryTree.js ===

//frontend/hostel-frontend/src/components/marketplace/CategoryTree.js
import React, { useState } from 'react';
import {
  List,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Collapse,
  Typography,
  Box,
  useTheme
} from '@mui/material';
import { ChevronRight, ChevronDown } from 'lucide-react';

const CategoryTreeItem = ({ 
  category, 
  selectedId, 
  onSelect,
  level = 0 
}) => {
  const [isOpen, setIsOpen] = useState(level === 0);
  const theme = useTheme();

  const getTotalListings = (cat) => {
    let total = cat.listing_count || 0;
    if (cat.children) {
      total += cat.children.reduce((sum, child) => sum + getTotalListings(child), 0);
    }
    return total;
  };

  const totalListings = getTotalListings(category);
  const hasChildren = category.children && category.children.length > 0;
  const isSelected = selectedId === category.id;

  return (
    <>
      <ListItemButton
        dense
        onClick={() => {
          if (hasChildren) {
            setIsOpen(!isOpen);
          }
          onSelect(category.id);
        }}
        selected={isSelected}
        sx={{
          pl: level * 1.5 + 1,
          py: 0.5,
          minHeight: 32,
          color: isSelected ? 'primary.main' : 'text.primary',
          '&.Mui-selected': {
            backgroundColor: theme.palette.primary.main + '08',
            '&:hover': {
              backgroundColor: theme.palette.primary.main + '12',
            }
          }
        }}
      >
        <ListItemIcon sx={{ minWidth: 24, color: 'inherit' }}>
          {hasChildren && (
            isOpen ? <ChevronDown size={16} /> : <ChevronRight size={16} />
          )}
        </ListItemIcon>

        <ListItemText
          primary={
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
              <Typography
                variant="body2"
                sx={{
                  fontSize: '0.8125rem',
                  fontWeight: isSelected ? 500 : 400,
                }}
              >
                {category.name}
              </Typography>
              {totalListings > 0 && (
                <Typography
                  variant="caption"
                  color={isSelected ? 'primary' : 'text.secondary'}
                  sx={{ fontSize: '0.75rem' }}
                >
                  {totalListings}
                </Typography>
              )}
            </Box>
          }
        />
      </ListItemButton>

      {hasChildren && (
        <Collapse in={isOpen} timeout="auto">
          <List disablePadding>
            {category.children.map((child) => (
              <CategoryTreeItem
                key={child.id}
                category={child}
                selectedId={selectedId}
                onSelect={onSelect}
                level={level + 1}
              />
            ))}
          </List>
        </Collapse>
      )}
    </>
  );
};

const CompactCategoryTree = ({ categories, selectedId, onSelectCategory }) => {
  if (!categories?.length) {
    return (
      <Typography variant="body2" color="text.secondary" sx={{ p: 2 }}>
        Категории не найдены
      </Typography>
    );
  }

  return (
    <List 
      component="nav" 
      disablePadding
      sx={{
        '& .MuiListItemButton-root': {
          borderRadius: 0,
        }
      }}
    >
      {categories.map((category) => (
        <CategoryTreeItem
          key={category.id}
          category={category}
          selectedId={selectedId}
          onSelect={onSelectCategory}
        />
      ))}
    </List>
  );
};

export default CompactCategoryTree;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/marketplace/MarketplaceFilters.js ===

//frontend/hostel-frontend/src/components/marketplace/MarketplaceFilters.js
import React from 'react';
import {
    Paper,
    Box,
    TextField,
    Select,
    MenuItem,
    InputAdornment,
    IconButton,
    Typography,
    Divider,
} from '@mui/material';
import { Search, X } from 'lucide-react';
import CompactCategoryTree from './CategoryTree';

const CompactMarketplaceFilters = ({ filters, onFilterChange, categories, selectedCategoryId }) => {
    return (
        <Paper 
            variant="outlined" 
            sx={{ 
                height: '100%',
                display: 'flex',
                flexDirection: 'column',
            }}
        >
            {/* Поиск */}
            <Box sx={{ p: 1, borderBottom: 1, borderColor: 'divider' }}>
                <TextField
                    fullWidth
                    size="small"
                    placeholder="Поиск"
                    value={filters.query || ''}
                    onChange={(e) => onFilterChange({ query: e.target.value })}
                    InputProps={{
                        startAdornment: (
                            <InputAdornment position="start">
                                <Search size={16} />
                            </InputAdornment>
                        ),
                        endAdornment: filters.query && (
                            <InputAdornment position="end">
                                <IconButton edge="end" size="small" onClick={() => onFilterChange({ query: '' })}>
                                    <X size={14} />
                                </IconButton>
                            </InputAdornment>
                        )
                    }}
                    sx={{ 
                        '& .MuiInputBase-root': {
                            height: 36
                        }
                    }}
                />
            </Box>

            {/* Категории */}
            <Box sx={{ 
                flex: 1, 
                overflow: 'auto',
                '&::-webkit-scrollbar': {
                    width: 6,
                },
                '&::-webkit-scrollbar-thumb': {
                    bgcolor: 'rgba(0,0,0,0.1)',
                    borderRadius: 3,
                }
            }}>
                <CompactCategoryTree
                    categories={categories}
                    selectedId={selectedCategoryId}
                    onSelectCategory={(id) => onFilterChange({ category_id: id })}
                />
            </Box>

            {/* Фильтры */}
            <Box sx={{ p: 1.5, borderTop: 1, borderColor: 'divider' }}>
                <Typography variant="caption" color="text.secondary" gutterBottom>
                    Цена
                </Typography>
                <Box sx={{ display: 'flex', gap: 1, mb: 1.5 }}>
                    <TextField
                        size="small"
                        placeholder="От"
                        type="number"
                        value={filters.min_price || ''}
                        onChange={(e) => onFilterChange({ min_price: e.target.value })}
                        InputProps={{
                            startAdornment: <InputAdornment position="start">₽</InputAdornment>,
                        }}
                        sx={{ 
                            '& .MuiInputBase-root': {
                                height: 32,
                                fontSize: '0.875rem'
                            }
                        }}
                    />
                    <TextField
                        size="small"
                        placeholder="До"
                        type="number"
                        value={filters.max_price || ''}
                        onChange={(e) => onFilterChange({ max_price: e.target.value })}
                        InputProps={{
                            startAdornment: <InputAdornment position="start">₽</InputAdornment>,
                        }}
                        sx={{ 
                            '& .MuiInputBase-root': {
                                height: 32,
                                fontSize: '0.875rem'
                            }
                        }}
                    />
                </Box>

                <Typography variant="caption" color="text.secondary" gutterBottom>
                    Сортировка
                </Typography>
                <Select
                    fullWidth
                    size="small"
                    value={filters.sort_by || 'date_desc'}
                    onChange={(e) => onFilterChange({ sort_by: e.target.value })}
                    sx={{ 
                        '& .MuiSelect-select': {
                            py: 0.75,
                            fontSize: '0.875rem'
                        }
                    }}
                >
                    <MenuItem value="date_desc">Сначала новые</MenuItem>
                    <MenuItem value="price_asc">Сначала дешевле</MenuItem>
                    <MenuItem value="price_desc">Сначала дороже</MenuItem>
                    <MenuItem value="views">По популярности</MenuItem>
                </Select>
            </Box>
        </Paper>
    );
};

export default CompactMarketplaceFilters;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/marketplace/ItemDetails.js ===

// frontend/hostel-frontend/src/components/marketplace/ItemDetails.js
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import {
  Box,
  Typography,
  Button,
  Grid,
  Paper,
  Divider,
  CircularProgress,
  Chip,
} from '@mui/material';
import { Favorite, Share, ShoppingCart } from '@mui/icons-material';
import axios from '../api/axios';

const ItemDetails = () => {
  const { id } = useParams();
  const [item, setItem] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  useEffect(() => {
    const fetchItemDetails = async () => {
      try {
        const response = await axios.get(`/api/v1/marketplace/listings/${id}`);
        setItem(response.data);
      } catch (err) {
        setError('Не удалось загрузить данные товара.');
      } finally {
        setLoading(false);
      }
    };

    fetchItemDetails();
  }, [id]);

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" mt={4}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box display="flex" justifyContent="center" mt={4}>
        <Typography color="error">{error}</Typography>
      </Box>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ py: 4 }}>
      <Grid container spacing={4}>
        {/* Изображения */}
        <Grid item xs={12} md={6}>
          <Box component={Paper} elevation={3} sx={{ overflow: 'hidden' }}>
            <img
              src={item.image || '/placeholder.png'}
              alt={item.title}
              style={{ width: '100%', height: 'auto' }}
            />
          </Box>
        </Grid>

        {/* Основная информация */}
        <Grid item xs={12} md={6}>
          <Box>
            <Typography variant="h4" fontWeight="bold">
              {item.title}
            </Typography>
            <Typography variant="h6" color="text.secondary" gutterBottom>
              {item.price} ₽
            </Typography>
            <Typography variant="body1" sx={{ my: 2 }}>
              {item.description}
            </Typography>
            <Divider sx={{ my: 2 }} />
            <Box display="flex" gap={2}>
              <Button
                variant="contained"
                startIcon={<ShoppingCart />}
                size="large"
              >
                Купить
              </Button>
              <Button
                variant="outlined"
                startIcon={<Favorite />}
                size="large"
              >
                В избранное
              </Button>
              <Button
                variant="outlined"
                startIcon={<Share />}
                size="large"
              >
                Поделиться
              </Button>
            </Box>
          </Box>
        </Grid>
      </Grid>

      {/* Отзывы */}
      <Box mt={4}>
        <Typography variant="h5" fontWeight="bold">
          Отзывы
        </Typography>
        {/* Здесь можно добавить список отзывов */}
        <Typography variant="body2" color="text.secondary">
          Пока нет отзывов.
        </Typography>
      </Box>
    </Container>
  );
};

export default ItemDetails;

=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/global/LocationPicker.js ===

import React, { useState, useCallback } from 'react';
import { GoogleMap, Marker } from '@react-google-maps/api';
import {
    Box,
    TextField,
    Paper,
    Typography,
    InputAdornment,
    IconButton,
} from '@mui/material';
import { Search as SearchIcon, MyLocation as MyLocationIcon } from '@mui/icons-material';

const LocationPicker = ({ onLocationSelect }) => {
    const [map, setMap] = useState(null);
    const [marker, setMarker] = useState(null);
    const [address, setAddress] = useState('');
    const [searchBox, setSearchBox] = useState(null);

    const mapContainerStyle = {
        width: '100%',
        height: '400px'
    };

    const defaultCenter = {
        lat: 45.2671, // Нови-Сад
        lng: 19.8335
    };

    const mapOptions = {
        scrollwheel: true,
        mapTypeControl: true,
        mapTypeControlOptions: {
            style: 'DEFAULT',
            mapTypeIds: ["roadmap", "satellite", "hybrid"]
        },
        streetViewControl: false,
        fullscreenControl: false,
    };

    const handleLocationSelect = (location) => {
        const getAddressComponent = (type) => {
            return location.address_components?.find(
                component => component.types.includes(type)
            )?.long_name || '';
        };

        const streetNumber = getAddressComponent('street_number');
        const route = getAddressComponent('route');

        const fullStreetAddress = route
            ? (streetNumber ? `${route}, ${streetNumber}` : route)
            : '';

        onLocationSelect({
            latitude: location.latitude,
            longitude: location.longitude,
            formatted_address: location.formatted_address,
            address_components: {
                street: fullStreetAddress || getAddressComponent('sublocality') || '',
                city: getAddressComponent('locality'),
                state: getAddressComponent('administrative_area_level_1'),
                country: getAddressComponent('country'),
                postal_code: getAddressComponent('postal_code')
            }
        });
    };

    const onMapLoad = useCallback((map) => {
        setMap(map);
        const searchInput = document.getElementById('location-search');
        if (searchInput && window.google) {
            const searchBoxInstance = new window.google.maps.places.SearchBox(searchInput);
            setSearchBox(searchBoxInstance);

            searchBoxInstance.addListener('places_changed', () => {
                const places = searchBoxInstance.getPlaces();
                if (places.length === 0) return;

                const place = places[0];
                if (!place.geometry) return;

                map.setCenter(place.geometry.location);
                map.setZoom(17);

                setMarker({
                    lat: place.geometry.location.lat(),
                    lng: place.geometry.location.lng()
                });

                setAddress(place.formatted_address);

                handleLocationSelect({
                    latitude: place.geometry.location.lat(),
                    longitude: place.geometry.location.lng(),
                    formatted_address: place.formatted_address,
                    address_components: place.address_components
                });
            });
        }
    }, [onLocationSelect]);

    const handleMapClick = useCallback((e) => {
        const lat = e.latLng.lat();
        const lng = e.latLng.lng();

        setMarker({ lat, lng });

        if (window.google) {
            const geocoder = new window.google.maps.Geocoder();
            geocoder.geocode(
                { location: { lat, lng } },
                (results, status) => {
                    if (status === 'OK' && results[0]) {
                        const place = results[0];
                        setAddress(place.formatted_address);
                        const location = {
                            latitude: lat,
                            longitude: lng,
                            formatted_address: place.formatted_address,
                            address_components: place.address_components
                        };
                        handleLocationSelect(location);
                    }
                }
            );
        }
    }, []);

    const handleCurrentLocation = () => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;

                    if (map) {
                        map.setCenter({ lat, lng });
                        map.setZoom(17);
                        setMarker({ lat, lng });
                    }

                    if (window.google) {
                        const geocoder = new window.google.maps.Geocoder();
                        geocoder.geocode(
                            { location: { lat, lng } },
                            (results, status) => {
                                if (status === 'OK' && results[0]) {
                                    const place = results[0];
                                    setAddress(place.formatted_address);
                                    handleLocationSelect({
                                        latitude: lat,
                                        longitude: lng,
                                        formatted_address: place.formatted_address,
                                        address_components: place.address_components
                                    });
                                }
                            }
                        );
                    }
                },
                (error) => {
                    console.error("Error getting current location:", error);
                    alert("Не удалось получить текущее местоположение");
                }
            );
        } else {
            alert("Геолокация не поддерживается вашим браузером");
        }
    };

    return (
        <Paper sx={{ p: 2 }}>
            <Typography variant="h6" gutterBottom>
                Выберите местоположение объекта
            </Typography>
            <Box sx={{ mb: 2 }}>
                <TextField
                    id="location-search"
                    fullWidth
                    placeholder="Поиск по адресу..."
                    value={address}
                    onChange={(e) => setAddress(e.target.value)}
                    InputProps={{
                        startAdornment: (
                            <InputAdornment position="start">
                                <SearchIcon />
                            </InputAdornment>
                        ),
                        endAdornment: (
                            <InputAdornment position="end">
                                <IconButton
                                    onClick={handleCurrentLocation}
                                    title="Мое местоположение"
                                >
                                    <MyLocationIcon />
                                </IconButton>
                            </InputAdornment>
                        )
                    }}
                />
            </Box>
            <GoogleMap
                mapContainerStyle={mapContainerStyle}
                center={defaultCenter}
                zoom={13}
                onLoad={onMapLoad}
                onClick={handleMapClick}
                options={mapOptions}
            >
                {marker && (
                    <Marker
                        position={marker}
                        draggable={true}
                        onDragEnd={(e) => handleMapClick(e)}
                    />
                )}
            </GoogleMap>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Кликните по карте или введите адрес для выбора местоположения
            </Typography>
        </Paper>
    );
};

export default LocationPicker;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/global/Layout.js ===

//frontend/hostel-frontend/src/components/Layout.js
import React, { useState } from "react";
import { ShoppingBag} from '@mui/icons-material';
import MessageIcon from '@mui/icons-material/Message';
import { Link, useLocation } from "react-router-dom";
import {
  AppBar,
  Toolbar,
  Box,
  Container,
  Typography,
  IconButton,
  Avatar,
  Tooltip,
  Menu,
  MenuItem,
  Divider,
  useMediaQuery,
  useTheme,
  Modal,
} from "@mui/material";
import {
  HomeWork,
  DirectionsCar,
  AttachMoney,
  Key,
  Logout,
  ListAlt,
  AddHome,
  AccountCircle,
} from "@mui/icons-material";
import { useAuth } from "../../contexts/AuthContext";
import UserProfile from "../user/UserProfile";
import { Bookmark } from '@mui/icons-material';

const Layout = ({ children }) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm"));
  const location = useLocation();

  // Определение текущей страницы
  const currentPath = location.pathname;

  const { user, login, logout } = useAuth();

  const [anchorEl, setAnchorEl] = useState(null);
  const [isProfileOpen, setIsProfileOpen] = useState(false);

  const handleOpenMenu = (e) => {
    setAnchorEl(e.currentTarget);
  };

  const handleCloseMenu = () => {
    setAnchorEl(null);
  };

  const handleOpenProfile = () => {
    setIsProfileOpen(true);
    handleCloseMenu();
  };

  const handleCloseProfile = () => {
    setIsProfileOpen(false);
  };

  const menuItems = [
    { path: "/", label: "Hostel", icon: <HomeWork fontSize="medium" /> },
    { path: "/cars", label: "Auto", icon: <DirectionsCar fontSize="medium" /> },
    { path: "/marketplace", label: "Market", icon: <AttachMoney fontSize="medium" /> },
  ];

  return (
    <Box sx={{ flexGrow: 1 }}>
      <AppBar
        position="static"
        sx={{
          bgcolor: "background.default",
          color: "text.primary",
          borderBottom: "1px solid #e0e0e0",
          boxShadow: "none",
        }}
      >
        <Container maxWidth="lg">
          <Toolbar
            disableGutters
            sx={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              minHeight: "56px",
              px: 2,
            }}
          >
            {/* Левый блок (меню) */}
            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                gap: isMobile ? 1.5 : 3,
              }}
            >
              {menuItems.map((item) => (
                <Box
                  key={item.path}
                  component={Link}
                  to={item.path}
                  sx={{
                    textDecoration: "none",
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    gap: 0.3,
                    color: currentPath === item.path ? "primary.main" : "text.secondary",
                    fontWeight: currentPath === item.path ? 600 : 400,
                    fontSize: "0.9rem",
                    transition: "color 0.3s ease, transform 0.3s ease",
                    "&:hover": {
                      color: "primary.main",
                      transform: "scale(1.05)",
                    },
                  }}
                >
                  {item.icon}
                  <Typography
                    variant="body2"
                    sx={{
                      fontSize: isMobile ? "0.75rem" : "0.85rem",
                      textAlign: "center",
                    }}
                  >
                    {item.label}
                  </Typography>
                </Box>
              ))}
            </Box>

            {/* Правый блок (авторизация) */}
            <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
              {!user ? (
                <Tooltip title="Войти">
                  <IconButton onClick={() => {
                    const returnUrl = window.location.pathname + window.location.search;
                    const encodedReturnUrl = encodeURIComponent(returnUrl);
                    login(`?returnTo=${encodedReturnUrl}`);
                  }} color="primary">
                    <Key />
                  </IconButton>
                </Tooltip>
              ) : (
                <>
                  <Tooltip title="Мой профиль">
                    <IconButton onClick={handleOpenMenu}>
                      <Avatar
                        src={user.pictureUrl}
                        alt={user.name}
                        sx={{ width: 32, height: 32 }}
                      />
                    </IconButton>
                  </Tooltip>
                  <Menu
                    anchorEl={anchorEl}
                    open={Boolean(anchorEl)}
                    onClose={handleCloseMenu}
                    PaperProps={{
                      sx: { mt: 1.5, width: 220 },
                    }}
                    transformOrigin={{ horizontal: "right", vertical: "top" }}
                    anchorOrigin={{ horizontal: "right", vertical: "bottom" }}
                  >
                    <MenuItem
                      onClick={handleOpenProfile}
                      sx={{ display: "flex", flexDirection: "column", alignItems: "flex-start", gap: 0.5 }}
                    >
                      <Typography variant="subtitle2" noWrap sx={{ fontWeight: 600 }}>
                        {user.name}
                      </Typography>
                      <Typography variant="caption" color="text.secondary" noWrap>
                        {user.email}
                      </Typography>
                    </MenuItem>
                    <Divider />
                    
                    <MenuItem component={Link} to="/marketplace/chat">
                      <MessageIcon fontSize="small" sx={{ mr: 1 }} />
                      Мои сообщения
                    </MenuItem>
                    
                    <MenuItem component={Link} to="/bookings">
                      <ListAlt fontSize="small" sx={{ mr: 1 }} />
                      Мои бронирования
                    </MenuItem>
                    <MenuItem component={Link} to="/my-listings">
                      <ShoppingBag fontSize="small" sx={{ mr: 1 }} />
                      Мои объявления
                    </MenuItem>
                    <MenuItem component={Link} to="/favorites">
                      <Bookmark fontSize="small" sx={{ mr: 1 }} />
                      Избранное
                    </MenuItem>
                    <MenuItem component={Link} to="/add-room">
                      <AddHome fontSize="small" sx={{ mr: 1 }} />
                      Добавить жильё
                    </MenuItem>
                    <MenuItem component={Link} to="/add-car">
                      <DirectionsCar fontSize="small" sx={{ mr: 1 }} />
                      Добавить автомобиль
                    </MenuItem>
                    <Divider />
                    <MenuItem onClick={logout}>
                      <Logout fontSize="small" sx={{ mr: 1 }} />
                      Выйти
                    </MenuItem>
                  </Menu>
                </>
              )}
            </Box>
          </Toolbar>
        </Container>
      </AppBar>

      {/* Модальное окно для редактирования профиля */}
      <Modal open={isProfileOpen} onClose={handleCloseProfile}>
        <Box
          sx={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: "90%",
            maxWidth: 600,
            bgcolor: "background.paper",
            borderRadius: 2,
            boxShadow: 24,
            p: 4,
          }}
        >
          <UserProfile onClose={handleCloseProfile} />
        </Box>
      </Modal>

      {/* Основной контент */}
      <Container maxWidth="lg" sx={{ py: 3 }}>
        {children}
      </Container>
    </Box>
  );
};

export default Layout;

=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/user/UserProfile.js ===

import React, { useState, useEffect } from 'react';
import {
    Box,
    TextField,
    Button,
    Switch,
    FormControlLabel,
    Paper,
    Typography,
    Alert,
    Stack,
    Avatar,
    IconButton
} from '@mui/material';
import { Close as CloseIcon } from '@mui/icons-material';
import { useAuth } from '../../contexts/AuthContext';
import axios from '../../api/axios';

const UserProfile = ({ onClose }) => {
    const { user } = useAuth();
    const [profile, setProfile] = useState(null);
    const [isEditing, setIsEditing] = useState(false);
    const [error, setError] = useState('');
    const [success, setSuccess] = useState('');
    const [formData, setFormData] = useState({
        phone: '',
        bio: '',
        notification_email: true,
        notification_push: true,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
    });

    useEffect(() => {
        const fetchProfile = async () => {
            try {
                const response = await axios.get('/api/v1/users/profile');
                setProfile(response.data.data);
                setFormData({
                    phone: response.data.data.phone || '',
                    bio: response.data.data.bio || '',
                    notification_email: response.data.data.notification_email,
                    notification_push: response.data.data.notification_push,
                    timezone: response.data.data.timezone
                });
            } catch (err) {
                setError('Ошибка загрузки профиля');
            }
        };
        fetchProfile();
    }, []);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setSuccess('');

        try {
            await axios.put('/api/v1/users/profile', formData);
            setSuccess('Профиль успешно обновлен');
            setIsEditing(false);
        } catch (err) {
            setError(err.response?.data?.error || 'Ошибка обновления профиля');
        }
    };

    if (!profile) {
        return <Box sx={{ p: 3 }}><Typography>Загрузка...</Typography></Box>;
    }

    return (
        <Box sx={{ maxWidth: 600, mx: 'auto', position: 'relative' }}>
            {/* Close button */}
            <IconButton
                onClick={onClose}
                sx={{
                    position: 'absolute',
                    right: 8,
                    top: 8,
                    zIndex: 1
                }}
            >
                <CloseIcon />
            </IconButton>

            <Paper sx={{ p: 3 }}>
                <Stack spacing={3}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                        <Avatar
                            src={profile.picture_url}
                            alt={profile.name}
                            sx={{ width: 80, height: 80 }}
                        />
                        <Box>
                            <Typography variant="h5">{profile.name}</Typography>
                            <Typography variant="body2" color="text.secondary">
                                {profile.email}
                            </Typography>
                        </Box>
                    </Box>

                    {error && <Alert severity="error">{error}</Alert>}
                    {success && <Alert severity="success">{success}</Alert>}

                    <form onSubmit={handleSubmit}>
                        <Stack spacing={2}>
                            <TextField
                                label="Телефон"
                                value={formData.phone}
                                onChange={(e) => setFormData({
                                    ...formData,
                                    phone: e.target.value
                                })}
                                disabled={!isEditing}
                                fullWidth
                            />

                            <TextField
                                label="О себе"
                                value={formData.bio}
                                onChange={(e) => setFormData({
                                    ...formData,
                                    bio: e.target.value
                                })}
                                disabled={!isEditing}
                                multiline
                                rows={4}
                                fullWidth
                            />

                            <FormControlLabel
                                control={
                                    <Switch
                                        checked={formData.notification_email}
                                        onChange={(e) => setFormData({
                                            ...formData,
                                            notification_email: e.target.checked
                                        })}
                                        disabled={!isEditing}
                                    />
                                }
                                label="Email уведомления"
                            />

                            <FormControlLabel
                                control={
                                    <Switch
                                        checked={formData.notification_push}
                                        onChange={(e) => setFormData({
                                            ...formData,
                                            notification_push: e.target.checked
                                        })}
                                        disabled={!isEditing}
                                    />
                                }
                                label="Push уведомления"
                            />

                            {isEditing ? (
                                <Box sx={{ display: 'flex', gap: 1 }}>
                                    <Button
                                        type="submit"
                                        variant="contained"
                                        fullWidth
                                    >
                                        Сохранить
                                    </Button>
                                    <Button
                                        onClick={() => setIsEditing(false)}
                                        variant="outlined"
                                        fullWidth
                                    >
                                        Отмена
                                    </Button>
                                </Box>
                            ) : (
                                <Button
                                    onClick={() => setIsEditing(true)}
                                    variant="contained"
                                    fullWidth
                                >
                                    Редактировать
                                </Button>
                            )}
                        </Stack>
                    </form>
                </Stack>
            </Paper>
        </Box>
    );
};

export default UserProfile;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/user/AddUser.js ===

import React, { useState } from "react";
import { TextField, Button, Container, Typography, Alert } from "@mui/material";
import axios from "../../api/axios";
import { useAuth } from "../../contexts/AuthContext";

const AddUser = () => {
  const { user } = useAuth();
  const [userForm, setUserForm] = useState({ name: "", email: "" });
  const [error, setError] = useState("");
  const [success, setSuccess] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setSuccess(false);

    if (!user) {
      setError("Необходимо войти в систему");
      return;
    }

    try {
      await axios.post('/users', userForm, {
        withCredentials: true
      });
      setSuccess(true);
      setUserForm({ name: "", email: "" });
    } catch (err) {
      setError(err.response?.data || "Ошибка при добавлении пользователя");
    }
  };

  if (!user) {
    return (
      <Container>
        <Alert severity="warning">
          Для добавления пользователей необходимо войти в систему
        </Alert>
      </Container>
    );
  }

  return (
    <Container>
      <Typography variant="h4" gutterBottom>
        Добавить пользователя
      </Typography>
      {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
      {success && <Alert severity="success" sx={{ mb: 2 }}>Пользователь успешно добавлен!</Alert>}
      <form onSubmit={handleSubmit}>
        <TextField
          label="Имя"
          fullWidth
          margin="normal"
          value={userForm.name}
          onChange={(e) => setUserForm({ ...userForm, name: e.target.value })}
          required
        />
        <TextField
          label="Email"
          type="email"
          fullWidth
          margin="normal"
          value={userForm.email}
          onChange={(e) => setUserForm({ ...userForm, email: e.target.value })}
          required
        />
        <Button
          type="submit"
          variant="contained"
          color="primary"
          sx={{ mt: 2 }}
        >
          Добавить
        </Button>
      </form>
    </Container>
  );
};

export default AddUser;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/index.js ===

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { ThemeProvider } from "@mui/material/styles";
import { CssBaseline } from '@mui/material';
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  // Можно добавить кастомные настройки темы
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
});

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <App />
    </ThemeProvider>
  </React.StrictMode>
);

reportWebVitals();

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/api/axios.js ===

// frontend/hostel-frontend/src/api/axios.js
import axios from 'axios';

const instance = axios.create({
  baseURL: process.env.REACT_APP_BACKEND_URL || 'http://localhost:3000',
  withCredentials: true,
  headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
  },
  validateStatus: function (status) {
      return status >= 200 && status < 500;
  }
});
instance.interceptors.response.use(
  response => response,
  error => {
      if (error.response?.status === 401) {
          // Можно добавить редирект на страницу логина
          window.location.href = '/login';
      }
      return Promise.reject(error);
  }
);

export default instance;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/contexts/AuthContext.js ===

import React, { createContext, useState, useContext, useEffect } from 'react';
import axios from '../api/axios';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true); // добавляем loading

  const checkAuth = async () => {
      try {
          const response = await axios.get('/auth/session', { withCredentials: true });
          if (response.data.authenticated) {
              setUser(response.data.user);
          }
      } catch (error) {
          console.error('Auth check failed:', error);
      } finally {
          setLoading(false); // устанавливаем loading в false после проверки
      }
  };


  useEffect(() => {
    checkAuth();
  }, []);

  // Объединяем функциональность в одной функции login
  const login = (params = '') => {
    window.location.href = `${process.env.REACT_APP_BACKEND_URL}/auth/google${params}`;
  };

  const logout = async () => {
    try {
      await axios.get('/auth/logout', { withCredentials: true });
      setUser(null);
    } catch (error) {
      console.error('Logout failed:', error);
    }
  };

  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
        {children}
    </AuthContext.Provider>
);
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/App.js ===

import React from "react";
import { BrowserRouter, Routes, Route } from "react-router-dom";

import { AuthProvider } from "./contexts/AuthContext";
import Layout from "./components/global/Layout";
import HomePage from "./pages/global/HomePage";
import AddRoomPage from "./pages/accommodation/AddRoomPage";
import AddUserPage from "./pages/user/AddUserPage";
import BookingsListPage from "./pages/accommodation/BookingsListPage";
import AdminPanelPage from "./pages/global/AdminPanelPage";
import PrivacyPolicy from "./pages/accommodation/PrivacyPolicy";
import CarListPage from "./pages/car/CarListPage";
import AddCarPage from "./pages/car/AddCarPage";
import MarketplacePage from "./pages/marketplace/MarketplacePage";
import CreateListingPage from "./pages/marketplace/CreateListingPage";
import ListingDetailsPage from './pages/marketplace/ListingDetailsPage';
import UserProfile from './components/user/UserProfile';
import MyListingsPage from './pages/marketplace/MyListingsPage';
import FavoriteListingsPage from './pages/marketplace/FavoriteListingsPage';
import { MapProvider } from './components/maps/MapProvider';
import ChatPage from "./pages/marketplace/ChatPage";

function App() {
  return (
    <BrowserRouter
      future={{
        v7_startTransition: true,
        v7_relativeSplatPath: true
      }}
    >
      <MapProvider>
        <AuthProvider>
          <Layout>
            <Routes>
              <Route path="/" element={<HomePage />} />
              <Route path="/bookings" element={<BookingsListPage />} />
              <Route path="/add-room" element={<AddRoomPage />} />
              <Route path="/add-user" element={<AddUserPage />} />
              <Route path="/admin" element={<AdminPanelPage />} />
              <Route path="/privacy-policy" element={<PrivacyPolicy />} />
              <Route path="/cars" element={<CarListPage />} />
              <Route path="/add-car" element={<AddCarPage />} />
              <Route path="/marketplace" element={<MarketplacePage />} />
              <Route path="/marketplace/create" element={<CreateListingPage />} />
              <Route path="/marketplace/listings/:id" element={<ListingDetailsPage />} />
              <Route path="/profile" element={<UserProfile />} />
              <Route path="/marketplace/chat" element={<ChatPage />} />
              <Route path="/my-listings" element={<MyListingsPage />} />
              <Route path="/favorites" element={<FavoriteListingsPage />} />
            </Routes>
          </Layout>
        </AuthProvider>
      </MapProvider>
    </BrowserRouter>
  );
}

export default App;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/setupProxy.js ===

const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) {
  // Proxy для API запросов
  app.use(
    '/api',
    createProxyMiddleware({
      target: 'http://localhost:3000',
      changeOrigin: true,
    })
  );

  // Proxy для WebSocket соединений
  app.use(
    '/ws',
    createProxyMiddleware({
      target: 'http://localhost:3001',
      ws: true,
      changeOrigin: true,
    })
  );
};
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/reportWebVitals.js ===

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/pages/marketplace/MarketplacePage.js ===

//frontend/hostel-frontend/src/pages/MarketplacePage.js
import { useEffect, useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import { useNavigate } from 'react-router-dom';
import {
    Container,
    Grid,
    Box,
    Typography,
    CircularProgress,
    Button,
    useTheme,
    useMediaQuery,
    Drawer,
    IconButton,
    Fab,
    Alert,
    Paper,
    Chip,
} from '@mui/material';
import { Plus, Filter, X } from 'lucide-react';
import ListingCard from '../../components/marketplace/ListingCard';
import {
    MobileFilters,
    MobileHeader,
    MobileListingCard
} from '../../components/marketplace/MobileComponents';
import CompactMarketplaceFilters from '../../components/marketplace/MarketplaceFilters';
import axios from '../../api/axios';
import { debounce } from 'lodash';

const MarketplacePage = () => {
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));
    const navigate = useNavigate();

    const [listings, setListings] = useState([]); 
    const [categories, setCategories] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [isFilterOpen, setIsFilterOpen] = useState(false);
    const [filters, setFilters] = useState({
        query: '',
        category_id: '',
        min_price: '',
        max_price: '',
        city: '',
        country: '',
        condition: '',
        sort_by: 'date_desc'
    });


    const handleFilterChange = useCallback((newFilters) => {
        setFilters(prev => ({
            ...prev,
            ...newFilters
        }));
    }, []);

    const fetchListings = useCallback(async (currentFilters) => {
        try {
            setLoading(true);
            setError(null);

            const params = Object.entries(currentFilters).reduce((acc, [key, value]) => {
                if (value !== '' && value !== null && value !== undefined) {
                    acc[key] = value;
                }
                return acc;
            }, {});

            const response = await axios.get('/api/v1/marketplace/listings', { params });
            const listingsData = response.data?.data?.data || [];
            setListings(listingsData);
        } catch (error) {
            console.error('Error fetching listings:', error);
            setError('Не удалось загрузить объявления');
        } finally {
            setLoading(false);
        }
    }, []);

    // Эффект для загрузки категорий
    useEffect(() => {
        const fetchData = async () => {
            try {
                setLoading(true);
                // Параллельная загрузка категорий и листингов
                const [categoriesResponse, listingsResponse] = await Promise.all([
                    axios.get('/api/v1/marketplace/category-tree'),
                    axios.get('/api/v1/marketplace/listings', {
                        params: Object.entries(filters).reduce((acc, [key, value]) => {
                            if (value !== '' && value !== null && value !== undefined) {
                                acc[key] = value;
                            }
                            return acc;
                        }, {})
                    })
                ]);

                if (categoriesResponse.data?.data) {
                    setCategories(categoriesResponse.data.data);
                }
                setListings(listingsResponse.data?.data?.data || []);
                setError(null);
            } catch (err) {
                console.error('Error fetching data:', err);
                setError('Произошла ошибка при загрузке данных');
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, [filters]); // Убираем лишний useEffect и объединяем загрузку данных

    const getActiveFiltersCount = () => {
        return Object.entries(filters).reduce((count, [key, value]) => {
            if (key !== 'sort_by' && value !== '') {
                return count + 1;
            }
            return count;
        }, 0);
    };

    const renderContent = () => {
        if (loading) {
            return (
                <Box display="flex" justifyContent="center" p={4}>
                    <CircularProgress />
                </Box>
            );
        }

        if (error) {
            return (
                <Alert 
                    severity="error" 
                    sx={{ m: 2 }}
                    action={
                        <IconButton size="small" onClick={() => setError(null)}>
                            <X size={16} />
                        </IconButton>
                    }
                >
                    {error}
                </Alert>
            );
        }

        if (listings.length === 0) {
            return (
                <Alert severity="info" sx={{ m: 2 }}>
                    По вашему запросу ничего не найдено
                </Alert>
            );
        }

        return (
            <Grid container spacing={isMobile ? 1 : 3}>
                {listings.map((listing) => (
                    <Grid item xs={isMobile ? 6 : 12} sm={6} md={4} key={listing.id}>
                        <Link
                            to={`/marketplace/listings/${listing.id}`}
                            style={{ textDecoration: 'none' }}
                        >
                            {isMobile ? (
                                <MobileListingCard listing={listing} />
                            ) : (
                                <ListingCard listing={listing} />
                            )}
                        </Link>
                    </Grid>
                ))}
            </Grid>
        );
    };

    if (isMobile) {
        return (
            <Box sx={{ minHeight: '100vh', display: 'flex', flexDirection: 'column' }}>
                <MobileHeader
                    onOpenFilters={() => setIsFilterOpen(true)}
                    filtersCount={getActiveFiltersCount()}
                />

                <Box sx={{ flex: 1, p: 1, bgcolor: 'grey.50' }}>
                    {filters.category_id && (
                        <Box sx={{ px: 1, mb: 1 }}>
                            <Chip
                                label={categories.find(c => c.id === filters.category_id)?.name}
                                onDelete={() => handleFilterChange({ category_id: '' })}
                                size="small"
                            />
                        </Box>
                    )}
                    {renderContent()}
                </Box>

                <MobileFilters
                    open={isFilterOpen}
                    onClose={() => setIsFilterOpen(false)}
                    filters={filters}
                    onFilterChange={handleFilterChange}
                    categories={categories}
                />

                <Box
                    component={Paper}
                    elevation={3}
                    sx={{
                        position: 'sticky',
                        bottom: 0,
                        p: 2,
                        borderRadius: 0
                    }}
                >
                    <Button
                        variant="contained"
                        fullWidth
                        onClick={() => navigate('/marketplace/create')}
                        startIcon={<Plus size={20} />}
                    >
                        Разместить объявление
                    </Button>
                </Box>
            </Box>
        );
    }

    return (
        <Container maxWidth="lg" sx={{ py: 4 }}>
            <Box sx={{ mb: 4, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Typography variant="h4">
                    Объявления
                </Typography>
                <Button
                    variant="contained"
                    onClick={() => navigate('/marketplace/create')}
                    startIcon={<Plus />}
                >
                    Создать объявление
                </Button>
            </Box>

            <Grid container spacing={3}>
                <Grid item xs={12} md={3}>
                    <CompactMarketplaceFilters
                        filters={filters}
                        onFilterChange={handleFilterChange}
                        categories={categories}
                        selectedCategoryId={filters.category_id}
                        isLoading={loading}
                    />
                </Grid>
                <Grid item xs={12} md={9}>
                    {renderContent()}
                </Grid>
            </Grid>
        </Container>
    );
};

export default MarketplacePage;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/pages/marketplace/ListingDetailsPage.js ===

//frontend/hostel-frontend/src/pages/ListingDetailsPage.js
import ChatButton from '../../components/marketplace/chat/ChatButton';
import React, { useState, useEffect, useRef } from 'react';
import { useParams } from 'react-router-dom';
import ReviewsSection from '../../components/reviews/ReviewsSection';
import { useAuth } from '../../contexts/AuthContext';
import MiniMap from '../../components/maps/MiniMap';

//import { LoadScript, GoogleMap, Marker } from '@react-google-maps/api';
import { GoogleMap, Marker } from '@react-google-maps/api';

import {
    Container,
    Modal,
    Paper,
    Grid,
    Box,
    Typography,
    Button,
    Card,
    CardContent,
    Skeleton,
    Stack,
    Avatar,
    IconButton,
    useTheme,
    useMediaQuery,
    ImageList,
    ImageListItem
} from '@mui/material';
import {
    MapPin,
    Calendar,
    Heart,
    Share2,
    Phone,
    MessageCircle,
    ChevronLeft,
    Maximize2,
    ChevronRight
} from 'lucide-react';
import axios from '../../api/axios';
const ListingDetailsPage = () => {
    const [isFavorite, setIsFavorite] = useState(false);
    const [isMapExpanded, setIsMapExpanded] = useState(false);
    const { id } = useParams();
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));
    const reviewsRef = useRef(null);

    const [listing, setListing] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [currentImageIndex, setCurrentImageIndex] = useState(0);
    const [reviewsCount, setReviewsCount] = useState(0);
    const { user, login } = useAuth();

    useEffect(() => {
        const fetchListing = async () => {
            try {
                setLoading(true);
                const response = await axios.get(`/api/v1/marketplace/listings/${id}`);
                setListing(response.data.data);
                setIsFavorite(response.data.data.is_favorite || false);
            } catch (err) {
                console.error('Error fetching listing:', err);
                setError('Не удалось загрузить объявление');
            } finally {
                setLoading(false);
            }
        };

        fetchListing();
    }, [id]);
    const scrollToReviews = () => {
        const reviewsSection = document.getElementById('reviews-section');
        if (reviewsSection) {
            reviewsSection.scrollIntoView({
                behavior: 'smooth',
                block: 'start'
            });
        }
    };
    const handleFavoriteClick = async () => {
        if (!user) {
            const returnUrl = window.location.pathname;
            const encodedReturnUrl = encodeURIComponent(returnUrl);
            login(`?returnTo=${encodedReturnUrl}`);
            return;
        }

        try {
            // Оптимистично обновляем UI
            setListing(prev => ({
                ...prev,
                is_favorite: !prev.is_favorite
            }));

            if (listing.is_favorite) {
                await axios.delete(`/api/v1/marketplace/listings/${id}/favorite`);
            } else {
                await axios.post(`/api/v1/marketplace/listings/${id}/favorite`);
            }
            // Получаем реальные данные с сервера
            const response = await axios.get(`/api/v1/marketplace/listings/${id}`);
            console.log('Обновленные данные объявления:', response.data.data);
            setListing(response.data.data);
        } catch (err) {
            // В случае ошибки возвращаем предыдущее состояние
            setListing(prev => ({
                ...prev,
                is_favorite: !prev.is_favorite
            }));
            console.error('Ошибка при обновлении избранного:', err);
            alert('Произошла ошибка при обновлении избранного');
        }
    };

    const formatPrice = (price) => {
        return new Intl.NumberFormat('ru-RU', {
            style: 'currency',
            currency: 'RUB',
            maximumFractionDigits: 0
        }).format(price);
    };

    if (loading) {
        return (
            <Container maxWidth="lg" sx={{ py: 4 }}>
                <Grid container spacing={4}>
                    <Grid item xs={12} md={8}>
                        <Skeleton variant="rectangular" height={400} />
                    </Grid>
                    <Grid item xs={12} md={4}>
                        <Skeleton variant="rectangular" height={200} />
                    </Grid>
                </Grid>
            </Container>
        );
    }

    if (error) {
        return (
            <Container maxWidth="lg" sx={{ py: 4 }}>
                <Typography color="error">{error}</Typography>
            </Container>
        );
    }

    if (!listing) return null;

    return (
        <Container maxWidth="lg" sx={{ py: 4 }}>
            <Grid container spacing={4}>
                {/* Галерея изображений */}
                <Grid item xs={12} md={8}>
                    <Box sx={{ position: 'relative' }}>
                        {listing.images && listing.images.length > 0 ? (
                            <>
                                <Box
                                    component="img"
                                    src={`${process.env.REACT_APP_BACKEND_URL}/uploads/${listing.images[currentImageIndex].file_path}`}
                                    alt={listing.title}
                                    sx={{
                                        width: '100%',
                                        height: isMobile ? '300px' : '500px',
                                        objectFit: 'cover',
                                        borderRadius: 2
                                    }}
                                />
                                {listing.images.length > 1 && (
                                    <>
                                        <IconButton
                                            sx={{
                                                position: 'absolute',
                                                left: 8,
                                                top: '50%',
                                                transform: 'translateY(-50%)',
                                                bgcolor: 'background.paper',
                                                '&:hover': { bgcolor: 'background.paper' }
                                            }}
                                            onClick={() => setCurrentImageIndex(prev =>
                                                prev > 0 ? prev - 1 : listing.images.length - 1
                                            )}
                                        >
                                            <ChevronLeft />
                                        </IconButton>
                                        <IconButton
                                            sx={{
                                                position: 'absolute',
                                                right: 8,
                                                top: '50%',
                                                transform: 'translateY(-50%)',
                                                bgcolor: 'background.paper',
                                                '&:hover': { bgcolor: 'background.paper' }
                                            }}
                                            onClick={() => setCurrentImageIndex(prev =>
                                                prev < listing.images.length - 1 ? prev + 1 : 0
                                            )}
                                        >
                                            <ChevronRight />
                                        </IconButton>
                                    </>
                                )}
                            </>
                        ) : (
                            <Box
                                sx={{
                                    width: '100%',
                                    height: isMobile ? '300px' : '500px',
                                    bgcolor: 'grey.200',
                                    borderRadius: 2,
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}
                            >
                                <Typography color="text.secondary">
                                    Нет изображений
                                </Typography>
                            </Box>
                        )}
                    </Box>

                    {listing.images && listing.images.length > 1 && (
                        <ImageList
                            sx={{ mt: 2, maxHeight: 100 }}
                            cols={Math.min(listing.images.length, 6)}
                            rowHeight={100}
                        >
                            {listing.images.map((image, index) => (
                                <ImageListItem
                                    key={image.id}
                                    sx={{
                                        cursor: 'pointer',
                                        opacity: currentImageIndex === index ? 1 : 0.6,
                                        transition: 'opacity 0.2s',
                                        '&:hover': { opacity: 1 }
                                    }}
                                    onClick={() => setCurrentImageIndex(index)}
                                >
                                    <img
                                        src={`${process.env.REACT_APP_BACKEND_URL}/uploads/${image.file_path}`}
                                        alt={`${listing.title} ${index + 1}`}
                                        style={{
                                            height: '100%',
                                            objectFit: 'cover'
                                        }}
                                    />
                                </ImageListItem>
                            ))}
                        </ImageList>
                    )}

                    {/* Описание объявления */}
                    <Box sx={{ mt: 4 }}>
                        <Typography variant="h4" gutterBottom>
                            {listing.title}
                        </Typography>

                        <Stack direction="row" spacing={2} sx={{ mb: 2 }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', color: 'text.secondary' }}>
                                <MapPin size={18} style={{ marginRight: 4 }} />
                                <Typography>
                                    {listing.location || `${listing.city}, ${listing.country}`}
                                </Typography>
                            </Box>
                            <Box sx={{ display: 'flex', alignItems: 'center', color: 'text.secondary' }}>
                                <Calendar size={18} style={{ marginRight: 4 }} />
                                <Typography>
                                    {new Date(listing.created_at).toLocaleDateString()}
                                </Typography>
                            </Box>
                            <Box
                                component="button"
                                onClick={scrollToReviews}
                                sx={{
                                    background: 'none',
                                    border: 'none',
                                    color: 'primary.main',
                                    cursor: 'pointer',
                                    textDecoration: 'underline',
                                    padding: 0,
                                    display: 'flex',
                                    alignItems: 'center',
                                    '&:hover': {
                                        color: 'primary.dark'
                                    }
                                }}
                            >
                                {reviewsCount} отзывов
                            </Box>
                        </Stack>
                        <Typography variant="body1" sx={{ mb: 4 }}>
                            {listing.description}
                        </Typography>

                        {/* Отзывы */}
                        <Box id="reviews-section" ref={reviewsRef} sx={{ mt: 4 }}>
                            <ReviewsSection
                                entityType="listing"
                                entityId={parseInt(id)}
                                entityTitle={listing.title}
                                canReview={user && user.id !== listing.user_id}
                                onReviewsCountChange={setReviewsCount}
                            />
                        </Box>
                    </Box>
                </Grid>

                {/* Правая панель */}
                <Grid item xs={12} md={4}>
                    <Box sx={{ position: 'sticky', top: 24 }}>
                        {/* Карточка с ценой и контактами */}
                        <Card elevation={2}>
                            <CardContent>
                                <Typography variant="h4" gutterBottom>
                                    {formatPrice(listing.price)}
                                </Typography>

                                <Stack direction="row" spacing={1} sx={{ mb: 3 }}>
                                    <Button
                                        variant="contained"
                                        fullWidth
                                        startIcon={!isMobile && <Phone />}
                                        onClick={() => {
                                            // Логика для звонка
                                        }}
                                    >
                                        {isMobile ? <Phone size={20} /> : 'Позвонить'}
                                    </Button>
                                    <ChatButton listing={listing} isMobile={isMobile} />
                                </Stack>

                                <Stack direction="row" spacing={1}>
                                    <Button
                                        variant="outlined"
                                        fullWidth
                                        startIcon={!isMobile && <Heart fill={listing?.is_favorite ? 'currentColor' : 'none'} />}
                                        onClick={handleFavoriteClick}
                                    >
                                        {isMobile ? (
                                            <Heart
                                                size={20}
                                                fill={listing?.is_favorite ? 'currentColor' : 'none'}
                                            />
                                        ) : listing?.is_favorite ? 'В избранном' : 'В избранное'}
                                    </Button>
                                    <Button
                                        variant="outlined"
                                        fullWidth
                                        startIcon={!isMobile && <Share2 />}
                                        onClick={() => {
                                            // Здесь можно добавить логику для шаринга
                                        }}
                                    >
                                        {isMobile ? <Share2 size={20} /> : 'Поделиться'}
                                    </Button>
                                </Stack>
                            </CardContent>
                        </Card>
                        {listing.latitude && listing.longitude ? (
                            listing.show_on_map ? (
                                <>
                                    <Card elevation={2} sx={{ mt: 2 }}>
                                        <CardContent sx={{ p: 1 }}>
                                            <MiniMap
                                                latitude={listing.latitude}
                                                longitude={listing.longitude}
                                                title={listing.title}
                                                address={listing.location}
                                                onClick={() => setIsMapExpanded(true)}
                                                onExpand={() => setIsMapExpanded(true)}
                                            />
                                        </CardContent>
                                    </Card>

                                    <Modal
                                        open={isMapExpanded}
                                        onClose={() => setIsMapExpanded(false)}
                                        sx={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            p: 2
                                        }}
                                    >
                                        <Paper
                                            sx={{
                                                position: 'relative',
                                                width: '100%',
                                                maxWidth: 1200,
                                                maxHeight: '90vh',
                                                overflow: 'hidden'
                                            }}
                                        >
                                            <GoogleMap
                                                mapContainerStyle={{
                                                    width: '100%',
                                                    height: '80vh'
                                                }}
                                                center={{
                                                    lat: listing.latitude,
                                                    lng: listing.longitude
                                                }}
                                                zoom={15}
                                                options={{
                                                    zoomControl: true,
                                                    mapTypeControl: true,
                                                    streetViewControl: true,
                                                    gestureHandling: "greedy"
                                                }}
                                            >
                                                <Marker
                                                    position={{
                                                        lat: listing.latitude,
                                                        lng: listing.longitude
                                                    }}
                                                    title={listing.title}
                                                />
                                            </GoogleMap>
                                        </Paper>
                                    </Modal>
                                </>
                            ) : (
                                <Card elevation={2} sx={{ mt: 2 }}>
                                    <CardContent>
                                        <Stack direction="row" spacing={1} alignItems="center">
                                            <MapPin size={18} />
                                            <Typography>
                                                {`${listing.city}, ${listing.country}`}
                                            </Typography>
                                        </Stack>
                                    </CardContent>
                                </Card>
                            )
                        ) : null}
                        {/* Карточка продавца */}
                        <Card elevation={2} sx={{ mt: 2 }}>
                            <CardContent>
                                <Typography variant="h6" gutterBottom>
                                    Продавец
                                </Typography>
                                <Stack direction="row" spacing={2} alignItems="center">
                                    <Avatar
                                        src={listing.user?.picture_url}
                                        alt={listing.user?.name}
                                        sx={{ width: 56, height: 56 }}
                                    />
                                    <Box>
                                        <Typography variant="subtitle1">
                                            {listing.user?.name}
                                        </Typography>
                                        <Typography variant="body2" color="text.secondary">
                                            На сайте с {new Date(listing.user?.created_at).toLocaleDateString()}
                                        </Typography>
                                    </Box>
                                </Stack>
                            </CardContent>
                        </Card>
                    </Box>
                </Grid>
            </Grid>
        </Container>
    );
};

export default ListingDetailsPage;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/pages/marketplace/CreateListingPage.js ===

import React, { useState, useEffect } from "react";
import {
    Container,
    TextField,
    Button,
    Typography,
    Box,
    Alert,
    Grid,
    FormControlLabel,
    Switch,
    IconButton,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Paper,
    Modal
} from "@mui/material";
import { Delete as DeleteIcon, CloudUpload as CloudUploadIcon } from '@mui/icons-material';
import LocationPicker from '../../components/global/LocationPicker';
import MiniMap from '../../components/maps/MiniMap';
import { GoogleMap, Marker } from '@react-google-maps/api';
import axios from "../../api/axios";

const CreateListing = () => {
    const [listing, setListing] = useState({
        title: "",
        description: "",
        price: 0,
        category_id: "",
        condition: "new",
        location: "",
        city: "",
        country: "",
        show_on_map: true,
        latitude: null,
        longitude: null
    });

    const [images, setImages] = useState([]);
    const [previewUrls, setPreviewUrls] = useState([]);
    const [categories, setCategories] = useState([]);
    const [error, setError] = useState("");
    const [success, setSuccess] = useState(false);
    const [showExpandedMap, setShowExpandedMap] = useState(false);

    useEffect(() => {
        const fetchCategories = async () => {
            try {
                const response = await axios.get("/api/v1/marketplace/categories");
                setCategories(response.data.data || []);
            } catch (err) {
                setError("Ошибка при загрузке категорий");
            }
        };
        fetchCategories();
    }, []);

    const handleImageChange = (e) => {
        const files = Array.from(e.target.files || []);
        if (files.length === 0) return;

        const validFiles = files.filter(file => {
            if (!file.type.startsWith('image/')) {
                setError("Можно загружать только изображения");
                return false;
            }
            if (file.size > 15 * 1024 * 1024) {
                setError("Размер файла не должен превышать 5MB");
                return false;
            }
            return true;
        });

        if (validFiles.length === 0) return;

        setImages(prev => [...prev, ...validFiles]);

        validFiles.forEach(file => {
            const reader = new FileReader();
            reader.onloadend = () => {
                setPreviewUrls(prev => [...prev, reader.result]);
            };
            reader.readAsDataURL(file);
        });
    };

    const handleLocationSelect = (location) => {
        setListing(prev => ({
            ...prev,
            latitude: location.latitude,
            longitude: location.longitude,
            location: location.formatted_address,
            city: location.address_components?.city || '',
            country: location.address_components?.country || ''
        }));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError("");
        setSuccess(false);

        try {
            const listingData = {
                ...listing,
                price: parseFloat(listing.price)
            };

            const response = await axios.post("/api/v1/marketplace/listings", listingData);
            const listingId = response.data.data.id;

            if (images.length > 0) {
                const formData = new FormData();
                images.forEach((image, index) => {
                    formData.append('images', image);
                    if (index === 0) {
                        formData.append('main_image_index', '0');
                    }
                });

                await axios.post(`/api/v1/marketplace/listings/${listingId}/images`, formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                });
            }

            setSuccess(true);
            setListing({
                title: "",
                description: "",
                price: 0,
                category_id: "",
                condition: "new",
                location: "",
                city: "",
                country: "",
                latitude: null,
                longitude: null
            });
            setImages([]);
            setPreviewUrls([]);

        } catch (error) {
            console.error('Ошибка при создании объявления:', error);
            setError(error.response?.data?.error || "Ошибка при создании объявления");
        }
    };

    return (
        <Container maxWidth="md">
            <Box sx={{ mt: 4, mb: 4 }}>
                <Typography variant="h4" gutterBottom>
                    Создать объявление
                </Typography>

                {error && (
                    <Alert severity="error" sx={{ mb: 2 }}>
                        {error}
                    </Alert>
                )}

                {success && (
                    <Alert severity="success" sx={{ mb: 2 }}>
                        Объявление успешно создано!
                    </Alert>
                )}

                <Paper sx={{ p: 3 }}>
                    <form onSubmit={handleSubmit}>
                        <Grid container spacing={3}>
                            <Grid item xs={12}>
                                <TextField
                                    label="Заголовок"
                                    fullWidth
                                    required
                                    value={listing.title}
                                    onChange={(e) => setListing({ ...listing, title: e.target.value })}
                                />
                            </Grid>

                            <Grid item xs={12}>
                                <TextField
                                    label="Описание"
                                    fullWidth
                                    required
                                    multiline
                                    rows={4}
                                    value={listing.description}
                                    onChange={(e) => setListing({ ...listing, description: e.target.value })}
                                />
                            </Grid>

                            <Grid item xs={12} sm={6}>
                                <TextField
                                    label="Цена"
                                    type="number"
                                    fullWidth
                                    required
                                    value={listing.price}
                                    onChange={(e) => setListing({ ...listing, price: e.target.value })}
                                />
                            </Grid>

                            <Grid item xs={12} sm={6}>
                                <FormControl fullWidth required>
                                    <InputLabel>Категория</InputLabel>
                                    <Select
                                        value={listing.category_id}
                                        onChange={(e) => setListing({ ...listing, category_id: e.target.value })}
                                    >
                                        {categories.map((category) => (
                                            <MenuItem key={category.id} value={category.id}>
                                                {category.name}
                                            </MenuItem>
                                        ))}
                                    </Select>
                                </FormControl>
                            </Grid>

                            <Grid item xs={12} sm={6}>
                                <FormControl fullWidth required>
                                    <InputLabel>Состояние</InputLabel>
                                    <Select
                                        value={listing.condition}
                                        onChange={(e) => setListing({ ...listing, condition: e.target.value })}
                                    >
                                        <MenuItem value="new">Новое</MenuItem>
                                        <MenuItem value="used">Б/у</MenuItem>
                                    </Select>
                                </FormControl>
                            </Grid>

                            <Grid item xs={12}>
                                <Typography variant="h6" gutterBottom>
                                    Местоположение
                                </Typography>
                                <LocationPicker onLocationSelect={handleLocationSelect} />
                                
                                {listing.latitude && listing.longitude && (
                                    <Box sx={{ mt: 2 }}>
                                        <MiniMap
                                            latitude={listing.latitude}
                                            longitude={listing.longitude}
                                            address={listing.location}
                                            onExpand={() => setShowExpandedMap(true)}
                                        />
                                    </Box>
                                )}

                                {showExpandedMap && listing.latitude && listing.longitude && (
                                    <Modal
                                        open={showExpandedMap}
                                        onClose={() => setShowExpandedMap(false)}
                                        sx={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            p: 2
                                        }}
                                    >
                                        <Paper
                                            sx={{
                                                position: 'relative',
                                                width: '100%',
                                                maxWidth: 1200,
                                                maxHeight: '90vh',
                                                overflow: 'hidden'
                                            }}
                                        >
                                            <GoogleMap
                                                mapContainerStyle={{
                                                    width: '100%',
                                                    height: '80vh'
                                                }}
                                                center={{
                                                    lat: listing.latitude,
                                                    lng: listing.longitude
                                                }}
                                                zoom={15}
                                                options={{
                                                    zoomControl: true,
                                                    mapTypeControl: true,
                                                    streetViewControl: true,
                                                    gestureHandling: "greedy"
                                                }}
                                            >
                                                <Marker
                                                    position={{
                                                        lat: listing.latitude,
                                                        lng: listing.longitude
                                                    }}
                                                    title={listing.title}
                                                />
                                            </GoogleMap>
                                        </Paper>
                                    </Modal>
                                )}
                                
                                <FormControlLabel
                                    control={
                                        <Switch
                                            checked={listing.show_on_map}
                                            onChange={(e) => setListing(prev => ({
                                                ...prev,
                                                show_on_map: e.target.checked
                                            }))}
                                        />
                                    }
                                    label="Показывать местоположение на карте"
                                    sx={{ mt: 1 }}
                                />
                            </Grid>

                            <Grid item xs={12}>
                                <Typography variant="h6" gutterBottom>
                                    Фотографии
                                </Typography>
                                <Button
                                    variant="contained"
                                    component="label"
                                    startIcon={<CloudUploadIcon />}
                                >
                                    Загрузить фото
                                    <input
                                        type="file"
                                        hidden
                                        multiple
                                        accept="image/*"
                                        onChange={handleImageChange}
                                    />
                                </Button>

                                <Box sx={{ mt: 2, display: 'flex', gap: 2, flexWrap: 'wrap' }}>
                                    {previewUrls.map((url, index) => (
                                        <Box
                                            key={index}
                                            sx={{ position: 'relative', width: 100, height: 100 }}
                                        >
                                            <img
                                                src={url}
                                                alt={`Preview ${index}`}
                                                style={{
                                                    width: '100%',
                                                    height: '100%',
                                                    objectFit: 'cover',
                                                    borderRadius: '4px'
                                                }}
                                            />
                                            <IconButton
                                                size="small"
                                                sx={{
                                                    position: 'absolute',
                                                    top: -10,
                                                    right: -10,
                                                    bgcolor: 'background.paper'
                                                }}
                                                onClick={() => {
                                                    setImages(prev => prev.filter((_, i) => i !== index));
                                                    setPreviewUrls(prev => prev.filter((_, i) => i !== index));
                                                }}
                                            >
                                                <DeleteIcon />
                                            </IconButton>
                                        </Box>
                                    ))}
                                </Box>
                            </Grid>

                            <Grid item xs={12}>
                                <Button
                                    type="submit"
                                    variant="contained"
                                    color="primary"
                                    fullWidth
                                    size="large"
                                    disabled={!listing.title || !listing.description || !listing.category_id || listing.price <= 0}
                                >
                                    Создать объявление
                                </Button>
                            </Grid>
                        </Grid>
                    </form>
                </Paper>
            </Box>
        </Container>
    );
};

export default CreateListing;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/pages/marketplace/ChatPage.js ===

// frontend/hostel-frontend/src/pages/marketplace/ChatPage.js
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
    Container,
    Grid,
    Box,
    useTheme,
    useMediaQuery,
    CircularProgress,
    Alert,
    Paper,         
    Typography,    
    Button        
} from '@mui/material';
import {
    ChatWindow,
    ChatList,
    ChatHeader,
    EmptyState,
} from '../../components/marketplace/chat/ChatComponents';
import ChatService from '../../components/marketplace/chat/ChatService';
import axios from '../../api/axios';
import { useAuth } from '../../contexts/AuthContext';

const ChatPage = () => {
    const { listingId } = useParams();
    const navigate = useNavigate();
    const { user, loading: authLoading, login } = useAuth();
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));

    const [chats, setChats] = useState([]);
    const [selectedChat, setSelectedChat] = useState(null);
    const [messages, setMessages] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    const chatServiceRef = useRef(null);
    const messageEndRef = useRef(null);

    // Инициализация чат-сервиса
    useEffect(() => {
        if (!user?.id) {
            setError('Необходима авторизация');
            setLoading(false);
            return;
        }

        chatServiceRef.current = new ChatService(user.id);

        return () => {
            if (chatServiceRef.current) {
                chatServiceRef.current.disconnect();
            }
        };
    }, [user?.id]);

    // Загрузка списка чатов
    const fetchChats = useCallback(async () => {
        try {
            const response = await axios.get('/api/v1/marketplace/chat');
            const chatsData = response.data?.data || [];
            setChats(chatsData);

            // Если есть listingId в URL, выбираем соответствующий чат
            if (listingId) {
                const chat = chatsData.find(c => c.listing_id === parseInt(listingId));
                if (chat) {
                    setSelectedChat(chat);
                }
            }
        } catch (error) {
            console.error('Ошибка загрузки чатов:', error);
            setError('Не удалось загрузить список чатов');
        } finally {
            setLoading(false);
        }
    }, [listingId]);

    // Загрузка сообщений выбранного чата
    const fetchMessages = useCallback(async (chatId) => {
        if (!chatServiceRef.current) {
            throw new Error('ChatService не инициализирован');
        }

        try {
            const messages = await chatServiceRef.current.getMessageHistory(chatId);
            return messages;
        } catch (error) {
            console.error('Ошибка загрузки сообщений:', error);
            throw error;
        }
    }, []);

    // Обработка выбора чата
    const handleSelectChat = useCallback(async (chat) => {
        if (!chat?.id || !chat?.listing_id) {
            console.error('Некорректные данные чата:', chat);
            return;
        }
    
        setSelectedChat(chat);
        setLoading(true);
        setMessages([]);
    
        try {
            // Загружаем сообщения сразу после установки чата
            const loadedMessages = await chatServiceRef.current?.getMessageHistory(chat.id, chat.listing_id);
            if (Array.isArray(loadedMessages) && loadedMessages.length > 0) {
                setMessages(loadedMessages);
            }
        } catch (error) {
            console.error('Ошибка при загрузке сообщений:', error);
            setError('Не удалось загрузить сообщения');
        } finally {
            setLoading(false);
        }
    }, []);

    // Инициализация WebSocket и загрузка данных
    useEffect(() => {
        if (chatServiceRef.current) {
            chatServiceRef.current.connect();

            const unsubscribe = chatServiceRef.current.onMessage((message) => {
                console.log('Получено новое сообщение:', message);

                // Проверяем, относится ли сообщение к текущему чату
                if (selectedChat && message.chat_id === selectedChat.id) {
                    setMessages(prev => {
                        // Проверяем наличие дубликата
                        if (prev.some(m => m.id === message.id)) {
                            return prev;
                        }

                        // Добавляем новое сообщение и сортируем
                        const updatedMessages = [...prev, {
                            ...message,
                            sender: message.sender || {},
                            receiver: message.receiver || {},
                            is_read: message.is_read || false,
                            created_at: message.created_at || new Date().toISOString()
                        }];

                        return updatedMessages.sort((a, b) =>
                            new Date(a.created_at) - new Date(b.created_at)
                        );
                    });
                }
            });

            return () => unsubscribe();
        }
    }, [selectedChat]);

    // Загрузка чатов при монтировании
    useEffect(() => {
        fetchChats();
    }, [fetchChats]);
    useEffect(() => {
        if (selectedChat?.id && chatServiceRef.current) {
             chatServiceRef.current.connect();
        }
    }, [selectedChat?.id]);

    useEffect(() => {
        if (selectedChat && messages.length > 0) {
            const unreadMessages = messages.filter(
                msg => !msg.is_read && msg.receiver_id === user?.id
            );

            if (unreadMessages.length > 0) {
                const messageIds = unreadMessages.map(msg => msg.id);
                chatServiceRef.current?.markMessagesAsRead(messageIds);
            }
        }
    }, [selectedChat, messages, user?.id]);

    // Прокрутка к последнему сообщению
    useEffect(() => {
        messageEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    // Отправка сообщения
    const handleSendMessage = async (content) => {
        if (!selectedChat || !user?.id) {
            setError('Недостаточно данных для отправки сообщения');
            return;
        }

        try {
            const message = {
                chat_id: selectedChat.id,
                listing_id: selectedChat.listing_id,
                receiver_id: selectedChat.seller_id === user.id ?
                    selectedChat.buyer_id : selectedChat.seller_id,
                content: content
            };

            await chatServiceRef.current.sendMessage(message);
        } catch (error) {
            console.error('Ошибка отправки сообщения:', error);
            setError('Не удалось отправить сообщение');
        }
    };

    // Архивация чата
    const handleArchiveChat = async (chatId) => {
        try {
            await axios.post(`/api/v1/marketplace/chat/${chatId}/archive`);
            await fetchChats();
            if (selectedChat?.id === chatId) {
                setSelectedChat(null);
                setMessages([]);
            }
        } catch (error) {
            console.error('Ошибка архивации чата:', error);
            setError('Не удалось архивировать чат');
        }
    };

    if (authLoading) {
        return (
            <Box display="flex" justifyContent="center" alignItems="center" minHeight="200px">
                <CircularProgress />
            </Box>
        );
    }

    if (!user) {
        return (
            <Container maxWidth="md" sx={{ mt: 4 }}>
                <Paper sx={{ p: 3, textAlign: 'center' }}>
                    <Typography variant="h6" gutterBottom>
                        Необходима авторизация
                    </Typography>
                    <Typography color="text.secondary" paragraph>
                        Для доступа к чату необходимо войти в систему
                    </Typography>
                    <Button 
                        variant="contained" 
                        onClick={() => {
                            const returnUrl = window.location.pathname;
                            const encodedReturnUrl = encodeURIComponent(returnUrl);
                            login(`?returnTo=${encodedReturnUrl}`);
                        }}
                    >
                        Войти
                    </Button>
                </Paper>
            </Container>
        );
    }

    // Мобильная версия
    if (isMobile) {
        return (
            <Box sx={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
                {selectedChat ? (
                    <>
                        <ChatHeader
                            chat={selectedChat}
                            onBack={() => setSelectedChat(null)}
                        />
                        <Box sx={{ flex: 1, overflow: 'hidden' }}>
                            <ChatWindow
                                messages={messages}
                                onSendMessage={handleSendMessage}
                                currentUser={user}
                            />
                        </Box>
                    </>
                ) : (
                    <>
                        <ChatList
                            chats={chats}
                            selectedChatId={selectedChat?.id}
                            onSelectChat={handleSelectChat}
                            onArchiveChat={handleArchiveChat}
                        />
                        {!loading && chats.length === 0 && (
                            <EmptyState text="У вас пока нет сообщений" />
                        )}
                    </>
                )}
            </Box>
        );
    }

    // Десктопная версия
    return (
        <Container maxWidth="xl" sx={{ py: 4, height: 'calc(100vh - 64px)' }}>
            <Grid container spacing={2} sx={{ height: '100%' }}>
                {/* Список чатов */}
                <Grid item xs={12} md={4} sx={{ height: '100%' }}>
                    <ChatList
                        chats={chats}
                        selectedChatId={selectedChat?.id}
                        onSelectChat={handleSelectChat}
                        onArchiveChat={handleArchiveChat}
                    />
                    {!loading && chats.length === 0 && (
                        <EmptyState text="У вас пока нет сообщений" />
                    )}
                </Grid>

                {/* Окно чата */}
                <Grid item xs={12} md={8} sx={{ height: '100%' }}>
                    {selectedChat ? (
                        <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                            <ChatHeader chat={selectedChat} />
                            <Box sx={{ flex: 1, overflow: 'hidden' }}>
                                <ChatWindow
                                    messages={messages}
                                    onSendMessage={handleSendMessage}
                                    currentUser={user}
                                />
                                <div ref={messageEndRef} />
                            </Box>
                        </Box>
                    ) : (
                        <EmptyState text="Выберите чат для начала общения" />
                    )}
                </Grid>
            </Grid>

            {error && (
                <Alert
                    severity="error"
                    sx={{
                        position: 'fixed',
                        bottom: 16,
                        right: 16,
                        maxWidth: 'calc(100% - 32px)'
                    }}
                    onClose={() => setError(null)}
                >
                    {error}
                </Alert>
            )}
        </Container>
    );
};

export default ChatPage;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/pages/marketplace/MyListingsPage.js ===

// frontend/hostel-frontend/src/pages/marketplace/MyListingsPage.js
import React, { useState, useEffect } from 'react';
import {
    Container,
    Typography,
    Grid,
    Box,
    CircularProgress,
    Alert,
    Button
} from '@mui/material';
import { Plus } from 'lucide-react';
import { Link } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';
import ListingCard from '../../components/marketplace/ListingCard';
import axios from '../../api/axios';

const MyListingsPage = () => {
    const [listings, setListings] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const { user } = useAuth();

    useEffect(() => {
        const fetchMyListings = async () => {
            try {
                setLoading(true);
                const response = await axios.get('/api/v1/marketplace/listings', {
                    withCredentials: true // Added this to ensure authentication
                });

                console.log('Listings API Response:', response);

                if (response.data?.data?.data && Array.isArray(response.data.data.data)) {
                    // Filter listings by user ID
                    const userListings = response.data.data.data.filter(listing =>
                        String(listing.user_id) === String(user?.id)
                    );
                    setListings(userListings);
                } else {
                    console.log('Unexpected listings data structure:', response.data);
                    setListings([]);
                }
            } catch (err) {
                console.error('Error fetching listings:', err);
                setError('Не удалось загрузить объявления');
            } finally {
                setLoading(false);
            }
        };

        if (user?.id) {
            fetchMyListings();
        } else {
            setLoading(false); // Останавливаем загрузку, если нет пользователя
        }
    }, [user]);

    if (loading) {
        return (
            <Box display="flex" justifyContent="center" p={4}>
                <CircularProgress />
            </Box>
        );
    }

    if (error) {
        return (
            <Container>
                <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>
            </Container>
        );
    }

    return (
        <Container sx={{ py: 4 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
                <Typography variant="h4" component="h1">
                    Мои объявления
                </Typography>
                <Button
                    component={Link}
                    to="/marketplace/create"
                    variant="contained"
                    startIcon={<Plus />}
                >
                    Создать объявление
                </Button>
            </Box>

            <Grid container spacing={3}>
                {listings.length === 0 ? (
                    <Grid item xs={12}>
                        <Alert severity="info">
                            У вас пока нет объявлений. Создайте свое первое объявление прямо сейчас!
                        </Alert>
                    </Grid>
                ) : (
                    listings.map((listing) => (
                        <Grid item xs={12} sm={6} md={4} key={listing.id}>
                            <Link
                                to={`/marketplace/listings/${listing.id}`}
                                style={{ textDecoration: 'none' }}
                            >
                                <ListingCard listing={listing} />
                            </Link>
                        </Grid>
                    ))
                )}
            </Grid>
        </Container>
    );
};

export default MyListingsPage;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/pages/marketplace/FavoriteListingsPage.js ===

import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import {
    Container,
    Typography,
    Grid,
    Box,
    CircularProgress,
    Alert,
} from '@mui/material';
import ListingCard from '../../components/marketplace/ListingCard';
import axios from '../../api/axios';
import { useAuth } from '../../contexts/AuthContext';

const FavoriteListingsPage = () => {
    const [listings, setListings] = useState(null); // Изменили на null
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const { user } = useAuth();

    useEffect(() => {
        const fetchFavorites = async () => {
            try {
                setLoading(true);
                const response = await axios.get('/api/v1/marketplace/favorites');
                setListings(response.data.data);
            } catch (err) {
                console.error('Error fetching favorites:', err);
                setError('Не удалось загрузить избранные объявления');
                setListings([]); // Устанавливаем пустой массив в случае ошибки
            } finally {
                setLoading(false);
            }
        };

        if (user) {
            fetchFavorites();
        } else {
            setListings([]); // Если пользователь не авторизован, устанавливаем пустой массив
            setLoading(false);
        }
    }, [user]);

    if (loading) {
        return (
            <Box display="flex" justifyContent="center" p={4}>
                <CircularProgress />
            </Box>
        );
    }

    if (!user) {
        return (
            <Container sx={{ py: 4 }}>
                <Alert severity="info">
                    Для просмотра избранных объявлений необходимо авторизоваться
                </Alert>
            </Container>
        );
    }

    return (
        <Container sx={{ py: 4 }}>
            <Typography variant="h4" gutterBottom>
                Избранные объявления
            </Typography>

            {error && (
                <Alert severity="error" sx={{ mb: 2 }}>
                    {error}
                </Alert>
            )}

            {listings && listings.length === 0 ? (
                <Alert severity="info">
                    У вас пока нет избранных объявлений
                </Alert>
            ) : (
                <Grid container spacing={3}>
                    {listings && listings.map((listing) => (
                        <Grid item xs={12} sm={6} md={4} key={listing.id}>
                            <Link
                                to={`/marketplace/listings/${listing.id}`}
                                style={{ textDecoration: 'none' }}
                            >
                                <ListingCard listing={listing} />
                            </Link>
                        </Grid>
                    ))}
                </Grid>
            )}
        </Container>
    );
};

export default FavoriteListingsPage;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/pages/global/HomePage.js ===

import React from "react";
import { Container } from "@mui/material";
import RoomList from "../../components/accommodation/RoomList";

const HomePage = () => (
  <Container sx={{ marginTop: 4 }}>
    <RoomList />
  </Container>
);

export default HomePage;

=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/pages/global/AdminPanelPage.js ===

import React from "react";
import AddRoom from "../../components/accommodation/AddRoom";
import AddUser from "../../components/user/AddUser";
import AddBooking from "../../components/accommodation/AddBooking";

const AdminPanelPage = () => (
  <div>
    <h1>Админ-панель</h1>
    <AddRoom />
    <AddUser />
    <AddBooking />
  </div>
);

export default AdminPanelPage;

=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/pages/user/AddUserPage.js ===

import React from "react";
import AddUser from "../../components/user/AddUser";

const AddUserPage = () => <AddUser />;

export default AddUserPage;

=== /data/proj/hostel-booking-system/backend/migrations/0004_update_constraints.down.sql ===


-- Remove the NOT NULL constraint.
ALTER TABLE bookings
ALTER COLUMN user_id DROP NOT NULL,
ALTER COLUMN room_id DROP NOT NULL;

-- Drop the added indexes.
DROP INDEX IF EXISTS idx_bookings_user_id;
DROP INDEX IF EXISTS idx_bookings_room_id;

=== /data/proj/hostel-booking-system/backend/migrations/0025_add_car_features.down.sql ===

-- backend/migrations/0025_update_car_features.down.sql
DROP TABLE IF EXISTS car_feature_links;
DROP TABLE IF EXISTS car_features;
=== /data/proj/hostel-booking-system/backend/migrations/0001_create_tables.up.sql ===

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(150) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE rooms (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    capacity INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE bookings (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- Добавить ограничение на длину email
ALTER TABLE users
    ADD CONSTRAINT valid_email 
    CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

-- Добавить ограничение на минимальную длину имени
ALTER TABLE users
    ADD CONSTRAINT valid_name 
    CHECK (length(name) >= 2);
=== /data/proj/hostel-booking-system/backend/migrations/0034_add_show_on_map.down.sql ===

ALTER TABLE marketplace_listings
DROP COLUMN show_on_map;
=== /data/proj/hostel-booking-system/backend/migrations/0018_add_bed_images.up.sql ===

CREATE TABLE bed_images (
    id SERIAL PRIMARY KEY,
    bed_id INT NOT NULL REFERENCES beds(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_bed_images_bed_id ON bed_images(bed_id);
=== /data/proj/hostel-booking-system/backend/migrations/0016_fix_bed_availability.down.sql ===

DROP FUNCTION IF EXISTS get_beds_availability;
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds;
=== /data/proj/hostel-booking-system/backend/migrations/0034_add_show_on_map.up.sql ===

-- /backend/migrations/0034_add_show_on_map.up.sql
ALTER TABLE marketplace_listings
ADD COLUMN show_on_map BOOLEAN NOT NULL DEFAULT true;
=== /data/proj/hostel-booking-system/backend/migrations/0002_add_price_per_night.up.sql ===

ALTER TABLE rooms 
    ADD COLUMN price_per_night NUMERIC(10, 2) NOT NULL DEFAULT 0 
    CHECK (price_per_night >= 0);
CREATE INDEX idx_users_email ON users(email);

-- Добавить составной индекс для фильтрации комнат
CREATE INDEX idx_rooms_capacity_price ON rooms(capacity, price_per_night);
=== /data/proj/hostel-booking-system/backend/migrations/0015_fix_available_beds.up.sql ===

-- Удаляем старый триггер и функцию
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds();

-- Создаем улучшенную функцию обновления доступных мест
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    -- Обновляем количество доступных мест для комнаты, связанной с бронированием
    WITH bed_count AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        LEFT JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE 
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = r.total_beds - COALESCE(bc.booked_beds, 0)
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем новый триггер
CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();

-- Создаем функцию для получения количества доступных мест на конкретные даты
CREATE OR REPLACE FUNCTION get_available_beds(
    room_id_param INTEGER,
    start_date_param DATE,
    end_date_param DATE
)
RETURNS INTEGER AS $$
DECLARE
    total_beds INTEGER;
    booked_beds INTEGER;
BEGIN
    -- Получаем общее количество кроватей
    SELECT total_beds INTO total_beds
    FROM rooms
    WHERE id = room_id_param;

    -- Считаем количество забронированных кроватей на указанные даты
    SELECT COUNT(DISTINCT bb.bed_id) INTO booked_beds
    FROM bed_bookings bb
    JOIN beds b ON bb.bed_id = b.id
    WHERE b.room_id = room_id_param
    AND bb.status = 'confirmed'
    AND bb.start_date <= end_date_param
    AND bb.end_date >= start_date_param;

    -- Возвращаем разницу
    RETURN total_beds - COALESCE(booked_beds, 0);
END;
$$ LANGUAGE plpgsql;

-- Функция инициализации доступных мест
CREATE OR REPLACE FUNCTION initialize_available_beds()
RETURNS void AS $$
BEGIN
    WITH bed_count AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        LEFT JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE 
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = r.total_beds - COALESCE(bc.booked_beds, 0)
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';
END;
$$ LANGUAGE plpgsql;

-- Выполняем начальную инициализацию
SELECT initialize_available_beds();
=== /data/proj/hostel-booking-system/backend/migrations/0006_add_room_address.down.sql ===

-- 0006_add_room_address.down.sql
DROP INDEX IF EXISTS idx_rooms_city;
DROP INDEX IF EXISTS idx_rooms_country;

ALTER TABLE rooms
    DROP COLUMN address_street,
    DROP COLUMN address_city,
    DROP COLUMN address_state,
    DROP COLUMN address_country,
    DROP COLUMN address_postal_code;
=== /data/proj/hostel-booking-system/backend/migrations/0021_add_google_id_to_users.up.sql ===

ALTER TABLE users 
ADD COLUMN google_id VARCHAR(255) UNIQUE,
ADD COLUMN picture_url TEXT;
=== /data/proj/hostel-booking-system/backend/migrations/0029_marketplace_Reviews.down.sql ===

-- Down миграция:
-- /backend/migrations/0029_create_reviews.down.sql
DROP TRIGGER IF EXISTS update_reviews_updated_at ON reviews;
DROP TRIGGER IF EXISTS update_review_responses_updated_at ON review_responses;
DROP FUNCTION IF EXISTS update_updated_at_column;
DROP FUNCTION IF EXISTS calculate_entity_rating;
DROP TABLE IF EXISTS review_votes;
DROP TABLE IF EXISTS review_responses;
DROP TABLE IF EXISTS reviews;
=== /data/proj/hostel-booking-system/backend/migrations/0021_add_google_id_to_users.down.sql ===

ALTER TABLE users 
DROP COLUMN google_id,
DROP COLUMN picture_url;
=== /data/proj/hostel-booking-system/backend/migrations/0014_add_beds_trigger.down.sql ===

-- Удаляем триггер
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;

-- Удаляем функцию
DROP FUNCTION IF EXISTS update_available_beds();
=== /data/proj/hostel-booking-system/backend/migrations/0026_add_test_cars.down.sql ===

-- backend/migrations/0026_add_test_cars.down.sql
DELETE FROM car_feature_links WHERE car_id IN (SELECT id FROM cars WHERE make IN ('Axia', 'Velaris', 'Terra', 'Navis'));
DELETE FROM car_images WHERE car_id IN (SELECT id FROM cars WHERE make IN ('Axia', 'Velaris', 'Terra', 'Navis'));
DELETE FROM cars WHERE make IN ('Axia', 'Velaris', 'Terra', 'Navis');
=== /data/proj/hostel-booking-system/backend/migrations/0014_add_beds_trigger.up.sql ===

-- Создаем функцию для подсчета доступных кроватей
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
            AND (
                (start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE)
            )
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Создаем триггер для таблицы bed_bookings
CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();
=== /data/proj/hostel-booking-system/backend/migrations/0005_add_status_and_indexes.down.sql ===

-- 0005_add_status_and_indexes.down.sql
DROP INDEX IF EXISTS idx_bookings_status;
DROP INDEX IF EXISTS idx_bookings_dates;
ALTER TABLE bookings DROP COLUMN status;
=== /data/proj/hostel-booking-system/backend/migrations/0024_add_car.down.sql ===

-- backend/migrations/0024_add_car.down.sql
DROP TABLE IF EXISTS car_feature_links;
DROP TABLE IF EXISTS car_features;
DROP TABLE IF EXISTS car_bookings;
DROP TABLE IF EXISTS car_images;
DROP TABLE IF EXISTS cars;
DROP TABLE IF EXISTS car_categories;
=== /data/proj/hostel-booking-system/backend/migrations/0017_add_location_fields.up.sql ===

-- Добавляем поля для координат и форматированного адреса
ALTER TABLE rooms
    ADD COLUMN latitude DECIMAL(10, 8),
    ADD COLUMN longitude DECIMAL(11, 8),
    ADD COLUMN formatted_address TEXT;

-- Индекс для географического поиска
CREATE INDEX idx_rooms_location ON rooms(latitude, longitude);

-- Функция для валидации координат
CREATE OR REPLACE FUNCTION validate_coordinates()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.latitude IS NOT NULL AND (NEW.latitude < -90 OR NEW.latitude > 90) THEN
        RAISE EXCEPTION 'Широта должна быть между -90 и 90';
    END IF;
    IF NEW.longitude IS NOT NULL AND (NEW.longitude < -180 OR NEW.longitude > 180) THEN
        RAISE EXCEPTION 'Долгота должна быть между -180 и 180';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Триггер для валидации координат
CREATE TRIGGER validate_coordinates_trigger
    BEFORE INSERT OR UPDATE ON rooms
    FOR EACH ROW
    EXECUTE FUNCTION validate_coordinates();
=== /data/proj/hostel-booking-system/backend/migrations/0007_add_room_images.down.sql ===

-- 0007_add_room_images.down.sql
DROP TABLE IF EXISTS room_images;
=== /data/proj/hostel-booking-system/backend/migrations/0011_extend_room_types.up.sql ===

ALTER TABLE rooms
    ADD COLUMN accommodation_type VARCHAR(50) NOT NULL DEFAULT 'room'
    CHECK (accommodation_type IN ('bed', 'room', 'apartment')),
    ADD COLUMN is_shared BOOLEAN NOT NULL DEFAULT false,
    ADD COLUMN total_beds INT,
    ADD COLUMN available_beds INT,
    ADD COLUMN has_private_bathroom BOOLEAN NOT NULL DEFAULT true;

CREATE TABLE beds (
    id SERIAL PRIMARY KEY,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    bed_number INT NOT NULL,
    is_available BOOLEAN NOT NULL DEFAULT true,
    price_per_night DECIMAL(10, 2) NOT NULL CHECK (price_per_night >= 0),
    UNIQUE(room_id, bed_number)
);

CREATE TABLE bed_bookings (
    id SERIAL PRIMARY KEY,
    bed_id INT REFERENCES beds(id) ON DELETE CASCADE,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL CHECK (end_date > start_date),
    status VARCHAR(20) NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
=== /data/proj/hostel-booking-system/backend/migrations/0020_add_demo_data.down.sql ===

-- Удаляем демо данные
DELETE FROM bed_images;
DELETE FROM beds;
DELETE FROM room_images;
DELETE FROM rooms;
DELETE FROM users WHERE email = 'demo@example.com';

-- Восстанавливаем старое ограничение
DROP INDEX IF EXISTS unique_main_image_per_room;
ALTER TABLE room_images ADD CONSTRAINT unique_main_image_per_room UNIQUE (room_id, is_main);
=== /data/proj/hostel-booking-system/backend/migrations/0005_add_status_and_indexes.up.sql ===

-- 0005_add_status_and_indexes.up.sql
ALTER TABLE bookings 
    ADD COLUMN status VARCHAR(20) NOT NULL 
    DEFAULT 'pending' 
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

CREATE INDEX idx_bookings_status ON bookings(status);
CREATE INDEX idx_bookings_dates ON bookings(start_date, end_date);
=== /data/proj/hostel-booking-system/backend/migrations/0035_add_marketplace_messages.up.sql ===

-- /backend/migrations/0035_add_marketplace_messages.up.sql

-- Сначала создаем таблицу чатов, так как на нее будут ссылаться сообщения
CREATE TABLE marketplace_chats (
    id SERIAL PRIMARY KEY,
    listing_id INT REFERENCES marketplace_listings(id) ON DELETE CASCADE,
    buyer_id INT REFERENCES users(id),
    seller_id INT REFERENCES users(id),
    last_message_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_archived BOOLEAN DEFAULT false,
    UNIQUE(listing_id, buyer_id, seller_id)
);

-- Затем создаем таблицу сообщений
CREATE TABLE marketplace_messages (
    id SERIAL PRIMARY KEY,
    chat_id INT REFERENCES marketplace_chats(id) ON DELETE CASCADE,
    listing_id INT REFERENCES marketplace_listings(id) ON DELETE CASCADE,
    sender_id INT REFERENCES users(id),
    receiver_id INT REFERENCES users(id),
    content TEXT NOT NULL,
    is_read BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Индексы для оптимизации запросов
CREATE INDEX idx_marketplace_messages_chat ON marketplace_messages(chat_id);
CREATE INDEX idx_marketplace_messages_listing ON marketplace_messages(listing_id);
CREATE INDEX idx_marketplace_messages_sender ON marketplace_messages(sender_id);
CREATE INDEX idx_marketplace_messages_receiver ON marketplace_messages(receiver_id);
CREATE INDEX idx_marketplace_messages_created ON marketplace_messages(created_at);

CREATE INDEX idx_marketplace_chats_buyer ON marketplace_chats(buyer_id);
CREATE INDEX idx_marketplace_chats_seller ON marketplace_chats(seller_id);
CREATE INDEX idx_marketplace_chats_updated ON marketplace_chats(updated_at);

-- Функция для обновления updated_at
CREATE OR REPLACE FUNCTION update_marketplace_chats_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Триггеры для автоматического обновления updated_at
CREATE TRIGGER update_marketplace_chats_timestamp
    BEFORE UPDATE ON marketplace_chats
    FOR EACH ROW
    EXECUTE FUNCTION update_marketplace_chats_updated_at();

CREATE TRIGGER update_marketplace_messages_timestamp
    BEFORE UPDATE ON marketplace_messages
    FOR EACH ROW
    EXECUTE FUNCTION update_marketplace_chats_updated_at();
=== /data/proj/hostel-booking-system/backend/migrations/0018_add_bed_images.down.sql ===

DROP TABLE IF EXISTS bed_images;

=== /data/proj/hostel-booking-system/backend/migrations/0022_update_bed_images.up.sql ===

-- backend/migrations/0022_update_bed_images.up.sql
ALTER TABLE bed_images
ADD COLUMN is_main BOOLEAN DEFAULT false;

CREATE UNIQUE INDEX unique_main_image_per_bed ON bed_images (bed_id) WHERE is_main = true;
=== /data/proj/hostel-booking-system/backend/migrations/0023_update_bed_select.up.sql ===

ALTER TABLE beds ADD COLUMN has_outlet BOOLEAN NOT NULL DEFAULT true;
ALTER TABLE beds ADD COLUMN has_light BOOLEAN NOT NULL DEFAULT true;
ALTER TABLE beds ADD COLUMN has_shelf BOOLEAN NOT NULL DEFAULT true;
ALTER TABLE beds ADD COLUMN bed_type VARCHAR(20) NOT NULL DEFAULT 'single' 
  CHECK (bed_type IN ('top', 'bottom', 'single'));
=== /data/proj/hostel-booking-system/backend/migrations/0013_update_bed_bookings.down.sql ===

-- 0013_update_bed_bookings.down.sql
DROP INDEX IF EXISTS idx_bed_bookings_dates_status;
ALTER TABLE bed_bookings DROP COLUMN IF EXISTS status;
=== /data/proj/hostel-booking-system/backend/migrations/0012_add_accommodation_types.down.sql ===

-- 0012_add_accommodation_types.down.sql
ALTER TABLE bookings DROP COLUMN IF EXISTS status;
=== /data/proj/hostel-booking-system/backend/migrations/0004_update_constraints.up.sql ===


-- Add NOT NULL constraint to ensure data integrity.
ALTER TABLE bookings
ALTER COLUMN user_id SET NOT NULL,
ALTER COLUMN room_id SET NOT NULL;

-- Add an index to optimize queries on bookings table.
CREATE INDEX idx_bookings_user_id ON bookings(user_id);
CREATE INDEX idx_bookings_room_id ON bookings(room_id);

=== /data/proj/hostel-booking-system/backend/migrations/0022_update_bed_images.down.sql ===

-- backend/migrations/0022_update_bed_images.down.sql
DROP INDEX IF EXISTS unique_main_image_per_bed;
ALTER TABLE bed_images DROP COLUMN IF EXISTS is_main;
=== /data/proj/hostel-booking-system/backend/migrations/0019_update_bed_availability_trigger.down.sql ===

CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms r
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
=== /data/proj/hostel-booking-system/backend/migrations/0012_add_accommodation_types.up.sql ===

-- 0012_add_accommodation_types.up.sql
ALTER TABLE bookings
    ADD COLUMN IF NOT EXISTS status VARCHAR(20) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));
=== /data/proj/hostel-booking-system/backend/migrations/0032_extend_user_profile.up.sql ===

-- backend/migrations/0032_extend_user_profile.up.sql
ALTER TABLE users
    ADD COLUMN phone VARCHAR(20),
    ADD COLUMN bio TEXT,
    ADD COLUMN notification_email BOOLEAN DEFAULT true,
    ADD COLUMN notification_push BOOLEAN DEFAULT true,
    ADD COLUMN timezone VARCHAR(50) DEFAULT 'UTC',
    ADD COLUMN last_seen TIMESTAMP,
    ADD COLUMN account_status VARCHAR(20) DEFAULT 'active' 
        CHECK (account_status IN ('active', 'inactive', 'suspended')),
    ADD COLUMN settings JSONB DEFAULT '{}';

-- Индекс для поиска по телефону
CREATE INDEX idx_users_phone ON users(phone);

-- Индекс для статуса аккаунта
CREATE INDEX idx_users_status ON users(account_status);
=== /data/proj/hostel-booking-system/backend/migrations/0032_extend_user_profile.down.sql ===

ALTER TABLE users
    DROP COLUMN IF EXISTS phone,
    DROP COLUMN IF EXISTS bio,
    DROP COLUMN IF EXISTS notification_email,
    DROP COLUMN IF EXISTS notification_push,
    DROP COLUMN IF EXISTS timezone,
    DROP COLUMN IF EXISTS last_seen,
    DROP COLUMN IF EXISTS account_status,
    DROP COLUMN IF EXISTS settings;

DROP INDEX IF EXISTS idx_users_phone;
DROP INDEX IF EXISTS idx_users_status;
=== /data/proj/hostel-booking-system/backend/migrations/0028_marketplace.up.sql ===

-- Категории объявлений
CREATE TABLE marketplace_categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    slug VARCHAR(100) NOT NULL UNIQUE,
    parent_id INT REFERENCES marketplace_categories(id),
    icon VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Объявления
CREATE TABLE marketplace_listings (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id),
    category_id INT REFERENCES marketplace_categories(id),
    title VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(12,2),
    condition VARCHAR(50), -- new, used, etc
    status VARCHAR(20) DEFAULT 'active', -- active, sold, archived
    location VARCHAR(255),
    latitude DECIMAL(10,8),
    longitude DECIMAL(11,8),
    address_city VARCHAR(100),
    address_country VARCHAR(100),
    views_count INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Изображения объявлений
CREATE TABLE marketplace_images (
    id SERIAL PRIMARY KEY,
    listing_id INT REFERENCES marketplace_listings(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    is_main BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Избранное
CREATE TABLE marketplace_favorites (
    user_id INT REFERENCES users(id),
    listing_id INT REFERENCES marketplace_listings(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, listing_id)
);
-- Добавляем основные категории
INSERT INTO marketplace_categories (name, slug, icon) VALUES 
('Электроника', 'electronics', 'phone'),
('Недвижимость', 'real-estate', 'home'),
('Транспорт', 'vehicles', 'car'),
('Работа', 'jobs', 'briefcase'),
('Для дома и дачи', 'home-and-garden', 'couch'),
('Личные вещи', 'personal', 'tshirt'),
('Хобби и отдых', 'hobby', 'camera'),
('Животные', 'pets', 'paw'),
('Бизнес и оборудование', 'business', 'building');

-- Добавляем подкатегории
INSERT INTO marketplace_categories (name, slug, parent_id, icon) 
SELECT 'Телефоны', 'phones', id, 'smartphone' FROM marketplace_categories WHERE slug = 'electronics';

INSERT INTO marketplace_categories (name, slug, parent_id, icon) 
SELECT 'Ноутбуки', 'laptops', id, 'laptop' FROM marketplace_categories WHERE slug = 'electronics';

INSERT INTO marketplace_categories (name, slug, parent_id, icon) 
SELECT 'Квартиры', 'apartments', id, 'apartment' FROM marketplace_categories WHERE slug = 'real-estate';

INSERT INTO marketplace_categories (name, slug, parent_id, icon) 
SELECT 'Дома', 'houses', id, 'house' FROM marketplace_categories WHERE slug = 'real-estate';
-- Добавляем тестовые объявления
INSERT INTO marketplace_listings 
(user_id, category_id, title, description, price, condition, status, location, latitude, longitude, address_city, address_country) 
VALUES
-- Телефоны
(1, (SELECT id FROM marketplace_categories WHERE slug = 'phones'), 
'iPhone 13 Pro Max', 
'Продаю iPhone 13 Pro Max 256GB в идеальном состоянии. Полный комплект, на гарантии.', 
85000, 'used', 'active', 
'Novi Sad, Serbia', 45.2671, 19.8335, 'Novi Sad', 'Serbia'),

-- Ноутбуки
(1, (SELECT id FROM marketplace_categories WHERE slug = 'laptops'),
'MacBook Pro 14" M1 Pro',
'MacBook Pro 14" (2021) с чипом M1 Pro, 16GB RAM, 512GB SSD. Состояние нового.', 
150000, 'used', 'active',
'Novi Sad, Serbia', 45.2551, 19.8452, 'Novi Sad', 'Serbia'),

-- Квартиры
(1, (SELECT id FROM marketplace_categories WHERE slug = 'apartments'),
'3-комнатная квартира в центре',
'Просторная 3-комнатная квартира в историческом центре города. Свежий ремонт, вся инфраструктура рядом.', 
15000000, 'new', 'active',
'Novi Sad, Serbia', 45.2541, 19.8401, 'Novi Sad', 'Serbia'),

-- Дома
(1, (SELECT id FROM marketplace_categories WHERE slug = 'houses'),
'Современный дом с участком',
'Новый двухэтажный дом 200м² с участком 10 соток. Все коммуникации, готов к проживанию.', 
25000000, 'new', 'active',
'Novi Sad, Serbia', 45.2460, 19.8235, 'Novi Sad', 'Serbia');

-- Добавляем изображения для объявлений
INSERT INTO marketplace_images 
(listing_id, file_path, file_name, file_size, content_type, is_main)
VALUES
-- Изображения для iPhone
(1, 'iphone13_1.jpg', 'iphone13_1.jpg', 1024, 'image/jpeg', true),
(1, 'iphone13_2.jpg', 'iphone13_2.jpg', 1024, 'image/jpeg', false),
(1, 'iphone13_3.jpg', 'iphone13_3.jpg', 1024, 'image/jpeg', false),

-- Изображения для MacBook
(2, 'macbook_1.jpg', 'macbook_1.jpg', 1024, 'image/jpeg', true),
(2, 'macbook_2.jpg', 'macbook_2.jpg', 1024, 'image/jpeg', false),
(2, 'macbook_3.jpg', 'macbook_3.jpg', 1024, 'image/jpeg', false),

-- Изображения для квартиры
(3, 'apartment_1.jpg', 'apartment_1.jpg', 1024, 'image/jpeg', true),
(3, 'apartment_2.jpg', 'apartment_2.jpg', 1024, 'image/jpeg', false),
(3, 'apartment_3.jpg', 'apartment_3.jpg', 1024, 'image/jpeg', false),
(3, 'apartment_4.jpg', 'apartment_4.jpg', 1024, 'image/jpeg', false),

-- Изображения для дома
(4, 'house_1.jpg', 'house_1.jpg', 1024, 'image/jpeg', true),
(4, 'house_2.jpg', 'house_2.jpg', 1024, 'image/jpeg', false),
(4, 'house_3.jpg', 'house_3.jpg', 1024, 'image/jpeg', false),
(4, 'house_4.jpg', 'house_4.jpg', 1024, 'image/jpeg', false);

-- Добавляем несколько записей в избранное
INSERT INTO marketplace_favorites (user_id, listing_id)
VALUES
(1, 2),
(1, 3);

-- После уже существующих INSERT для категорий добавим:

-- Добавляем тестовые объявления
INSERT INTO marketplace_listings 
(user_id, category_id, title, description, price, condition, status, location, latitude, longitude, address_city, address_country) 
VALUES
-- Смартфон
(1, 
(SELECT id FROM marketplace_categories WHERE slug = 'phones'), 
'iPhone 14 Pro', 
'Продаю iPhone 14 Pro 256GB. Цвет - космический черный. На гарантии еще 9 месяцев. Полный комплект.',
95000, 
'used', 
'active', 
'Novi Sad, Serbia', 
45.2671, 
19.8335, 
'Novi Sad', 
'Serbia'),

-- Ноутбук
(1, 
(SELECT id FROM marketplace_categories WHERE slug = 'laptops'),
'MacBook Pro 16" M2',
'Новый MacBook Pro 16" с чипом M2 Pro. 32GB RAM, 1TB SSD. Максимальная комплектация.',
250000,
'new',
'active',
'Novi Sad, Serbia',
45.2551,
19.8452,
'Novi Sad',
'Serbia'),

-- Квартира
(1,
(SELECT id FROM marketplace_categories WHERE slug = 'apartments'),
'3-х комнатная квартира в центре',
'Просторная квартира с отличным ремонтом. 85м². Подземный паркинг. 2 санузла. Вид на реку.',
12500000,
'new',
'active',
'Novi Sad, Serbia',
45.2541,
19.8401,
'Novi Sad',
'Serbia');

-- Добавляем изображения
INSERT INTO marketplace_images 
(listing_id, file_path, file_name, file_size, content_type, is_main)
VALUES
-- Изображения для iPhone
(1, 'iphone14_1.jpg', 'iphone14_1.jpg', 1024, 'image/jpeg', true),
(1, 'iphone14_2.jpg', 'iphone14_2.jpg', 1024, 'image/jpeg', false),
-- Изображения для MacBook
(2, 'macbook16_1.jpg', 'macbook16_1.jpg', 1024, 'image/jpeg', true),
(2, 'macbook16_2.jpg', 'macbook16_2.jpg', 1024, 'image/jpeg', false),
-- Изображения для квартиры
(3, 'apartment_1.jpg', 'apartment_1.jpg', 1024, 'image/jpeg', true),
(3, 'apartment_2.jpg', 'apartment_2.jpg', 1024, 'image/jpeg', false);
=== /data/proj/hostel-booking-system/backend/migrations/0013_update_bed_bookings.up.sql ===

-- 0013_update_bed_bookings.up.sql
ALTER TABLE bed_bookings
ADD COLUMN IF NOT EXISTS status VARCHAR(20) NOT NULL DEFAULT 'pending'
    CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed'));

-- Создаем индекс для оптимизации поиска
CREATE INDEX IF NOT EXISTS idx_bed_bookings_dates_status 
ON bed_bookings(start_date, end_date, status);
=== /data/proj/hostel-booking-system/backend/migrations/0025_add_car_features.up.sql ===

-- backend/migrations/0025_update_car_features.up.sql
CREATE TABLE IF NOT EXISTS car_features (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    category VARCHAR(50),
    description TEXT
);

CREATE TABLE IF NOT EXISTS car_feature_links (
    car_id INTEGER REFERENCES cars(id) ON DELETE CASCADE,
    feature_id INTEGER REFERENCES car_features(id) ON DELETE CASCADE,
    PRIMARY KEY(car_id, feature_id)
);

-- Предварительное добавление features
INSERT INTO car_features (name, category) VALUES 
    ('Кондиционер', 'Климат'),
    ('Климат-контроль', 'Климат'),
    ('Круиз-контроль', 'Комфорт'),
    ('Парктроники', 'Безопасность'),
    ('Камера заднего вида', 'Безопасность'),
    ('Навигация', 'Мультимедиа'),
    ('Bluetooth', 'Мультимедиа'),
    ('USB', 'Мультимедиа'),
    ('AUX', 'Мультимедиа'),
    ('MP3', 'Мультимедиа'),
    ('CD', 'Мультимедиа'),
    ('Кожаный салон', 'Интерьер'),
    ('Люк', 'Интерьер'),
    ('Панорамная крыша', 'Интерьер'),
    ('Подогрев сидений', 'Комфорт'),
    ('Электропривод сидений', 'Комфорт'),
    ('Электропривод зеркал', 'Комфорт'),
    ('Электропривод окон', 'Комфорт')
ON CONFLICT (name) DO NOTHING;

CREATE INDEX IF NOT EXISTS idx_car_features_category ON car_features(category);
CREATE INDEX IF NOT EXISTS idx_car_feature_links_car ON car_feature_links(car_id);
CREATE INDEX IF NOT EXISTS idx_car_feature_links_feature ON car_feature_links(feature_id);
=== /data/proj/hostel-booking-system/backend/migrations/0033_add_updated_at_to_users.up.sql ===

-- backend/migrations/0033_add_updated_at_to_users.up.sql
ALTER TABLE users
    ADD COLUMN updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- Создаем триггер для автоматического обновления updated_at
CREATE OR REPLACE FUNCTION update_user_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_user_updated_at();
=== /data/proj/hostel-booking-system/backend/migrations/0003_add_constraints_and_indexes.down.sql ===


-- Remove constraints and indexes added in the up migration
ALTER TABLE bookings DROP CONSTRAINT valid_date_range;

DROP INDEX IF EXISTS idx_rooms_price;
DROP INDEX IF EXISTS idx_bookings_room_date;

=== /data/proj/hostel-booking-system/backend/migrations/0017_add_location_fields.down.sql ===

-- Удаляем триггер и функцию
DROP TRIGGER IF EXISTS validate_coordinates_trigger ON rooms;
DROP FUNCTION IF EXISTS validate_coordinates;

-- Удаляем индекс
DROP INDEX IF EXISTS idx_rooms_location;

-- Удаляем колонки
ALTER TABLE rooms
    DROP COLUMN IF EXISTS latitude,
    DROP COLUMN IF EXISTS longitude,
    DROP COLUMN IF EXISTS formatted_address;
=== /data/proj/hostel-booking-system/backend/migrations/0001_create_tables.down.sql ===

DROP TABLE IF EXISTS bookings CASCADE;
DROP TABLE IF EXISTS rooms CASCADE;
DROP TABLE IF EXISTS users CASCADE;

=== /data/proj/hostel-booking-system/backend/migrations/0026_add_test_cars.up.sql ===

-- backend/migrations/0026_add_test_cars.up.sql
-- Добавляем тестовые автомобили
INSERT INTO cars (
    make, model, year, price_per_day, location, latitude, longitude,
    description, seats, transmission, fuel_type, availability
) VALUES 
    -- Axia Neo
    ('Axia', 'Neo', 2023, 3500, 'Novi Sad, Serbia', 45.2671, 19.8335,
    'Axia Neo — это идеальный выбор для городских поездок. Современный дизайн и экологичный двигатель делают его популярным среди молодых профессионалов. Лёгкий в управлении, тихий и экономичный, этот компактный автомобиль станет вашим верным спутником в мегаполисе.',
    4, 'automatic', 'electric', true),

    -- Velaris Elegance
    ('Velaris', 'Elegance', 2022, 8000, 'Novi Sad, Serbia', 45.2551, 19.8452,
    'Velaris Elegance сочетает в себе роскошь и инновации. Мощный двигатель и просторный салон обеспечивают непревзойдённый комфорт даже на дальних поездках. Эта модель создаёт ощущение премиум-класса для тех, кто ценит утончённость и технологии.',
    5, 'automatic', 'petrol', true),

    -- Terra Cruiser X8
    ('Terra', 'Cruiser X8', 2023, 6500, 'Novi Sad, Serbia', 45.2460, 19.8235,
    'Terra Cruiser X8 — это надежный внедорожник, идеально подходящий для семейных поездок и активного отдыха. Благодаря просторному салону, гибридной системе и современным технологиям, он станет незаменимым помощником в любой ситуации.',
    7, 'automatic', 'hybrid', true),

    -- Navis Venture 9
    ('Navis', 'Venture 9', 2024, 5500, 'Novi Sad, Serbia', 45.2541, 19.8401,
    'Navis Venture 9 создан для больших компаний и комфортных путешествий. Благодаря вместительности, продуманной эргономике и современным технологиям, он обеспечивает максимальное удобство на дороге.',
    9, 'automatic', 'diesel', true);

-- Добавляем изображения для автомобилей
INSERT INTO car_images (
    car_id, file_path, file_name, file_size, content_type, is_main
) VALUES 
    (1, 'Axia_Neo.jpg', 'Axia_Neo.jpg', 1024, 'image/jpeg', true),
    (2, 'Velaris_Elegance.jpg', 'Velaris_Elegance.jpg', 1024, 'image/jpeg', true),
    (3, 'Terra_Cruiser.jpg', 'Terra_Cruiser.jpg', 1024, 'image/jpeg', true),
    (4, 'Navis_Venture.jpg', 'Navis_Venture.jpg', 1024, 'image/jpeg', true);

-- Добавляем особенности для каждого автомобиля
WITH new_cars AS (
  SELECT id, make, model FROM cars ORDER BY id DESC LIMIT 4
)
INSERT INTO car_feature_links (car_id, feature_id)
SELECT
  c.id,
  f.id
FROM new_cars c
CROSS JOIN car_features f
WHERE 
  (c.make = 'Axia' AND f.name IN (
    'Кондиционер', 'Климат-контроль', 'Навигация', 'Bluetooth', 'USB', 'Электропривод окон'
  ))
  OR 
  (c.make = 'Velaris' AND f.name IN (
    'Кондиционер', 'Климат-контроль', 'Круиз-контроль', 'Парктроники', 'Камера заднего вида',
    'Кожаный салон', 'Люк', 'Панорамная крыша', 'Подогрев сидений', 'Электропривод сидений',
    'Навигация', 'Bluetooth', 'USB', 'AUX', 'MP3'
  ))
  OR 
  (c.make = 'Terra' AND f.name IN (
    'Кондиционер', 'Климат-контроль', 'Круиз-контроль', 'Парктроники', 'Камера заднего вида',
    'Кожаный салон', 'Подогрев сидений', 'Навигация', 'Bluetooth', 'USB'
  ))
  OR 
  (c.make = 'Navis' AND f.name IN (
    'Кондиционер', 'Климат-контроль', 'Круиз-контроль', 'Парктроники', 'Камера заднего вида',
    'Навигация', 'Bluetooth', 'USB', 'AUX', 'MP3', 'Электропривод окон'
  ));
=== /data/proj/hostel-booking-system/backend/migrations/0007_add_room_images.up.sql ===

-- 0007_add_room_images.up.sql
CREATE TABLE room_images (
    id SERIAL PRIMARY KEY,
    room_id INT NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    is_main BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT unique_main_image_per_room UNIQUE (room_id, is_main) 
        DEFERRABLE INITIALLY DEFERRED
);

CREATE INDEX idx_room_images_room_id ON room_images(room_id);
=== /data/proj/hostel-booking-system/backend/migrations/0015_fix_available_beds.down.sql ===

-- Удаляем созданные функции и триггеры
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
DROP FUNCTION IF EXISTS update_available_beds();
DROP FUNCTION IF EXISTS get_available_beds(INTEGER, DATE, DATE);
DROP FUNCTION IF EXISTS initialize_available_beds();

-- Возвращаем простой триггер для обновления available_beds
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE rooms
    SET available_beds = (
        SELECT COUNT(*)
        FROM beds b
        WHERE b.room_id = NEW.room_id
        AND b.is_available = true
        AND b.id NOT IN (
            SELECT bed_id
            FROM bed_bookings
            WHERE status = 'confirmed'
            AND (
                (start_date <= CURRENT_DATE AND end_date >= CURRENT_DATE)
            )
        )
    )
    WHERE id = NEW.room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER bed_bookings_update_trigger
AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
FOR EACH ROW
EXECUTE FUNCTION update_available_beds();
=== /data/proj/hostel-booking-system/backend/migrations/0031_add_car_rating.up.sql ===

-- backend/migrations/0031_add_car_rating.up.sql

ALTER TABLE cars
ADD COLUMN rating DECIMAL(3,2) DEFAULT 0,
ADD COLUMN reviews_count INT DEFAULT 0;

-- Создаем триггер для обновления рейтинга
CREATE OR REPLACE FUNCTION update_car_rating()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.entity_type = 'car' THEN
        UPDATE cars
        SET 
            rating = (
                SELECT COALESCE(AVG(rating)::DECIMAL(3,2), 0)
                FROM reviews 
                WHERE entity_type = 'car' 
                AND entity_id = NEW.entity_id
                AND status = 'published'
            ),
            reviews_count = (
                SELECT COUNT(*)
                FROM reviews 
                WHERE entity_type = 'car' 
                AND entity_id = NEW.entity_id
                AND status = 'published'
            )
        WHERE id = NEW.entity_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER reviews_car_rating_update
AFTER INSERT OR UPDATE OR DELETE ON reviews
FOR EACH ROW
EXECUTE FUNCTION update_car_rating();
=== /data/proj/hostel-booking-system/backend/migrations/0011_extend_room_types.down.sql ===

-- 0011_extend_room_types.down.sql
DROP TABLE IF EXISTS bed_bookings;
DROP TABLE IF EXISTS beds;
ALTER TABLE rooms
    DROP COLUMN accommodation_type,
    DROP COLUMN is_shared,
    DROP COLUMN total_beds,
    DROP COLUMN available_beds,
    DROP COLUMN has_private_bathroom;
=== /data/proj/hostel-booking-system/backend/migrations/0002_add_price_per_night.down.sql ===

ALTER TABLE rooms DROP COLUMN price_per_night;
=== /data/proj/hostel-booking-system/backend/migrations/0016_fix_bed_availability.up.sql ===

-- Название файла: backend/migrations/0016_fix_bed_availability.up.sql

-- Удаляем старую версию функции если она существует
DROP FUNCTION IF EXISTS update_available_beds CASCADE;

-- Создаем новую функцию
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    WITH bed_count AS (
        SELECT 
            b.room_id,
            COUNT(DISTINCT b.id) as total_beds,
            COUNT(DISTINCT CASE 
                WHEN NOT EXISTS (
                    SELECT 1 
                    FROM bed_bookings bb 
                    WHERE bb.bed_id = b.id 
                    AND bb.status = 'confirmed'
                    AND (
                        (bb.start_date <= CURRENT_DATE AND bb.end_date >= CURRENT_DATE) OR
                        (bb.start_date >= CURRENT_DATE AND bb.start_date <= CURRENT_DATE)
                    )
                ) THEN b.id 
            END) as available_beds
        FROM beds b
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET 
        total_beds = bc.total_beds,
        available_beds = bc.available_beds
    FROM bed_count bc
    WHERE r.id = bc.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Пересоздаем триггер
DROP TRIGGER IF EXISTS bed_bookings_update_trigger ON bed_bookings;
CREATE TRIGGER bed_bookings_update_trigger
    AFTER INSERT OR UPDATE OR DELETE ON bed_bookings
    FOR EACH ROW
    EXECUTE FUNCTION update_available_beds();

-- Создаем функцию для получения количества доступных мест на определенные даты
CREATE OR REPLACE FUNCTION get_beds_availability(
    p_room_id INTEGER,
    p_start_date DATE,
    p_end_date DATE
) RETURNS INTEGER AS $$
BEGIN
    RETURN (
        SELECT COUNT(DISTINCT b.id)
        FROM beds b
        WHERE b.room_id = p_room_id
        AND b.is_available = true
        AND NOT EXISTS (
            SELECT 1
            FROM bed_bookings bb
            WHERE bb.bed_id = b.id
            AND bb.status = 'confirmed'
            AND (
                (bb.start_date <= p_end_date AND bb.end_date >= p_start_date) OR
                (bb.start_date >= p_start_date AND bb.start_date <= p_end_date)
            )
        )
    );
END;
$$ LANGUAGE plpgsql;
=== /data/proj/hostel-booking-system/backend/migrations/0006_add_room_address.up.sql ===

-- 0006_add_room_address.up.sql
ALTER TABLE rooms
    ADD COLUMN address_street VARCHAR(255) NOT NULL DEFAULT '',
    ADD COLUMN address_city VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_state VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_country VARCHAR(100) NOT NULL DEFAULT '',
    ADD COLUMN address_postal_code VARCHAR(20) NOT NULL DEFAULT '';

CREATE INDEX idx_rooms_city ON rooms(address_city);
CREATE INDEX idx_rooms_country ON rooms(address_country);
=== /data/proj/hostel-booking-system/backend/migrations/0020_add_demo_data.up.sql ===

-- backend/migrations/0020_add_demo_data.up.sql

-- Сначала фиксим ограничение для изображений
ALTER TABLE room_images DROP CONSTRAINT IF EXISTS unique_main_image_per_room;
CREATE UNIQUE INDEX unique_main_image_per_room ON room_images (room_id) WHERE is_main = true;

-- Очищаем существующие данные
TRUNCATE bed_images, beds, room_images, rooms, users CASCADE;

-- Сбрасываем последовательности
ALTER SEQUENCE rooms_id_seq RESTART WITH 1;
ALTER SEQUENCE beds_id_seq RESTART WITH 1;
ALTER SEQUENCE room_images_id_seq RESTART WITH 1;
ALTER SEQUENCE bed_images_id_seq RESTART WITH 1;
ALTER SEQUENCE users_id_seq RESTART WITH 1;

-- Создаем тестового пользователя
INSERT INTO users (name, email) VALUES
('Demo User', 'demo@example.com');

-- Создаем демонстрационные объекты

-- 1. Апартаменты в центре
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Уютные апартаменты в центре', 4, 80,
    'Dunavska 35', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'apartment', false, true,
    45.255421, 19.845241,
    'Dunavska 35, Novi Sad, Serbia'
);

-- Добавляем изображения для первых апартаментов
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '1.jpg', 'apartment1.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '2.jpg', 'apartment2.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '3.jpg', 'apartment3.jpg', 1024, 'image/jpeg', false);

-- 2. Апартаменты возле парка
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Просторные апартаменты у парка', 6, 120,
    'Futoška 12', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'apartment', false, true,
    45.249877, 19.833657,
    'Futoška 12, Novi Sad, Serbia'
);

-- Добавляем изображения для вторых апартаментов
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '4.jpg', 'apartment4.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '5.jpg', 'apartment5.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '6.jpg', 'apartment6.jpg', 1024, 'image/jpeg', false);

-- 3. Приватная комната в историческом центре
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Уютная комната в историческом центре', 2, 35,
    'Zmaj Jovina 4', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'room', false, true,
    45.254663, 19.844966,
    'Zmaj Jovina 4, Novi Sad, Serbia'
);

-- Добавляем изображения для первой приватной комнаты
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '7.jpg', 'room1.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '8.jpg', 'room2.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '1.jpg', 'room3.jpg', 1024, 'image/jpeg', false);

-- 4. Приватная комната возле набережной
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Комната с видом на Дунай', 2, 40,
    'Beogradski kej 31', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'room', false, true,
    45.256893, 19.861559,
    'Beogradski kej 31, Novi Sad, Serbia'
);

-- Добавляем изображения для второй приватной комнаты
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '2.jpg', 'room4.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '3.jpg', 'room5.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '4.jpg', 'room6.jpg', 1024, 'image/jpeg', false);

-- 5. Хостел в центре (койко-места)
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, total_beds, available_beds, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Центральный хостел', 6, 12,
    'Miletićeva 15', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'bed', true, 6, 6, true,
    45.252558, 19.842895,
    'Miletićeva 15, Novi Sad, Serbia'
);

-- Добавляем изображения для первого хостела
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '5.jpg', 'hostel1.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '6.jpg', 'hostel2.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '7.jpg', 'hostel3.jpg', 1024, 'image/jpeg', false);

-- Добавляем кровати для первого хостела
INSERT INTO beds (room_id, bed_number, price_per_night, is_available) VALUES
((SELECT MAX(id) FROM rooms), 11, 12, true),
((SELECT MAX(id) FROM rooms), 12, 12, true),
((SELECT MAX(id) FROM rooms), 21, 12, true),
((SELECT MAX(id) FROM rooms), 22, 12, true),
((SELECT MAX(id) FROM rooms), 31, 12, true),
((SELECT MAX(id) FROM rooms), 32, 12, true);

-- Добавляем изображения для кроватей первого хостела
INSERT INTO bed_images (bed_id, file_path, file_name, file_size, content_type) VALUES
((SELECT MAX(id) FROM beds), '8.jpg', 'bed1.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) FROM beds), '1.jpg', 'bed2.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 1 FROM beds), '2.jpg', 'bed3.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 2 FROM beds), '3.jpg', 'bed4.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 3 FROM beds), '4.jpg', 'bed5.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 4 FROM beds), '5.jpg', 'bed6.jpg', 1024, 'image/jpeg');

-- 6. Хостел возле вокзала (койко-места)
INSERT INTO rooms (
    name, capacity, price_per_night,
    address_street, address_city, address_state, address_country, address_postal_code,
    accommodation_type, is_shared, total_beds, available_beds, has_private_bathroom,
    latitude, longitude, formatted_address
) VALUES (
    'Хостел у вокзала', 4, 10,
    'Bulevar Jaše Tomića 5', 'Novi Sad', 'Vojvodina', 'Serbia', '21000',
    'bed', true, 4, 4, true,
    45.260721, 19.831572,
    'Bulevar Jaše Tomića 5, Novi Sad, Serbia'
);

-- Добавляем изображения для второго хостела
INSERT INTO room_images (room_id, file_path, file_name, file_size, content_type, is_main) VALUES
((SELECT MAX(id) FROM rooms), '6.jpg', 'hostel4.jpg', 1024, 'image/jpeg', true),
((SELECT MAX(id) FROM rooms), '7.jpg', 'hostel5.jpg', 1024, 'image/jpeg', false),
((SELECT MAX(id) FROM rooms), '8.jpg', 'hostel6.jpg', 1024, 'image/jpeg', false);

-- Добавляем кровати для второго хостела
INSERT INTO beds (room_id, bed_number, price_per_night, is_available) VALUES
((SELECT MAX(id) FROM rooms), 1, 10, true),
((SELECT MAX(id) FROM rooms), 2, 10, true),
((SELECT MAX(id) FROM rooms), 3, 10, true),
((SELECT MAX(id) FROM rooms), 4, 10, true);

-- Добавляем изображения для кроватей второго хостела
INSERT INTO bed_images (bed_id, file_path, file_name, file_size, content_type) VALUES
((SELECT MAX(id) FROM beds), '1.jpg', 'bed7.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 1 FROM beds), '2.jpg', 'bed8.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 2 FROM beds), '3.jpg', 'bed9.jpg', 1024, 'image/jpeg'),
((SELECT MAX(id) - 3 FROM beds), '4.jpg', 'bed10.jpg', 1024, 'image/jpeg');


=== /data/proj/hostel-booking-system/backend/migrations/0028_marketplace.down.sql ===

-- Удаляем таблицы в правильном порядке (с учетом зависимостей)
DROP TABLE IF EXISTS marketplace_favorites;
DROP TABLE IF EXISTS marketplace_images;
DROP TABLE IF EXISTS marketplace_listings;
DROP TABLE IF EXISTS marketplace_categories;
=== /data/proj/hostel-booking-system/backend/migrations/0003_add_constraints_and_indexes.up.sql ===


-- Add additional constraints and indexes to fix issues
ALTER TABLE bookings
    ADD CONSTRAINT valid_date_range 
    CHECK (start_date < end_date AND start_date >= CURRENT_DATE);

-- Indexes to optimize queries
CREATE INDEX idx_rooms_price ON rooms (price_per_night);
CREATE INDEX idx_bookings_room_date ON bookings (room_id, start_date, end_date);

=== /data/proj/hostel-booking-system/backend/migrations/0030_add_review_votes_columns.up.sql.sql ===

-- /backend/migrations/0030_add_review_votes_columns.up.sql
ALTER TABLE reviews 
ADD COLUMN helpful_votes INT DEFAULT 0,
ADD COLUMN not_helpful_votes INT DEFAULT 0;
=== /data/proj/hostel-booking-system/backend/migrations/0024_add_car.up.sql ===

-- backend/migrations/0024_add_car.up.sql
CREATE TABLE cars (
    id SERIAL PRIMARY KEY,
    make VARCHAR(50) NOT NULL,
    model VARCHAR(50) NOT NULL,
    year INT NOT NULL,
    price_per_day NUMERIC(10, 2) NOT NULL,
    availability BOOLEAN DEFAULT TRUE,
    location VARCHAR(100) NOT NULL,
    latitude DECIMAL(10, 8),
    longitude DECIMAL(11, 8),
    description TEXT,
    seats INT DEFAULT 4,
    transmission VARCHAR(20) CHECK (transmission IN ('manual', 'automatic')),
    fuel_type VARCHAR(20) CHECK (fuel_type IN ('petrol', 'diesel', 'electric', 'hybrid')),
    daily_mileage_limit INT,
    insurance_included BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблица категорий
CREATE TABLE car_categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    description TEXT
);

-- Таблица особенностей
CREATE TABLE car_features (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    category VARCHAR(50),  -- Для группировки особенностей (комфорт, безопасность и т.д.)
    description TEXT
);

-- Связующая таблица автомобиль-особенности
CREATE TABLE car_feature_links (
    car_id INT REFERENCES cars(id) ON DELETE CASCADE,
    feature_id INT REFERENCES car_features(id) ON DELETE CASCADE,
    PRIMARY KEY (car_id, feature_id)
);

-- Таблица изображений
CREATE TABLE car_images (
    id SERIAL PRIMARY KEY,
    car_id INT REFERENCES cars(id) ON DELETE CASCADE,
    file_path VARCHAR(255) NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size INT NOT NULL,
    content_type VARCHAR(100) NOT NULL,
    is_main BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблица бронирований
CREATE TABLE car_bookings (
    id SERIAL PRIMARY KEY,
    car_id INT REFERENCES cars(id) ON DELETE CASCADE,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    start_date TIMESTAMP NOT NULL,
    end_date TIMESTAMP NOT NULL,
    pickup_location TEXT,
    dropoff_location TEXT,
    status VARCHAR(20) NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'confirmed', 'cancelled', 'completed')),
    total_price DECIMAL(10, 2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Индексы
CREATE INDEX idx_cars_location ON cars(location);
CREATE INDEX idx_cars_availability ON cars(availability);
CREATE INDEX idx_car_bookings_dates ON car_bookings(start_date, end_date);
CREATE INDEX idx_car_bookings_status ON car_bookings(status);
CREATE INDEX idx_car_images_car_id ON car_images(car_id);
CREATE UNIQUE INDEX unique_main_image_per_car ON car_images (car_id) WHERE is_main = true;

-- Добавляем предопределенные особенности
INSERT INTO car_features (name, category) VALUES
    ('Кондиционер', 'Климат'),
    ('Климат-контроль', 'Климат'),
    ('Круиз-контроль', 'Комфорт'),
    ('Парктроники', 'Безопасность'),
    ('Камера заднего вида', 'Безопасность'),
    ('Навигация', 'Мультимедиа'),
    ('Bluetooth', 'Мультимедиа'),
    ('USB', 'Мультимедиа'),
    ('AUX', 'Мультимедиа'),
    ('MP3', 'Мультимедиа'),
    ('CD', 'Мультимедиа'),
    ('Кожаный салон', 'Интерьер'),
    ('Люк', 'Интерьер'),
    ('Панорамная крыша', 'Интерьер'),
    ('Подогрев сидений', 'Комфорт'),
    ('Электропривод сидений', 'Комфорт'),
    ('Электропривод зеркал', 'Комфорт'),
    ('Электропривод окон', 'Комфорт');

-- Добавляем категории автомобилей
INSERT INTO car_categories (name, description) VALUES
    ('Эконом', 'Бюджетные автомобили с хорошей топливной эффективностью'),
    ('Комфорт', 'Автомобили среднего класса с улучшенным комфортом'),
    ('Премиум', 'Люксовые автомобили с премиальными удобствами'),
    ('Внедорожник', 'Автомобили повышенной проходимости для путешествий'),
    ('Минивэн', 'Просторные автомобили для групповых поездок');
=== /data/proj/hostel-booking-system/backend/migrations/0033_add_updated_at_to_users.down.sql ===

-- backend/migrations/0033_add_updated_at_to_users.down.sql
DROP TRIGGER IF EXISTS update_users_updated_at ON users;
DROP FUNCTION IF EXISTS update_user_updated_at();
ALTER TABLE users DROP COLUMN IF EXISTS updated_at;
=== /data/proj/hostel-booking-system/backend/migrations/0027_add_room_reviews.up.sql ===

-- Создаем таблицу отзывов
CREATE TABLE room_reviews (
    id SERIAL PRIMARY KEY,
    room_id INT REFERENCES rooms(id) ON DELETE CASCADE,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    rating INT CHECK (rating >= 1 AND rating <= 5),
    comment TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(room_id, user_id) -- один отзыв от пользователя на комнату
);

-- Индексы для оптимизации запросов
CREATE INDEX idx_room_reviews_room_id ON room_reviews(room_id);
CREATE INDEX idx_room_reviews_user_id ON room_reviews(user_id);
CREATE INDEX idx_room_reviews_rating ON room_reviews(rating);

-- Индексы для улучшения производительности фильтрации и сортировки
CREATE INDEX idx_rooms_price_created ON rooms(price_per_night, created_at);
CREATE INDEX idx_rooms_type_price ON rooms(accommodation_type, price_per_night);
CREATE INDEX idx_rooms_city_country ON rooms(address_city, address_country);
=== /data/proj/hostel-booking-system/backend/migrations/0019_update_bed_availability_trigger.up.sql ===

-- Обновляем функцию подсчета доступных мест
CREATE OR REPLACE FUNCTION update_available_beds()
RETURNS TRIGGER AS $$
BEGIN
    -- Обновляем количество доступных мест для комнаты с учетом текущих броней
    WITH current_bookings AS (
        SELECT b.room_id,
               COUNT(DISTINCT bb.bed_id) as booked_beds
        FROM beds b
        JOIN bed_bookings bb ON b.id = bb.bed_id
        WHERE bb.status = 'confirmed'
        AND bb.start_date <= CURRENT_DATE
        AND bb.end_date >= CURRENT_DATE
        GROUP BY b.room_id
    )
    UPDATE rooms r
    SET available_beds = COALESCE(r.total_beds, 0) - COALESCE(cb.booked_beds, 0)
    FROM current_bookings cb
    WHERE r.id = cb.room_id
    AND r.accommodation_type = 'bed';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
=== /data/proj/hostel-booking-system/backend/migrations/0029_marketplace_Reviews.up.sql ===

-- /backend/migrations/0029_create_reviews.up.sql

-- Таблица для хранения отзывов
CREATE TABLE reviews (
    id SERIAL PRIMARY KEY,
    user_id INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    entity_type VARCHAR(50) NOT NULL, -- 'listing', 'room', 'car'
    entity_id INT NOT NULL,
    rating INT NOT NULL CHECK (rating >= 1 AND rating <= 5),
    comment TEXT,
    pros TEXT,
    cons TEXT,
    photos TEXT[], -- Массив URL фотографий
    likes_count INT DEFAULT 0,
    is_verified_purchase BOOLEAN DEFAULT false,
    status VARCHAR(20) DEFAULT 'published' CHECK (status IN ('draft', 'published', 'hidden')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Индексы для оптимизации запросов
CREATE INDEX idx_reviews_entity ON reviews(entity_type, entity_id);
CREATE INDEX idx_reviews_user ON reviews(user_id);
CREATE INDEX idx_reviews_rating ON reviews(rating);
CREATE INDEX idx_reviews_status ON reviews(status);

-- Таблица для ответов на отзывы
CREATE TABLE review_responses (
    id SERIAL PRIMARY KEY,
    review_id INT NOT NULL REFERENCES reviews(id) ON DELETE CASCADE,
    user_id INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    response TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблица для голосов за полезность отзывов
CREATE TABLE review_votes (
    review_id INT NOT NULL REFERENCES reviews(id) ON DELETE CASCADE,
    user_id INT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    vote_type VARCHAR(20) NOT NULL CHECK (vote_type IN ('helpful', 'not_helpful')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (review_id, user_id)
);

-- Функция для автоматического обновления updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Триггеры для обновления updated_at
CREATE TRIGGER update_reviews_updated_at
    BEFORE UPDATE ON reviews
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_review_responses_updated_at
    BEFORE UPDATE ON review_responses
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Вспомогательные функции для работы с рейтингами
CREATE OR REPLACE FUNCTION calculate_entity_rating(p_entity_type VARCHAR, p_entity_id INT)
RETURNS NUMERIC AS $$
DECLARE
    avg_rating NUMERIC;
BEGIN
    SELECT COALESCE(AVG(rating)::NUMERIC(3,2), 0)
    INTO avg_rating
    FROM reviews
    WHERE entity_type = p_entity_type 
    AND entity_id = p_entity_id 
    AND status = 'published';
    
    RETURN avg_rating;
END;
$$ LANGUAGE plpgsql;
=== /data/proj/hostel-booking-system/backend/migrations/0030_add_review_votes_columns.down.sql ===

-- /backend/migrations/0030_add_review_votes_columns.down.sql
ALTER TABLE reviews 
DROP COLUMN helpful_votes,
DROP COLUMN not_helpful_votes;
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/src/components/reviews/ReviewComponents.jsx ===

// frontend/hostel-frontend/src/components/reviews/ReviewComponents.jsx
import React, { useState } from 'react';
import { useMediaQuery } from '@mui/material';
import GalleryViewer from '../shared/GalleryViewer';
import {
    Box,
    Typography,
    Rating,
    Button,
    Card,
    CardContent,
    Stack,
    Avatar,
    TextField,
    LinearProgress,
    IconButton,
    Chip,
    Menu,
    MenuItem
} from '@mui/material';
import {
    ThumbsUp,
    ThumbsDown,
    MessageSquare,
    MoreVertical,
    Camera,
    Flag,
    Edit,
    Trash2,
    CheckCircle2,
    PencilLine
} from 'lucide-react';

// Компонент формы создания/редактирования отзыва
const ReviewForm = ({ onSubmit, initialData = null, onCancel, entityType, entityId }) => {
    const [formData, setFormData] = useState({
        rating: initialData?.rating || 0,
        comment: initialData?.comment || '',
        pros: initialData?.pros || '',
        cons: initialData?.cons || ''
    });

    const [photoFiles, setPhotoFiles] = useState([]);
    const [previewUrls, setPreviewUrls] = useState([]);

    const handleChange = (field) => (event) => {
        setFormData(prev => ({
            ...prev,
            [field]: event.target.value
        }));
    };

    const handlePhotoAdd = (event) => {
        const files = Array.from(event.target.files);
        
        const validFiles = files.filter(file => {
            const isValidType = file.type.startsWith('image/');
            const isValidSize = file.size <= 15 * 1024 * 1024; // 15MB
            return isValidType && isValidSize;
        });

        if (validFiles.length + photoFiles.length > 10) {
            alert('Можно загрузить максимум 10 фотографий');
            return;
        }

        setPhotoFiles(prev => [...prev, ...validFiles]);

        // Создаем URL для предпросмотра
        validFiles.forEach(file => {
            const url = URL.createObjectURL(file);
            setPreviewUrls(prev => [...prev, url]);
        });
    };

    const handleRemovePhoto = (index) => {
        setPhotoFiles(prev => prev.filter((_, i) => i !== index));
        setPreviewUrls(prev => prev.filter((_, i) => i !== index));
    };

    const handleSubmit = (e) => {
        e.preventDefault();

        const reviewData = {
            entity_type: entityType,
            entity_id: entityId,
            rating: parseInt(formData.rating),
            comment: formData.comment,
            pros: formData.pros,
            cons: formData.cons
        };

        let photosFormData = null;
        if (photoFiles.length > 0) {
            photosFormData = new FormData();
            photoFiles.forEach(file => {
                photosFormData.append('photos', file);
            });
        }

        onSubmit({ reviewData, photosFormData });
    };

    return (
        <Box component="form" onSubmit={handleSubmit} sx={{ p: 2 }}>
            <Stack spacing={3}>
                <Box>
                    <Typography gutterBottom>Общая оценка</Typography>
                    <Rating
                        value={formData.rating}
                        onChange={(_, newValue) => {
                            setFormData(prev => ({ ...prev, rating: newValue }));
                        }}
                        size="large"
                    />
                </Box>

                <TextField
                    label="Комментарий"
                    multiline
                    rows={4}
                    value={formData.comment}
                    onChange={handleChange('comment')}
                    fullWidth
                />

                <TextField
                    label="Достоинства"
                    multiline
                    rows={2}
                    value={formData.pros}
                    onChange={handleChange('pros')}
                    fullWidth
                />

                <TextField
                    label="Недостатки"
                    multiline
                    rows={2}
                    value={formData.cons}
                    onChange={handleChange('cons')}
                    fullWidth
                />

                <Box>
                    <Button
                        component="label"
                        startIcon={<Camera />}
                        variant="outlined"
                    >
                        Добавить фото
                        <input
                            type="file"
                            hidden
                            multiple
                            accept="image/*"
                            onChange={handlePhotoAdd}
                        />
                    </Button>

                    {previewUrls.length > 0 && (
                        <Box sx={{ mt: 2 }}>
                            <GalleryViewer
                                images={previewUrls}
                                galleryMode="thumbnails"
                                thumbnailSize={{ width: '100%', height: '100px' }}
                                gridColumns={{ xs: 4, sm: 3, md: 2 }}
                            />
                        </Box>
                    )}
                </Box>

                <Stack direction="row" spacing={2} justifyContent="flex-end">
                    <Button onClick={onCancel}>
                        Отмена
                    </Button>
                    <Button
                        type="submit"
                        variant="contained"
                        disabled={!formData.rating || !formData.comment}
                    >
                        {initialData ? 'Сохранить' : 'Опубликовать'}
                    </Button>
                </Stack>
            </Stack>
        </Box>
    );
};

// Компонент отдельного отзыва
const ReviewCard = ({ review, currentUserId, onVote, onReply, onEdit, onDelete, onReport }) => {
    const [showGallery, setShowGallery] = useState(false);
    const [selectedImageIndex, setSelectedImageIndex] = useState(0);
     const [showReplyForm, setShowReplyForm] = useState(false);
 
    const [replyText, setReplyText] = useState('');
    const [menuAnchor, setMenuAnchor] = useState(null);

    const isMobile = useMediaQuery((theme) => theme.breakpoints.down('sm'));

    const handleReplySubmit = () => {
        onReply(review.id, replyText);
        setReplyText('');
        setShowReplyForm(false);
    };

    return (
        <Card sx={{ mb: 2 }}>
            <CardContent>
                <Stack spacing={2}>
                    {/* Заголовок с информацией о пользователе */}
                    <Stack
                        direction="row"
                        alignItems="center"
                        justifyContent="space-between"
                    >
                        <Stack direction="row" spacing={2} alignItems="center">
                            <Avatar src={review.user?.picture_url} />
                            <Box>
                                <Typography variant="subtitle1">
                                    {review.user?.name}
                                </Typography>
                                <Typography variant="caption" color="text.secondary">
                                    {new Date(review.created_at).toLocaleDateString()}
                                </Typography>
                            </Box>

                            {review.is_verified_purchase && (
                                isMobile ? (
                                    <CheckCircle2 size={20} color="green" />
                                ) : (
                                    <Chip
                                        icon={<CheckCircle2 size={16} />}
                                        label="Проверенная покупка"
                                        size="small"
                                        color="success"
                                    />
                                )
                            )}
                        </Stack>

                        {(currentUserId === review.user_id) && (
                            <>
                                <IconButton onClick={(e) => setMenuAnchor(e.currentTarget)}>
                                    <MoreVertical />
                                </IconButton>
                                <Menu
                                    anchorEl={menuAnchor}
                                    open={Boolean(menuAnchor)}
                                    onClose={() => setMenuAnchor(null)}
                                >
                                    <MenuItem onClick={() => {
                                        onEdit(review);
                                        setMenuAnchor(null);
                                    }}>
                                        <Edit size={16} style={{ marginRight: 8 }} />
                                        Редактировать
                                    </MenuItem>
                                    <MenuItem onClick={() => {
                                        onDelete(review.id);
                                        setMenuAnchor(null);
                                    }}>
                                        <Trash2 size={16} style={{ marginRight: 8 }} />
                                        Удалить
                                    </MenuItem>
                                </Menu>
                            </>
                        )}
                    </Stack>

                    <Rating value={review.rating} readOnly />

                    {review.comment && (
                        <Typography>{review.comment}</Typography>
                    )}

                    {review.pros && (
                        <Box>
                            <Typography color="success.main" variant="subtitle2">
                                Достоинства:
                            </Typography>
                            <Typography>{review.pros}</Typography>
                        </Box>
                    )}

                    {review.cons && (
                        <Box>
                            <Typography color="error.main" variant="subtitle2">
                                Недостатки:
                            </Typography>
                            <Typography>{review.cons}</Typography>
                        </Box>
                    )}

                    {/* Галерея фотографий */}
                    {review.photos?.length > 0 && (
                        <>
                            {/* Превью фотографий */}
                            <Box sx={{ mt: 2 }}>
                                <GalleryViewer
                                    images={review.photos}
                                    galleryMode="thumbnails"
                                    thumbnailSize={{ width: '100%', height: '100px' }}
                                    gridColumns={{ xs: 4, sm: 3, md: 2 }}
                                    onClick={(index) => {
                                        setSelectedImageIndex(index);
                                        setShowGallery(true);
                                    }}
                                />
                            </Box>

                            {/* Полноэкранный просмотр */}
                            <GalleryViewer
                                images={review.photos}
                                open={showGallery}
                                onClose={() => setShowGallery(false)}
                                initialIndex={selectedImageIndex}
                                galleryMode="fullscreen"
                            />
                        </>
                    )}

                    {/* Кнопки голосования */}
                    <Stack direction="row" spacing={2}>
                        <Button
                            size="small"
                            onClick={() => onVote(review.id, 'helpful')}
                            startIcon={<ThumbsUp />}
                            variant={review.current_user_vote === 'helpful' ? 'contained' : 'outlined'}
                        >
                            {isMobile ? (
                                `(${review.votes_count?.helpful || 0})`
                            ) : (
                                `Полезно (${review.votes_count?.helpful || 0})`
                            )}
                        </Button>
                        <Button
                            size="small"
                            onClick={() => onVote(review.id, 'not_helpful')}
                            startIcon={<ThumbsDown />}
                            variant={review.current_user_vote === 'not_helpful' ? 'contained' : 'outlined'}
                        >
                            {isMobile ? (
                                `(${review.votes_count?.not_helpful || 0})`
                            ) : (
                                `Не полезно (${review.votes_count?.not_helpful || 0})`
                            )}
                        </Button>

                        {isMobile ? (
                            <>
                                <IconButton onClick={() => setShowReplyForm(!showReplyForm)}>
                                    <MessageSquare size={20} />
                                </IconButton>
                                <IconButton onClick={() => onReport(review.id)}>
                                    <Flag size={20} />
                                </IconButton>
                            </>
                        ) : (
                            <>
                                <Button
                                    size="small"
                                    startIcon={<MessageSquare />}
                                    onClick={() => setShowReplyForm(!showReplyForm)}
                                >
                                    Ответить
                                </Button>
                                <Button
                                    size="small"
                                    startIcon={<Flag />}
                                    onClick={() => onReport(review.id)}
                                >
                                    Пожаловаться
                                </Button>
                            </>
                        )}
                    </Stack>

                    {showReplyForm && (
                        <Box>
                            <TextField
                                fullWidth
                                multiline
                                rows={3}
                                placeholder="Напишите ответ..."
                                value={replyText}
                                onChange={(e) => setReplyText(e.target.value)}
                            />
                            <Stack direction="row" spacing={1} sx={{ mt: 1 }}>
                                <Button
                                    variant="contained"
                                    size="small"
                                    onClick={handleReplySubmit}
                                    disabled={!replyText.trim()}
                                >
                                    Ответить
                                </Button>
                                <Button
                                    size="small"
                                    onClick={() => {
                                        setShowReplyForm(false);
                                        setReplyText('');
                                    }}
                                >
                                    Отмена
                                </Button>
                            </Stack>
                        </Box>
                    )}

                    {review.responses && review.responses.length > 0 && (
                        <Box sx={{ pl: 4 }}>
                            {review.responses.map((response, index) => (
                                <Box key={index} sx={{ mt: 2 }}>
                                    <Stack direction="row" spacing={2} alignItems="center">
                                        <Avatar
                                            src={response.user?.picture_url}
                                            sx={{ width: 24, height: 24 }}
                                        />
                                        <Typography variant="subtitle2">
                                            {response.user?.name}
                                        </Typography>
                                        <Typography variant="caption" color="text.secondary">
                                            {new Date(response.created_at).toLocaleDateString()}
                                        </Typography>
                                    </Stack>
                                    <Typography sx={{ mt: 1 }}>
                                        {response.response}
                                    </Typography>
                                </Box>
                            ))}
                        </Box>
                    )}
                </Stack>
            </CardContent>
        </Card>
    );
};



// Компонент статистики рейтингов
const RatingStats = ({ stats }) => {
    return (
        <Stack direction="row" spacing={4} alignItems="center" sx={{ mb: 4 }}>
            <Box textAlign="center">
                <Typography variant="h3" fontWeight="bold">
                    {stats.average_rating?.toFixed(1) || "0.0"}
                </Typography>
                <Rating
                    value={stats.average_rating || 0}
                    readOnly
                    precision={0.1}
                />
                <Typography color="text.secondary">
                    {stats.total_reviews || 0} отзывов
                </Typography>
            </Box>

            <Box flex={1}>
                {[5, 4, 3, 2, 1].map(rating => (
                    <Stack
                        key={rating}
                        direction="row"
                        spacing={2}
                        alignItems="center"
                        sx={{ mb: 1 }}
                    >
                        <Typography minWidth={20}>{rating}</Typography>
                        <LinearProgress
                            variant="determinate"
                            value={((stats.rating_distribution?.[rating] || 0) /
                                (stats.total_reviews || 1)) * 100}
                            sx={{ flex: 1, height: 8, borderRadius: 1 }}
                        />
                        <Typography minWidth={40}>
                            {stats.rating_distribution?.[rating] || 0}
                        </Typography>
                    </Stack>
                ))}
            </Box>
        </Stack>
    );
};

export { ReviewForm, ReviewCard, RatingStats };
=== /data/proj/hostel-booking-system/frontend/hostel-frontend/.env ===

# Frontend environment variables for production
REACT_APP_GOOGLE_MAPS_API_KEY=AIzaSyBISWAfMMEdWSIKL9WASQIWeKbSQo4Dv48
REACT_APP_API_URL=https://landhub.rs/api
REACT_APP_BACKEND_URL=https://landhub.rs
FRONTEND_URL=https://landhub.rs
GENERATE_SOURCEMAP=false
REACT_APP_WS_URL=ws://localhost:3000/ws/chat
=== /data/proj/hostel-booking-system/backend/.env ===

# Backend environment variables
DATABASE_URL=postgres://postgres:c9XWc7Cm@db:5432/hostel_db?sslmode=disable
GOOGLE_CLIENT_ID=917315728307-au9ga5fl7o3bbid9nv7e4l92gut194pq.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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
GOOGLE_OAUTH_REDIRECT_URL=https://landhub.rs/auth/google/callback
FRONTEND_URL=https://landhub.rs
ENV=production
PORT=3000

=== /data/proj/hostel-booking-system/frontend/hostel-frontend/public/manifest.json ===

{
  "short_name": "Prodavnica App",
  "name": "Sale Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

=== /data/proj/hostel-booking-system/frontend/hostel-frontend/package.json ===

{
  "name": "hostel-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@googlemaps/adv-markers-utils": "^1.2.4",
    "@googlemaps/js-api-loader": "^1.16.8",
    "@googlemaps/markerclusterer": "^2.5.3",
    "@mui/icons-material": "^5.15.0",
    "@mui/material": "^5.16.7",
    "@react-google-maps/api": "^2.19.3",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.7.7",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.468.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.28.1",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4",
    "zustand": "^5.0.3"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "start:dev": "react-scripts start --proxy http://localhost:8080"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "compilerOptions": {
    "baseUrl": "src"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@types/date-fns": "^2.6.3"
  }
}

=== /data/proj/hostel-booking-system/frontend/package.json ===

{
  "name": "hostel-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@mui/icons-material": "^5.15.0",
    "@mui/material": "^5.16.7",
    "@react-google-maps/api": "^2.19.3",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.7.7",
    "lucide-react": "^0.468.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.28.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "PORT=3001 WDS_SOCKET_PORT=3001 DANGEROUSLY_DISABLE_HOST_CHECK=true react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
=== /data/proj/hostel-booking-system/package.json ===

{
  "name": "hostel-booking-system",
  "version": "1.0.0",
  "description": "Hostel booking system with React frontend and Go backend",
  "private": true,
  "workspaces": [
    "frontend/*"
  ],
  "scripts": {
    "start": "cd frontend/hostel-frontend && npm start",
    "build": "cd frontend/hostel-frontend && npm run build"
  },
  "dependencies": {
    "@googlemaps/js-api-loader": "^1.16.8",
    "@googlemaps/markerclusterer": "^2.5.3"
  }
}

=== /data/proj/hostel-booking-system/docker-compose.override.yml ===

version: '3.8'

services:
  frontend:
    build:
      context: ./frontend/hostel-frontend
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=development
      - PORT=3001
      - WDS_SOCKET_PORT=3001
      - DANGEROUSLY_DISABLE_HOST_CHECK=true
    volumes:
      - ./frontend/hostel-frontend:/app
      # Исключаем node_modules из монтирования
      - /app/node_modules
    networks:
      - hostel_network

networks:
  hostel_network:
    driver: bridge
=== /data/proj/hostel-booking-system/docker-compose.prod.yml ===

version: '3.8'

services:
  db:
    image: postgres:15
    container_name: hostel_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: c9XWc7Cm
      POSTGRES_DB: hostel_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "postgres"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - hostel_network

  migrate:
    image: migrate/migrate
    volumes:
      - ./backend/migrations:/migrations
    command: [
      "-path", "/migrations",
      "-database", "postgres://postgres:c9XWc7Cm@db:5432/hostel_db?sslmode=disable",
      "up"
    ]
    depends_on:
      db:
        condition: service_healthy

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      - APP_MODE=production
      - ENV_FILE=.env
      - WS_ENABLED=true      
    volumes:
      - ./backend/uploads:/app/uploads
    expose:
      - "3000"
    ports:
      - "3000:3000"
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]
      interval: 10s
      timeout: 5s
      retries: 3
    networks:
      - hostel_network

  nginx:
    image: nginx:alpine
    container_name: hostel_nginx
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf
      - ./frontend/hostel-frontend/build:/usr/share/nginx/html:ro
      - ./backend/uploads:/usr/share/nginx/uploads
      - ./certbot/conf:/etc/letsencrypt
      - ./certbot/www:/var/www/certbot
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost"]
      interval: 10s
      timeout: 5s
      retries: 3
    networks:
      - hostel_network

volumes:
  postgres_data:

networks:
  hostel_network:
    driver: bridge
=== /data/proj/hostel-booking-system/deploy/docker-compose.yml ===

version: '3.8'

services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

  backend:
    build:
      context: ../backend
    ports:
      - "3000:3000"
    env_file:
      - ../backend/.env
    depends_on:
      - db
    command: [ "go", "run", "main.go" ]
    networks:
      - hostel_network

  frontend:
    build:
      context: ../frontend/hostel-frontend
    ports:
      - "3001:3000"
    environment:
      - REACT_APP_API_URL=https://landhub.rs/api
    networks:
      - hostel_network

volumes:
  db_data:


networks:
  hostel_network:
    driver: bridge

=== /data/proj/hostel-booking-system/docker-compose.yml ===

version: '3.8'

services:
  db:
    image: postgres:15
    container_name: hostel_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: hostel_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    env_file:
      - ./backend/.env.local
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - ./backend/uploads:/app/uploads
    environment:
      - UPLOAD_DIR=/app/uploads

  migrate:
    image: migrate/migrate
    volumes:
      - ./backend/migrations:/migrations
    command: [
      "-path", "/migrations",
      "-database", "postgres://postgres:password@db:5432/hostel_db?sslmode=disable",
      "up"
    ]
    depends_on:
      db:
        condition: service_healthy

volumes:
  postgres_data:

